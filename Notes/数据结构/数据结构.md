[TOC]



# 线性表



> 链表编程注意问题：
>
> 以下情况代码能否正常工作：
>
> 1. 链表为空时
>
> 2. 链表只包含一个结点时
> 3. 处理头、尾结点时

## 单链表类

==做题时直接边输入边操作，不用创建类== ==函数形参加上类的类数据成员即可==

```c++
#include <iostream>
using namespace std;

class Node
{
public:
    Node():data(0),next(NULL){};
    Node(int d):data(d),next(NULL){};//可以简化申请新节点空间
    int data;
    Node * next;
};

class Linklist
{
public:
    Linklist(int n):head(new Node()),length(n){};
    ~Linklist();
    void CreateLink();
    Node* Locate(int k);
    Node* Search(int item);
    void InsertNode(int k,int d);
    void DeleteNode(int k);
    void Reverse(Node * s);
    void PrintLink();
private:
    Node * head;
    int length;//初始创建链表的长度，可修改

};


//销毁链表
Linklist::~Linklist()
{
    Node * p;
    while(head!=NULL)
    {
        p=head;
        head=head->next;
        delete p;
    }
}

//尾插法创建含哨兵项链表
void Linklist::CreateLink()
{
    Node * p=head;
    Node * rear=head;
    int count=length;
    int temp;
    while(count-->0)
    {
        if(scanf("%d",&temp)){};
        p=new Node(temp);
        rear->next=p;
        rear=p;
    }
}

//定位第k个结点
Node* Linklist::Locate(int k)
{
    Node * p=head;
    if(k<0) return NULL;//k=0,则表示定位哨兵头节点
    while(p!=NULL&&k>0)
    {
        p=p->next;
        k--;
    }
    return p;
}

//搜索字段值为item的节点
Node* Linklist::Search(int item)
{
    Node * p=head->next;
    while(p!=NULL&&p->data!=item) p=p->next;
    return p;
}

//链表第k个结点后插入一个数据域值为d的结点
void Linklist::InsertNode(int k,int d)
{
    Node * p=NULL;
    Node * s=new Node(d);
    if(k<0) return;
    p=Locate(k);
    if(p==NULL) return;
    s->next=p->next;
    p->next=s;
}

//删除链表第k个结点
void Linklist::DeleteNode(int k)
{
    Node * p=NULL;
    Node * q=NULL;
    if(k<1)return;
    p=Locate(k-1);
    if(p==NULL) return;
    q=p->next;
    p->next=q->next;
    delete q;
}

//反转链表（s为交汇点）
Node * Linklist::Reverse(Node * s)
{
    Node *p1=s,*p2=s->next;
    Node *temp=NULL;
    while(p2!=NULL)
    {
        temp=p2;
        p2=p2->next;
        temp->next=p1;
        p1=temp;
    }
    return p1;//返回反转后反转部分的链表头
}

//打印链表
void Linklist::PrintLink()
{
    Node * p=head->next;
    while(p!=NULL)
    {
        printf("%d ",p->data);
        p=p->next;
    }
}

int main(void)
{
    int temp,opcount;
    int a,a1,a2;
    if(scanf("%d",&temp)){};
    Linklist list(temp);
    list.CreateLink();
    if(scanf("%d",&opcount)){};
    while(opcount-->0)
    {
        if(scanf("%d",&a)){};
        if(a==0)
        {
            if(scanf("%d%d",&a1,&a2)){};
            list.InsertNode(a1,a2);
        }else{
            if(scanf("%d",&a1)){};
            list.DeleteNode(a1);
        }
    }
    list.PrintLink();
    return 0;
}
```

####单链表应用:一元多项式！

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211020224020560.png" alt="image-20211020224020560" style="zoom:50%;" />

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211020224111664.png" alt="image-20211020224111664" style="zoom:50%;" />

> 多项式加法

```c++
class Node
{
public:
    Node():coef(0),exp(0),next(NULL){};
    Node(int c,int e):coef(c),exp(d),,next(NULL){};//可以简化申请新节点空间
    int coef;
    int exp;
    Node * next;
};
```



## 循环链表

![image-20211019150558856](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019150558856.png)

####判断空表

```c++
head->next==head;
```

####判断表尾

```c++
p->next==head;
```

#### ex：双向循环链表: 约瑟夫

> 编号为1…N的N个小朋友玩游戏，他们按编号顺时针围成一圈，从第一个人开始按**逆时针**次序报数，报到第M个人出列；然后再从下个人开始按**顺时针**次序报数，报到第K个人出列；再从下一个人开始按逆时针次序报数，报到第M个人出列；再从下个人开始按顺时针次序报数，报到第K个人出列……以此类推不断循环，直至最后一人出列。请编写程序按顺序输出出列人的编号。
>
> 输入格式:
>
> 输入为3个正整数，分别表示N、M、K，均不超过1000。
>
> 输出格式:
>
> 输出为一行整数，为出列人的编号。每个整数后一个空格。

```c++
//用双向循环链表模拟
///注意：这里的双向循环链表无哨兵位，因为无后续操作不需要head，tail的记录
#include <iostream>
using namespace std;

class DLNode
{
public:
    DLNode():data(0),right(NULL),left(NULL){};
    DLNode(int d):data(d),right(NULL),left(NULL){};//可以简化申请新节点空间
    int data;
    DLNode * right;
    DLNode * left;
};


int main (void)
{
   int n,m,k,count;
   scanf("%d%d%d",&n,&m,&k);
   count=n;

   DLNode * head=new DLNode(1);//建表头
   DLNode * rear=head;//建表尾
    
   //创建无哨兵位双向循环链表
   DLNode * p=head;//创建遍历指针
   for(int i=1;i<n;i++)
   {
           p=new DLNode(i+1);
           rear->right=p;//
           p->left=rear;//注意建立双向关系
           rear=p;
   }
   //循环链表（表头，表尾）需要建立循环关系
   rear->right=head;//
   head->left=rear;//注意由于是双向循环链表需建立双向循环关系
    
   int j=0;
   p=head;
   while(count!=0)
   {
       if((n-count)%2==0) //逆时针报数
       {
           j++;
           if(j==(m-1)%n)//报到第m的前一个
           {
               printf("%d ",p->left->data);
               DLNode * q=p->left;
               q->left->right=q->right;
               q->right->left=q->left;
               delete q;///双向链表的删除
               count--;
               j=0;
           }
           p=p->left;
       }
       else //顺时针
       {
           j++;
           if(j==(k-1)%n)//报到第n的前一个
           {
               printf("%d ",p->right->data);
               DLNode * q=p->right;
               q->left->right=q->right;
               q->right->left=q->left;///双向链表的删除
               delete q;
               count--;
               j=0;
           }
           p=p->right;
       }
   }

   return 0;
}
```

## 双向链表

![image-20211019151734554](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019151734554.png)

> 对于双向循环链表，仅加入哨位结点头即可

#### 双向链表结点

```c++
class DLNode
{
public:
    Node():data(0),left(NULL),right(NULL){};
    Node(int d):data(d),left(NULL),right(NULL){};//可以简化申请新节点空间
    int data;
    DLNode *left,*right;
};


```

#### 创建(双向)循环链表

```c++
//创建循环链表
void CreateDL(DLNode *s)
{
    DLNode * head=new DLNode(-1);//建哨兵表头
    DLNode * rear=new DLNode(-1);//建哨兵表尾
	head->right=rear;
    rear->left=head;
    
    DLNode * prerear=head;//创建遍历指针=>指向表尾前一个
    for(int i=0;i<n;i++)
    {
        InsertNode(prerear,data[i]);
        prerear=prerear->right;
    }
    
}

//创建含哨兵头双向循环链表
///遍历时需考虑是否为链表头
void CreateCDL(DLNode *s)
{
    DLNode * head=new DLNode(-1);//建哨兵位表头
    DLNode * rear=head;//建表尾
    
    for(int i=0;i<n;i++)
    {
        DLNode * p=new DLNode(data[i]);
        rear->right=p;//
        p->left=rear;//注意建立双向关系
        rear=p;
    }
    //循环链表（表头，表尾）需要建立循环关系
    rear->right=head;//
    head->left=rear;//注意由于是双向循环链表需建立双向循环关系
}
```



#### 删除结点（双向循环链表相同操作）

```c++
//删除链表非哨位结点s
void DeleteNode(DLNode *s)
{
    if(s==NULL) return;
    s->left->right=s->right;
    s->right->left=s->left;
    delete s;
}
```

#### 插入

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019172128343.png" alt="image-20211019172128343" style="zoom:50%;" />

```c++
void Linklist::InsertNode(DLNode *s,int item)
{
    DLNode * p=new Node(item);
    if(p==NULL) return;
    p->right=s->right;//1)
    p->left=s;//1)连接p与链表
    s->right->left=p;//2)
    s->right=p;//2)连接链表与p
}
```

## 静态链表

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019173227397.png" alt="image-20211019173227397" style="zoom:50%;" />

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019173104482.png" alt="image-20211019173104482" style="zoom: 50%;" />

####ex: 移动盒子

> NOJ 1099
>
> 有若干个盒子，从左至右依次编号为1,2,3,...,n。可执行以下指令（保证X不等于Y）：
> L X Y表示把盒子X移动到盒子Y左边（如果X已在Y左边，则忽略该指令）。
> R X Y表示把盒子X移动到盒子Y右边（如果X已在Y右边，则忽略该指令）。
> 例如n=6时,初始：1 2 3 4 5 6
> 执行指令L 1 4：   2 3 1 4 5 6
> 执行指令R 3 5：   2 1 4 5 3 6

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019174408791.png" alt="image-20211019174408791" style="zoom:50%;" />

```c++
//删除盒子<=>删除双向链表结点
right[left[x]]=right[x];
left[right[x]]=left[x];

//R X Y<=>Insert x afer y
right[x]=right[y];//1)
left[x]=y;//1)连接x与链表
left[right[y]]=x;//2)
right(y)=x;//2)连接y链表与x

//L X Y<=>Insert x before y
left[x]=left[y];//1)
right[x]=y;//1)连接x与链表
right[left[y]]=x;//2)
left(y)=x;//2)连接y链表与x
```

**与普通双向链表一致，只是将->改成[]**

## ex:双指针：链表倒数第k个结点

> 已知一个带有表头结点的单链表，假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data值，并返回1；否则，只返回0

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019193009761.png" alt="image-20211019193009761" style="zoom: 50%;" />

```c++
//双指针
int LocateBackwards(Node * head,int k)
{
    if(k<1) return 0;
    Node *p=head;
    Node *q=head;
    for(int i=0;p!=NULL&&i<k;i++) p=p->next;//注意这里要加p!=NULL(k>length的情况)
    if(p==NULL) return 0;
    while(p!=NULL)//p最后在尾结点指向的NULL
    {
        p=p->next;
        q=q->next;
    }
    //q即为链表倒数第k个结点指针
    cout<<q->data<<endl;
    return 1;
}
```

## ex:双指针：链表相交点

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019220804250.png" alt="image-20211019220804250" style="zoom:50%;" />

```c++
Node* Cross(Node *head1,Node *head2)
{
    if(head1==NULL||head2==NULL) return NULL;
    if(head1==head2) return head1;//特殊情况
    
    //先计算两链表长度，并找到尾结点
    Node *p1=head1,*p2=head2;
    int L1=0,L2=0;
    while(p1!=NULL) {L1++;p1=p1->next;}
    while(p2!=NULL) {L2++;p2=p2->next;}
    
    //若尾结点不相等则不相交
    if(p1!=p2) return NULL;
    
    //若尾结点相等则一定有相交情况
    if(L1>=L2){p1=head1;p2=head2;}
    else {p1=head2;p2=head1;}
    for(int i=0;i<abs(L1-L2);i++) p1=p1->next;
    while(p1!=p2) 
    {
        p1=p1->next;
        p2=p2->next;
    }
    return p1;
}
```

## ex:快慢指针：链表中间结点

* **fast指针**每次移动2步，**slow指针**每次移动1步 

> 找单链表中间位置的结点，要求只遍历 一次链表

```c++
Node* LocateMiddle(Node * head)
{
    Node *fast=head;
    Node *slow=head;
    
    while(fast !=NULL&&fast->next!=NULL)//由于fast一次走两步，故还要判断fast->next!=NULL！！！
    {
        fast=fast->next->next;
        slow=slow->next;
    }
    
    //fast==NULL:链表长度为偶数
    //fast!=NULL:链表长度为奇数
    return slow;
}
```

## ex:快慢指针：单链表判环

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019222328155.png" alt="image-20211019222328155" style="zoom:50%;" />

* 如果含有环，fast和slow必然会在某个时刻相 遇(fast==slow)，好比在环形跑道上赛跑时运动员的套圈。
* 如果遍历过程中，最终fast达到NULL，则说明无环。
* 如果有环，则fast和slow的相遇点（fast==slow所 对应的结点）x必然在环中。
* 保持fast不动，slow继续前进直至再次与fast相遇，slow移动的步数即环长度。

```c++
Node* HasRing(Node *head)
{
    int length=1;
    Node *fast=head;
    Node *slow=head;
    while(fast!=NULL&&fast->next!=NULL&&fast!=slow)
    {
        fast=fast->next->next;
        slow=slow->next;
    }
    if(fast!=NULL||fast->next!=NULL) return 0;
   	slow=slow->next;
    while(fast!=slow) length++;
    return length;
}
```

## ex:快慢指针：回文链表

> 判断一个单链表是否是回文
>
> 要求时间复杂度O(n)，空间复杂度O(1)

1. 先通过「双指针技巧」中的**快慢指针**来找到链表的中点
2. 从`slow`开始**反转链表**，开始比较回文串

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211019224358408.png" alt="image-20211019224358408" style="zoom: 50%;" />

奇:<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211020223347163.png" alt="image-20211020223347163" style="zoom:50%;" />       偶:<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211020223402700.png" alt="image-20211020223402700" style="zoom:50%;" />

```c++
bool Tenet(Node * head)
{
    Node *left=head->next,*right=NULL;
    right=Reverse(LocateMiddle(head));
    while(left!=right||right->next!=left)//链表长度为奇||偶(或left->next!=right)
    {
        if(left->data!=right->data) return false;
        left=left->next;
        right=right->next;
    }
    return true;
}
```

## ex:快慢指针：重排链表

> 设线性表L=(a1,  a2,  a3,  …,  an-2,  an-1,  an)采用带哨 位结点的单链表保存，请设计一个空间复杂度 为O(1)且时间上尽可能高效的算法，重新排列L 中的各结点，得到线性表L’=  (a1,  an,  a2,  an-1,  a3, an-2…)。

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211020223329270.png" alt="image-20211020223329270" style="zoom:50%;" />

```c++
void Rearrange(Node * head)
{
    Node *left=head->next,*right=NULL;
    right=Reverse(LocateMiddle(head));
    while(left!=right||left->next!=right)//链表长度为奇||偶
    {
        Node * temp=right->next;
        InsertNode(left,right->data);
        DeleteNode(right);
        left=left->next;
        right=temp;
    }
}
```

# 栈和队列

## 栈类

```c++
#include <iostream>
#include <string.h>
using namespace std;

class Node
{
public:
    Node():data(-1),next(NULL){};///data类型
    Node(int d):data(d),next(NULL){};///data类型
    int data;///data类型
    Node * next;
};

class LinkStack
{
public:
    LinkStack():top(NULL){};
    ~LinkStack();
    void push(int d);///data类型
    int pop();///data类型
    int topdata();///data类型
    bool IsEmpty();
private:
    Node * top;
};


//销毁链式栈
LinkStack::~LinkStack()
{
    Node * p;
    while(top!=NULL)
    {
        p=top;
        top=top->next;
        delete p;
    }
}

//入栈
void LinkStack::push(int d)///data类型
{
    Node * s=new Node(d);
    s->next=top;
    top=s;
}

//出栈
int LinkStack::pop()///data类型
{
    int x;
    if(IsEmpty())
    {
        return -1;
    }
    else
    {
        Node * temp=top;
        x=top->data;
        top=top->next;//也可改为返回T
        delete temp;
        return x;
    }
}

int LinkStack::topdata()///data类型
{
    if(IsEmpty())
    {
        return -1;
    }
    return top->data;
}

//判断是否为空栈
bool LinkStack::IsEmpty()///data类型
{
    if(top==NULL) return true;
    else return false;
}

```

## 队列类

```c++
#include <iostream>
using namespace std;


class Node
{
public:
    Node():data(0),next(NULL){};
    Node(int d):data(d),next(NULL){};
    int data;///data类型
    Node * next;
};

//带有“哨兵”结点的队列
class LinkQueue
{
public:
    LinkQueue():front(new Node()),rear(front){};//初始化空的带有“哨兵”结点的队列
    ~LinkQueue();
    void Enqueue(int d);///data类型
    int Dequeue();///data类型
    bool IsEmpty();
    void Print();
    int MemberNum();
private:
    Node * front;
    Node * rear;
};


//销毁链式栈
LinkQueue::~LinkQueue()
{
    while(front!=NULL)
    {
        rear=front;
        front=front->next;
        delete rear;
    }
}

//从队尾入队
void LinkQueue::Enqueue(int d)///data类型
{
    Node * s=new Node(d);
    rear->next=s;
    rear=s;
}

//从队首出队
int LinkQueue::Dequeue()///data类型
{
    if(IsEmpty())
    {
        return -1;
    }
    else
    {
        Node * temp=front->next;//注意这里front一直为哨兵节点，故front->next才是第一个队员
        int tmp=temp->data;///data类型
        front->next=temp->next;
        delete temp;
        if(front->next==NULL) rear=front;//及判断删除的节点是否为rear，令rear=front则可满足队空条件
        return tmp;
    }
}

//判断是否为空栈
bool LinkQueue::IsEmpty()
{
    if(front==rear) return true;
    else return false;
}

//队列成员数
int LinkQueue::MemberNum()
{
    int num=0;
    Node * s=front;
    Node * e=rear;
    while(s!=e)
    {
        num++;
        s=s->next;
    }
    return num;
}
void LinkQueue::Print()
{
    Node * temp=front->next;
    while(temp!=NULL)
    {
        printf("%d ",temp->data);
        temp=temp->next;
    }
    printf("\n");
}

```

## 双端队列类(单调队列)

#### ex:队列最大值(单调队列)

* 双端队列作辅助队列

<img src="https://pic.leetcode-cn.com/9d038fc9bca6db656f81853d49caccae358a5630589df304fc24d8999777df98-fig3.gif" alt="fig3.gif" style="zoom:50%;" />

```c++
#include <iostream>
#include<string.h>
using namespace std;

class Node
{
public:
    Node():data(0),next(NULL){};
    Node(int d):data(d),next(NULL){};
    int data;
    Node * next;
};


//带有“哨兵”结点的双端队列
class Deque
{
public:
    Deque():head(new Node()),rear(head){};//初始化空的带有“哨兵”结点的队列
    ~Deque();
    void push(int d);//前端入队
    void pop();//前端出队
    void inject(int d);//后端入队
    void eject();//后端出队
    bool IsEmpty();
    int RearNode();
    int HeadNode();
private:
    Node * head;
    Node * rear;
};


//销毁链式栈
Deque::~Deque()
{
    while(head!=NULL)
    {
        rear=head;
        head=head->next;
        delete rear;
    }
}

int Deque::RearNode()
{
    return rear->data;
}

int Deque::HeadNode()
{
    if(IsEmpty()) return 0;//保证主程序中不会为空
    return head->next->data;
}

void Deque::push(int d)//前端入队
{
    Node * s=new Node(d);
    Node * temp=head->next;
    head->next=s;
    if(IsEmpty()) rear=s;
    else s->next=temp;
}

void Deque::pop()//前端出队
{
    Node * temp=head->next;
    if(IsEmpty()) return;
    head->next=temp->next;
    delete temp;
    if(head->next==NULL) rear=head;
}


void Deque::inject(int d)//后端入队
{
    Node * s=new Node(d);
    rear->next=s;
    rear=s;
}
void Deque::eject()//后端出队
{
    Node * p=head;
    if(IsEmpty()) return;
    while(p->next!=rear) {p=p->next;}
    delete rear;
    rear=p;
}


//判断是否为空栈
bool Deque::IsEmpty()
{
    if(head==rear) return true;
    else return false;
}

int main(void)
{
    int temp=0;
    char str[7];
    int t=0;
    Deque q1,q2;//q1：普通队列；q2：辅助max队列；
    scanf("%d",&t);
    while(t-->0)
    {
        scanf("%s",str);
        //入队
        if(strcmp(str, "ENQUEUE")==0)
        {
            scanf("%d",&temp);
            //普通队列直接入队
            q1.inject(temp);
            //辅助max（双端）队列维护单调队列=>队尾出队至队内前一个元素大于将要入队的元素
            while(!q2.IsEmpty()&&q2.RearNode()<temp) q2.eject();
            //再入队
            q2.inject(temp);
            continue;
        }
        //出队
        if(strcmp(str, "DEQUEUE")==0)
        {
            int r=0;
            //普通队列若队列不为空则直接出队
            if(q1.IsEmpty()) continue;
            r=q1.HeadNode();
            q1.pop();
            //辅助max（双端）队列维护单调队列=>若队列不为空且出队元素与队首相等则出队
            if(q2.IsEmpty()==0&&r==q2.HeadNode()) q2.pop();
        }
        //最大元素=>辅助max（双端）队列维护单调队列,若队不为空，则取队首元素
        if(strcmp(str, "MAXIMUM")==0)
        {
            if(q2.IsEmpty()==0) printf("%d",q2.HeadNode());
            continue;
        }
    }
    return 0;
}

```

## 栈：扩容

> push时栈满了需要扩容

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211026152031305.png" alt="image-20211026152031305" style="zoom: 50%;" />

#### 容量加倍策略

> 每次Push操作均摊时间复杂度O(1)



```c++
void stack::Push(int item)
{
    if(IsFull())
    {
        int *B=new int[size*2];
        for(int i=0;i<size;i++) B[i]=A[i];//A：原栈指针
        delete A;
        A=B;
        size*=2;
    }
    A[++top]=item;
}
```

#### 容量递增策略

> 每次Push操作均摊时间复杂度O(n)

``int *B=new int[size+d]``

## 栈：进制转换

* 进制转换结果为余数的**逆序**=>栈后进先出

> 十进制转换八进制

```c++
int n;
LinkStack s;
scanf("%d",&n);
while(n>0)
{
    s.Push(n%8);
    n/=8;
}
while(s.IsEmpty()==0) printf("%d",s.pop());
```

> 十进制转base(16)进制

```c++
int n;
LinkStack s;
char digit[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}//>10进制：定义字符数组
scanf("%d",&n);
while(n>0)
{
    s.Push(n%base);
    n/=base;
}
while(s.IsEmpty()==0) printf("%d",s.pop());
```

## 栈：括号匹配

>* 高级语言程序设计中的各种括号应该匹配，例 如：“(”  与 “)”匹配、“[”与 “]”  匹配、“{” 与 “}” 匹配等。
>*   输入一字符串，判断括号是否匹配；匹配输出
>  “yes”，否则输出“no”.

* 用栈存放左括号，匹配则弹出，不匹配则no，直至栈空yes

```c++
bool MatchBracket(char * str)
{
    LinkStack s;
    int i=0;
    while(*(str+i)!='\0')
    {
        if(str[i]=='{'||str[i]=='['||str[i]=='(') s.push(str[i]);
        if(str[i]=='}'||str[i]==']'||str[i]==')') 
        {
            if(s.IsEmpty()) return false;//!!空栈单独判断
            int temp=s.pop();
            if(!(temp=='{'&&str[i]=='}'||temp=='['&&str[i]==']'||temp=='('&&str[i]==')')) return false;
        }
        i++;
    }
    if(s.IsEmpty()) return true;
    else return false;
}
```

#### 补齐匹配

###### 多组字符串输入

>请编写程序判断一个包含“（”和“）”的括号序列是否匹配。如匹配则输出Match；如不匹配，计算出使该序列变为匹配序列所需添加的最少括号数目（只允许在该序列开始和结尾处添加括号），并输出经添加最少括号后得到的合法匹配序列
>
>输入格式:
>
>输入为若干行，每行一个字符串，包含不超过105个括号。输入行数不超过10行。
>
>输出格式:
>
>对于输入的每个括号序列输出1行或2行信息。若输入的括号序列匹配，则输出Match。若不匹配，则输出分为2行，第1行为一个整数，表示将该序列变为匹配序列所需添加的最少括号数目，第2行为一个字符串，表示经添加最少括号后得到的合法匹配序列。

* 主要思想：

* 引入left和right作为记录当前观察到的括号的左边的左括号补齐和右边的右括号补齐

* step:若为`(`:右边的右括号补齐+1

​		若为`)`:right=0(无可替代的右括号补齐/前无孤独的左括号)=>左边的左括号补齐+1

​					right!=0(现在这个右括号可替代的右括号补齐/可匹配前孤独的左括号)=>右边的右括号补齐-1

* 1. left=0&&right=0，无需补齐=>match
  2. 否则，unmatch=>添加最少括号后得到的合法匹配序列:left * `(` *+* 原括号序列 *+* right * `)`

```c++
#include <iostream>
#include <string.h>
using namespace std;


int main (void)
{

    string temp;
    //多组字符串输入
    while(cin>>temp)
    {
        int left=0,right=0;//left:左括号补偿，right:右括号补偿
        for(int i=0;temp[i]=='('||temp[i]==')';i++)
        {
            if(temp[i]=='(') right++;//补偿右括号
            else
                if(right==0) left++;//前无左括号，只能补偿
                else right--;//后字符串替代补偿
        }
        //left=0&&right=0，无需补齐=>match
        if(left==0&&right==0)
        {
            printf("Match");
        }
        else//否则，unmatch=>添加最少括号后得到的合法匹配序列:left * `(` + 原括号序列 + right * `)`
        {
            printf("%d\n",left+right);
            while(left--!=0) printf("(");
            cout<<temp;
            while(right--!=0) printf(")");
        }
        printf("\n");
    }

    return 0;
}
```

## 栈：表达式求值

###### 字符串结束符：str[i]!=’\0‘

#### 后缀表达式求值

设置一个栈，存放操作数 从左到右依次读入后缀表达式的每一个操作数/运算符/结束符：

1. 若读到的是操作数，将它压入堆栈。
2. 若读到的是运算符，就从堆栈中连续弹出 两个元素（操作数），进行相应的运算， 并将结果压入栈中。
3. 读入结束符时，栈顶元素就是计算结果。

```c++
void CalculatePost(LinkQueue &q)
{
    LinkStack s;
    int temp;
    //保存后缀表达式的q不为空时
    while(!q.IsEmpty())
    {
        //observe第一个数
        temp=q.Dequeue();

        //若为运算符，
        if(IsOperators(temp))
        {
            //就从堆栈（不是队列!!）中连续弹出 两个元素（操作数）
            int x=s.pop();
            int y=s.pop();

            //进行相应的运算 并将结果压入栈中
            if(temp=='+') s.push(x+y);
            else if(temp=='-') s.push(y-x);
            else if(temp=='*') s.push(x*y);
            else if(temp=='/')
                {
                if(x==0) {printf("ILLEGAL");exit(0);}//注意除法一定要注意除数是否为0
                else s.push(y/x);
                }
        }else s.push(temp);
    }
    //q为空时，栈顶元素就是计算结果
    printf("%d",s.topdata());
}
```

#### 中缀->后缀

##### 手算

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211026215628107.png" alt="image-20211026215628107" style="zoom: 67%;" />

##### 程序

> 算法T(transformation之缩写)将中缀表达式转换成后缀表 达式，堆栈 S  保存扫描中缀表达式得到的暂不能加入后缀 表达式的运算符，队列 Q 保存结果后缀表达式 

* 操作数规则：直接放入后缀表达式
* 运算符规则：

  1. 栈空或栈顶是左括号：运算符压栈
  2. 当前运算符优先级> 栈顶运算符：压栈
  3. 当前运算符优先级≤栈顶运算符：弹栈直至当前运算符优先级大于栈顶或栈空或栈顶为左括号， 再压栈

  =>这三步合在一起就是第三步:弹栈直至当前运算符优先级大于栈顶或栈空或栈顶为左括号， 压栈
* 括号规则：**[也算运算符]**

  1. 遇到左括号：压栈
  2. 遇到右括号：弹栈至左括号
* 结束符规则：弹栈至栈空

```c++
#include <iostream>
#include <string.h>
using namespace std;

const int MAX=50010;

class Node
{
public:
    Node():data(-1),next(NULL){};
    Node(int d):data(d),next(NULL){};
    int data;
    Node * next;
};


//栈类：用来中缀转后缀&计算后缀表达式
class LinkStack
{
public:
    LinkStack():top(NULL){};
    ~LinkStack();
    void push(int d);
    int pop();
    int topdata();
    bool IsEmpty();
private:
    Node * top;
};


//销毁链式栈
LinkStack::~LinkStack()
{
    Node * p;
    while(top!=NULL)
    {
        p=top;
        top=top->next;
        delete p;
    }
}

//入栈
void LinkStack::push(int d)
{
    Node * s=new Node(d);
    s->next=top;
    top=s;
}

//出栈
int LinkStack::pop()
{
    int x;
    if(IsEmpty())
    {
        return -1;
    }
    else
    {
        Node * temp=top;
        x=top->data;
        top=top->next;//也可改为返回T
        delete temp;
        return x;
    }
}

int LinkStack::topdata()
{
    if(IsEmpty())
    {
        return -1;
    }
    return top->data;
}

//判断是否为空栈
bool LinkStack::IsEmpty()
{
    if(top==NULL) return true;
    else return false;
}



//队列类：用来保存后缀表达式
class LinkQueue
{
public:
    LinkQueue():front(new Node()),rear(front){};//初始化空的带有“哨兵”结点的队列
    ~LinkQueue();
    void Enqueue(int d);
    int Dequeue();
    bool IsEmpty();
    void Print();
private:
    Node * front;
    Node * rear;
};


//销毁链式栈
LinkQueue::~LinkQueue()
{
    while(front!=NULL)
    {
        rear=front;
        front=front->next;
        delete rear;
    }
}

//从队尾入队
void LinkQueue::Enqueue(int d)
{
    Node * s=new Node(d);
    rear->next=s;
    rear=s;
}

//从队首出队
int LinkQueue::Dequeue()
{
    int x;
    if(IsEmpty())
    {
        return -1;
    }
    else
    {
        Node * temp=front->next;//注意这里front一直为哨兵节点，故front->next才是第一个队员
        x=temp->data;
        front->next=temp->next;
        delete temp;
        if(front->next==NULL) rear=front;//及判断删除的节点是否为rear，令rear=front则可满足队空条件
        return x;
    }
}

//判断是否为空栈
bool LinkQueue::IsEmpty()
{
    if(front==rear) return true;
    else return false;
}


void LinkQueue::Print()
{
    Node * temp=front->next;
    while(temp!=NULL)
    {
        printf("%d ",temp->data);
        temp=temp->next;
    }
    printf("\n");
}

//判断是否为运算符
bool IsOperators(char x)
{
    if(x=='+'||x=='-'||x=='*'||x=='/')
        return true;
    return false;
}

//设置运算符优先级
/*
定义运算符优先级：
【高级】(    :2 
【中级】* / /:1
【低级】+ / -:0
*/
int Prior(char x)
{
    if(!IsOperators(x)) return -1;

    if(x=='(') return 2;
    else if (x=='*'||x=='/') return 1;
    else if(x=='+'||x=='-') return 0;

}

void Transform(char * str,LinkQueue &q)//str:中缀表达式 q:保存后缀结果
{
    int sum=0;
    int i=0;
    LinkStack s;
    //将弹栈的元素 保存后缀表达式的队列中
    while(str[i]!='\0')
    {
        
        if(str[i]=='(')  s.push(str[i]);//遇到左括号：压栈
        else if(str[i]==')')//遇到右括号：弹栈至左括号
        {
            int temp=s.pop();
            while(temp!='(')
            {
                q.Enqueue(temp);
                temp=s.pop();
            }
        }
        else if(IsOperators(str[i]))//运算符
        {
            //弹栈直至当前运算符优先级大于栈顶或栈空或栈顶为左括号， 压栈
            while(!(s.IsEmpty()||s.topdata()=='('||Prior(str[i])>Prior(s.topdata())))//注意三个条件：当前运算符优先级大于栈顶||栈空||栈顶为左括号 的逆
            {
                q.Enqueue(s.pop());
            }
            s.push(str[i]);
        }
        else //操作数：直接放入后缀表达式
        {
            ///注意：由于读入是字符=>一定要转换为数：如'1''2'=>'12' 
            sum=0;
            while(str[i]!='\0'&&str[i]>='0'&&str[i]<='9')
            {
                sum=sum*10+(str[i]-'0');
                i++;

            }
            i--;//最后判断时多加了一个i，要减去
            q.Enqueue(sum);
        }
    	i++;
    }
    //弹栈至栈空：别忘记
    while(!s.IsEmpty()) q.Enqueue(s.pop());

}

//计算后缀表达式
void CalculatePost(LinkQueue &q)
{
    LinkStack s;
    int temp;
    //保存后缀表达式的q不为空时
    while(!q.IsEmpty())
    {
        //observe第一个数
        temp=q.Dequeue();

        //若为运算符，
        if(IsOperators(temp))
        {
            //就从堆栈（不是队列!!）中连续弹出 两个元素（操作数）
            int x=s.pop();
            int y=s.pop();

            //进行相应的运算 并将结果压入栈中
            if(temp=='+') s.push(x+y);
            else if(temp=='-') s.push(y-x);
            else if(temp=='*') s.push(x*y);
            else if(temp=='/')
                {
                if(x==0) {printf("ILLEGAL");exit(0);}//注意除法一定要注意除数是否为0
                else s.push(y/x);
                }
        }else s.push(temp);
    }
    //q为空时，栈顶元素就是计算结果
    printf("%d",s.topdata());
}

int main (void)
{
    //q：保存后缀表达式
    LinkQueue q;
    //temp：保存中缀表达式字符串
    char temp[MAX];
    scanf("%s", temp);
    //中缀表达式转后缀表达时
    Transform(temp,q);
    //计算后缀表达式
    CalculatePost(q);
    
    return 0;
}

```

#### 直接计算中值表达式

(其实相当于把两步合并)

* 改中缀转后缀

  * 去掉后缀表达式队列，引入操作数栈（即计算后缀的表达式的栈）

  * 每次需要弹栈到队列时:将入队=>改为运算操作：出队两数字后运算将结果压入操作数栈Q
  * 而对操作数直接压栈不改变



<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204153731307.png" alt="image-20211204153731307" style="zoom:67%;" /><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204153737873.png" alt="image-20211204153737873" style="zoom:67%;" />

## 栈：递归/回溯与栈消除递归

> - 递归是一种算法结构，回溯是一种算法思想。
> - 一个递归就是在函数中调用函数本身来解决问题。
> - 回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”。
> - 回溯搜索是深度优先搜索（DFS）的一种

#### ==回溯算法的基本框架==

##### 求所有解

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204160024451.png" alt="image-20211204160024451" style="zoom: 50%;" />

##### 求一个解

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204160224078.png" alt="image-20211204160224078" style="zoom:50%;" />

```c++
//回溯一般结构
void DFS(int 当前状态)  
{  
      if(当前状态为边界状态)  
      {  
        记录或输出  
        return;  
      }  
      for(i=0;i<n;i++)       //【横向遍历】解答树所有子节点  
      {  
           //扩展出一个子状态。  
           修改了全局变量  
           if(子状态满足约束条件)  
            {  
              dfs(子状态)  
           }  
            恢复全局变量//回溯部分  
      }  
}  

//递归一般结构
void f()  
{  
     if(符合边界条件)  
     {  
        ///////  
        return;  
     }  

     //某种形式的调用  
     f();  
}  
```

#### ex:DFS走迷宫

>* n × n的迷宫
>* 机器人起始位置(sx,sy)；
>* 每步走一格，上、 下、左、右任意一个相邻的合法格子
>* 出口位置(tx, ty)
>* 解：动作序列:

```c++
int dx[]={0,0,1,1};
int dy[]={1,-1,0,0};

char maze[Nmax][Nmax];
//init:F(0,0,tx,ty,0,action)
//(x,y)是现在位置，(tx,ty)是出口，k是解数组的index，action是解数组
void F(int x,int y,int tx,int ty,int k,int action[])
{
    if(x==tx&&y==ty)
    {
        for(int i=0;i<k;i++) printf("%d",action[k]);
        return;
    }
    for(int i=1;i<=n;i++)//每一步有四个方向【横向遍历所有子结点】
    {
        //若走第i个方向，则下个位置
        int nx=x+dx[i];
        int ny=y+dy[i];
        if(map[nx][ny]==0)//可走
        {
            Action[k]=i;
            map[nx][ny]=1;//修改map状：走过就不能再走
            F(nx,ny,tx,ty,k+1,action);
            map[nx][ny]=0;//恢复map状态，观察下一个横向解（方向）=>回溯
        }
    }
}

//回溯一般结构
void DFS(int 当前状态)  
{  
      if(当前状态为边界状态)  
      {  
        记录或输出  
        return;  
      }  
      for(i=0;i<n;i++)       //【横向遍历】解答树所有子节点  
      {  
           //扩展出一个子状态。  
           修改了全局变量  
           if(子状态满足约束条件)  
            {  
              dfs(子状态)  
           }  
            恢复全局变量//回溯部分  
      }  
}
```

#### ex:DFS八皇后

> 8 × 8棋盘，如何放置8个皇后，使得任意两 个皇后都不在同一行同一列，同一斜线
>
> 解：A[k]表示第k列的皇后放到第几行

```c++
//根据前A[k-1]，能放在第k列第i行嘛
bool CanPut(int A[],int k,int i)
{
    for(int j=1;i<k;i++)
    {
        if(A[j]==i||abs(A[j]-i)==abs(j-k)) return false;
    }
    return true;
}

//init:Nqueens(A,n,1)
void Nqueens(int A[],int n,int k)
{
    if(k>n)
    {
        for(int i=1;i<k;i++) printf("%d",A[k]);
        return;
    }
    for(int i=1;i<=n;i++)//每列有n个位置【横向遍历所有子结点】
    {
        if(CanPut(A,k,i))
        {
            A[k]=i;
            Nqueens(A,n,k+1);
        }
    }
}
```

#### ex:汉诺塔

##### 递归

=>递推关系： 把x 针上的n片金片,移动到y 针上, 移动过程中可以利用z 针。

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201223130420385.png" alt="image-20201223130420385" style="zoom:80%;" />

```c++
void MOVE(char x,char y)
{
    printf("%c->%c\n",x,y);
}

//HR将原柱 A 上的 n个圆盘移到目标柱 C 上，圆柱 B 是中间柱 
void HR(int n,int A,int B,int C)
{
    if(n==1)
    {
        MOVE(A,C);
        return;
    }
    HR(n-1,A,C,B);
    MOVE(A,C);
    HR(n-1,B,A,C);
}

```

##### 栈消除递归??

```c++
//HI将原柱A上的n个圆盘移到目标柱 C 上，圆柱 B 是中间柱 
void HR(int n)
{
    LinkStack s;
    s.push(Ftuple(n,A,B,C))
    while(!s.IsEmpty())
    {
        Ftuple temp=s.pop();
        if(n==1) MOVE(A,C);
        else
        {
            s.push(Ftuple(n-1,B,A,C));//HR(n-1,B,A,C);
            s.push(Ftuple(1,A,B,C));//MOVE(A,C);
            s.push(Ftuple(n-1,A,C,B));//HR(n-1,A,C,B);
        }
    }
}
```

## 栈混洗

> 入栈序列：1，2，...，n

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204184850292.png" alt="image-20211204184850292" style="zoom:50%;" />

#### 栈混洗甄别

> 对于出栈序列中1≤i < j < k≤ n 位置的3个元素
> 	 …, ai , … aj , … , ak  , …

法一：利用充要条件O(n^3^)

> 非栈混洗 <=>出现 3 1 2模式

```c++
bool Decision(int a[],int n)
{
	for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            for(int k=j+1;k<=n;k++)
                if(a[i]>a[k]&&a[k]>a[j]) return false;
	return true;    
}
```

法二：模拟栈混洗过程O(n)

```c++
n个元素的栈混洗，等价于n对括号的匹配bool Decision(LinkStack &s,int a[],int n)
{
    int k=1;//k用来遍历出栈序列
    int i=1;//i为入栈序列里的1~n
    while(k<=n)//a[k]是当前期望的出栈元素
    {
        if(s.IsEmpty()||s.topdata()<a[k]){s.push(i);i++;}//若栈为空或将出栈元素小于a[k]，则代表要继续入栈（别忘记更新i）
        else if(s.topdata()==a[k]){s.pop();k++;}//出栈元素等于a[k]，则出栈，别忘记更新k
        else if(s.topdata()>a[k]) return false;//出栈元素小于a[k]，根据充要条件不可能
    }
    return true;
}
```

#### 栈混洗总数

> **每一次栈混洗，都对应于栈的n次push和n次pop操作构成的一个序列**<=>**n个元素的栈混洗，等价于n对括号的匹配**
>
> 注意：不是2^n^，因为pop和push还要满足是匹配（括号的匹配）的

=>只考虑一种括号，n对括号共有多少种可能的合法匹配序列？<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204191142909.png" alt="image-20211204191142909" style="zoom:33%;" />

## 队列：循环队列

* 方案一：有count
* 方案二：无count

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204191458365.png" alt="image-20211204191458365" style="zoom: 50%;" />

## 队列：实现BFS

#### ex:BFS走迷宫最短路

> BFS求无权图SP

```c++
class Ftuple
{
public:
    Ftuple(int v1,int v2,int v3):x(v1),y(v2),step(v3),father(NULL){}
    int x;
    int y;
    int step;
    int *father;
}；

//n×m图：左上角(0,0)=>右下角(n-1,m-1)
int BFS_SP(int n)
{
    LinkQueue q;
    //初始化队列
    q.Enqueue(Trituple(0,0,1,NULL));
    while(!q.IsEmpty())
    {
        Ftuple temp=q.pop();
        //找到解:通过父结点指针恢复路径
        if(temp.x==n-1&&temp.y==m-1) 
        {
            printf("最短路径长度为：%d\n",Ftuple.step);
            printf("最短路径为：\n");
            int * f=Ftuple.father;
            while(f!=NULL)
            {
                printf("(%d,%d)",(f-&map[0][0])%m,(f-&map[0][0])/m);
                f=q.pop().father;
            }
        }
        //【横向遍历】解答树所有子节点
        for(int i=1;i<=4;i++)
        {
            int nx=temp.x+dx[i];
            int ny=temp.y+dy[i];
            if(map[nx][ny]==0)
            {
                q.Enqueue(nx,ny,step+1,&map[x][y])//指向(nx,ny)父结点的指针
                map[nx][ny]=1;
            }
        }
    }
}
```

## 单调栈

> * 优势：时间复杂度是线性的=>每个元素遍历一次
> * 基础模板：
>   1. 维持单调栈=>弹出不符合条件的栈顶元素
>   2. 放入最后解Array[]
>   3. 当前元素入栈

#### ex:下一个更大元素

> 即维护了一个单调递减栈

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204204020825.png" alt="image-20211204204020825" style="zoom: 33%;" />

```c++
const int N=100010;

//a记录原数组，right记录数组中每一个元素（且以数组元素做index=>HashSet）下一个更大元素
void NextGreater(int a[],int right[],int n)
{
    //初始化right数组
    for(int i=0;i<n;i++) right[i]=-1;
    LinkStack s;
    for(int i=0;i<n;i++)
    {
        //若当前入栈的元素a[i]>栈顶元素=>则栈顶元素的下一个更大元素即为a[i]
        //直到a[i]<=栈顶元素为止=>再入栈a[i]
        while(!s.IsEmpty()&&a[i]>s.topdata())
        {
            right[s.pop()]=a[i];
        }
        s.push(a[i]);
    }
}
```

#### ex:上一个更小元素

法一：反向扫描a[]

```c++
const int N=100010;

void NextGreater(int a[],int left[],int n)
{
    for(int i=0;i<n;i++) left[i]=-1;
    LinkStack s;
    for(int i=n-1;i>=0;i--)    //唯一变化处:逆向遍历a数组
    {
        while(!s.IsEmpty()&&a[i]>s.topdata())
        {
            left[s.pop()]=a[i];
        }
        s.push(a[i]);
    }
}
```

法二：进栈时,栈顶元素即为当前元素上一个更大元素

```c++
const int N=100010;


void NextGreater(int a[],int left[],int n)
{
    for(int i=0;i<n;i++) right[i]=-1;
    LinkStack s;
    for(int i=0;i<n;i++)
    {
        while(!s.IsEmpty()&&a[i]>=s.topdata())///>=
        {
            s.pop();
        }
        if(s.IsEmpty()) left[i]=-1;
        else left[i]=a[s.pop()];///正常入栈时（递减），栈顶元素即为当前元素上一个更大元素
        s.push(a[i]);
    }
}
```

#### ex:循环数组下一个更大元素

* 相比非循环数组：
  * 遍历数组需[0,2n-1)=>因为一圈（除自己）都在observe范围
  * 访问~~a[i]~~ = >a[i%n]

```c++
const int N=100010;

//a记录原数组，right记录数组中每一个元素（且以数组元素做index=>HashSet）下一个更大元素
void NextGreater(int a[],int right[],int n)
{
    //初始化right数组
    for(int i=0;i<n;i++) right[i]=-1;
    LinkStack s;
    for(int i=0;i<2*n-1;i++)
    {
        //若当前入栈的元素a[i]>栈顶元素=>则栈顶元素的下一个更大元素即为a[i]
        //直到a[i]<=栈顶元素为止=>再入栈a[i]
        while(!s.IsEmpty()&&a[i%n]>s.topdata())
        {
            right[s.pop()]=a[i%n];
        }
        s.push(a[i%n]);
    }
}
```

#### ex：相隔几个元素是下一个更大

```c++
const int N=100010;

//a记录原数组，right记录数组中每一个元素（且以数组元素做index=>HashSet）下一个更大元素
void NextGreater(int a[],int right[],int n)
{
    //初始化right数组
    for(int i=0;i<n;i++) right[i]=-1;
    LinkStack s;
    for(int i=0;i<n;i++)
    {
        //若当前入栈的元素a[i]>栈顶元素=>则栈顶元素的下一个更大元素即为a[i]
        //直到a[i]<=栈顶元素为止=>再入栈a[i]
        while(!s.IsEmpty()&&a[i]>s.topdata())
        {
            right[s.pop()]=i-index;///解为两index的距离
        }
        s.push(i);///保存index而不是值
    }
}
```

#### ex:移除重复元素

> 去除重复字符串，保持字典序最小
>
> * 字符串之间比较和数字比较不一样; 字符串比较是从头往后挨个字符比较,那个字符串大取决于两个字符串中第一个对应不相等的字符

关键思想：保持递增的Stack【**如果栈顶的character不是最后一次出现**&&下一个更小=>pop】

				1. 统计每个元素出现几次/最后一次出现的index=>hashmap
				1. 单增stack

```c++
const int N=100010;

//a记录原数组，right记录数组中每一个元素（且以数组元素做index=>HashSet）下一个更大元素
void RemoveDua(char a[],int n)
{
    //1.统计每个元素后一次出现的index=>hashmap
    int last[128]={0};//ASCII:小写字母a-z:97-122
    for(int i=0;i<n;i++) last[int(a[i])]=i;
    
    //2.单增stack模板
    //初始化right数组
    LinkStack s;
    for(int i=0;i<n;i++)
    {
        //若当前入栈的元素a[i]>栈顶元素&&栈顶的character不是最后一次出现=>pop
        //直到a[i]<=栈顶元素为止=>再入栈a[i]
        while(!s.IsEmpty()&&a[i]<s.topdata()&&i<last[s.topdata()])
        {
            s.pop();
        }
        s.push(a[i]);
    }
    //s中存的元素即为最终结果（栈底->栈顶）
}
```

#### ex: remove K digits

> 给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

* 维护一个递增栈：且pop次数<=k
  1. 维护一个递增栈
  2. 若还能移除（即剩余可移除位数k>0）就将前k位（栈顶）移除
  3. 去除number前的0

```c++
const int N=100010;

//a记录原数组，right记录数组中每一个元素（且以数组元素做index=>HashSet）下一个更大元素
void RemoveKdigits(char a[],char res[],int n)
{   
    //1.单增stack模板
    //初始化right数组
    for(int i=0;i<n;i++) res[i]=-1;
    LinkStack s;
    for(int i=0;i<n;i++)
    {
        //若当前入栈的元素a[i]>栈顶元素&&剩余可移除位数k>0=>pop
        //直到a[i]<=栈顶元素为止=>再入栈a[i]
        while(!s.IsEmpty()&&a[i]<s.topdata()&&k>0)
        {
            s.pop();
            k--;
        }
        s.push(a[i]);
    }
    //2.若还能移除（即剩余可移除位数k>0）就将前k位（栈顶）移除
    while(k-->0) s.pop();
    //3.去除number前的0[在栈底处]
    //用链表不好做=>因为无法标记栈底=>看以下代码=>用数组
}
```

```c++
const int N=100010;

void RemoveKdigits(char a[],char res[],int n)
{   
    //1.单增stack模板
    //初始化res数组
    for(int i=0;i<n;i++) res[i]=-1;
    int id=0;
    //stack顺序
    int stack[N];
    top=-1;
    for(int i=0;i<n;i++)
    {
        //若当前入栈的元素a[i]<栈顶元素&&剩余可移除位数k>0=>pop
        //直到a[i]<=栈顶元素为止=>再入栈a[i]
        while(top>=0&&a[i]<s.topdata()&&k>0)
        {
            top--;//s.pop();
            k--;
        }
        stack[++top]=a[i];//s.push(a[i]);
    }
    //2.若还能移除（即剩余可移除位数k>0）就将前k位（栈顶）移除
    while(k-->0) top--;
    //3.去除number前的0[在栈底处]
    bool firstzero=1;
    for(int i=0;i<top;i++)
    {
        if(stack[i]==0&&firstzero) continue;
        firstzero=false;
        res[id++]=stack[i];
    }
    res[id++]=stack[top];
    
}
```

#### ex:储水问题

> 维护一个递减栈：
>
> 只有高度**从低变高**才会**增加储水量**：即每次发生pop时，都可以计算一次储水量
>
> 左墙壁：stack[top-1]
>
> 湖底：stack[top]
>
> 右墙壁：当前元素a[i]

![image-20211205140933878](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211205140933878.png)

```c++
const int N=100010;

void TrapWater(int a[],int res,int n)
{   
    //1.单减Astack模板
    //初始化res数组
    res=0;
    //stack顺序
    int stack[N];
    top=-1;
    for(int i=0;i<n;i++)
    {
        //若当前入栈的元素a[i]>栈顶元素=>pop
        //直到a[i]<=栈顶元素为止=>再入栈a[i]
        while(top>=0&&a[i]>s.topdata())
        {
            int pre=stack[top--];//pop栈顶=>湖底
            if(top<0) break;//无左墙壁了
            int left=stack[top];//左墙壁
            int right=a[i]；
            res+=(min(left,right)-pre);
        }
        stack[++top]=a[i];//s.push(a[i]);
    }
    
}
```

#### ex:柱状图中最大矩形

> 单调递增栈

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211204210857518.png" alt="image-20211204210857518" style="zoom:33%;" />

```c++
const int N=1e5+10;

int LargestRectangle(int h[],int n)
{
    int right[N],left[N],stack[N],top=-1;
    for(int i=0;i<n;i++){right[i]=n;left[i]=-1;}
    //计算right[i]:h[i]右边第1个比h[i]小的元素位置 
    for(int i=0;i<n;i++)
    {
        while(top>=0&&h[i]<h[stack[top]]) right[stack[top--]]==i;
        stack[++top]=i;
    }
    //反向扫描，计算left[i]:h[i]左边第1个比h[i]小的元素位置 
    for(int i=n-1;i>=0;i--)
    {
        while(top>=0&&h[i]<h[stack[top]]) left[stack[top--]]==i;
        stack[++top]=i;
    }
    int max=-INF;
    for(int i=0; i<n; i++)
		if(((right[i]-left[i]-1)*h[i])>max) max=(right[i]-left[i]-1)*h[i];
	return max;   
}
```

## 单调队列

> 用Dequeue实现
>
> 模板：
>
> 1. **右出q**：去尾操作：队尾元素出队=>维护**[队列单调]**性
>
> 2. **进q**：新元素入队
> 3. **左出q**：删头操作：队首元素出队=>判断队首元素是否在求解区间**[窗口大小]**内，若不在，则出队
> 4. **取解**：取解操作，取出队列某一位置的解
>
> > 这里可以有不同的顺序，只要保证
> >
> > 1. 插入必须在去尾之后来位置单调性
> > 2. 根据不同题目来改变取解的具体位置

[回顾：队列最大值](####ex:队列最大值(单调队列))

#### ex:滑动窗口最大值

> 单调递减队列= >queue的取解在最左边=>最大值

```c++
const int N=1e5+10;
int * res=new int[n-k+1];
int slidingwindowMax(int a[],int n,int k)
{
    int deque[N],left=0,right=0;//left标记双端队列头和尾
    for(int i=0;i<N;i++)
    {
        while(left<right&&a[i]>=a[deque[right-1]]) right--;//右出q,保证递减队列
        deque[right++]=i;//进q，保存下标，方便调整窗口大小
        while(left<right&&deque[left]<i-k+1) left++;//左出q，保证窗口大小为k(或小于k)
       	if(i-k+1>=0) res[id++]=a[deuqe[left]];//取解，使用q左边最大值
    }
    
}
```

#### ex:最短子数组且和>k

> 数组区间求和=>前缀和
>
> 这样就把子数组和sum=>转换成比排队情况下，对某个人来说，找到**前面(以我为截止点)**比我矮sum的人

* 题目：=>相当于排队，对某个人来说，要找到前面比我最少矮k的人，且我和这个这个人距离最近

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211205164706589.png" alt="image-20211205164706589" style="zoom: 67%;" />

```c++
const int N=1e5+10;

//返回子数组长度
int shortestSubarray(int a[],int n,int k)
{
    //1.prefix sum=>[0,n-1]->[1,n]故申请n+1的数组
    int * sum=new int[n+1]();
    int res=0;
    for(int i=0;i<n;i++) sum[i+1]=sum[i]+a[i];
    //2.维护递增队列
    int deque[N],left=0,right=0;//left标记双端队列头和尾
    for(int i=0;i<N;i++)
    {
        while(left<right&&sum[i]-sum[deque[left]]>=k) res=min(res,i-deque[left]);//左出q+取解，若子数组和>=k统计窗口大小,更新res
        while(left<right&&sum[i]<=sum[deque[right-1]]) right--;//右出q,保证递增队列
        deque[right++]=i;//进q，保存下标，方便计算子数组长度即窗口大小
    }
}
```

> 最大子数组和：
>
> 即把左q的条件判断改为sum[i]-sum[left]>=maxsum，maxsum即为前几次最大的sum[i]-sum[left]

#### ex:带限制的子序列和

> ![image-20211205171249844](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211205171249844.png)

```c++
const int N=1e5+10;

//返回子数组长度
int shortestSubarray(int a[],int n,int k)
{
    int * sum=new int[n]();//sum[i]表示到i截止的最大子序列（不一定要连续）
    int res=a[0];
    int deque[N],left=0,right=0;//left标记双端队列头和尾
    for(int i=0;i<n;i++)
    {
        sum[i]=a[i];
        if(left<right) sum[i]+=sum[deque[left]];//取解
        res=max(res,sum[i]);
        if(left<right&&i-deque[right]>=k) left++;//左出q,保证窗口大小为k
        while(left<right&&sum[deque[right]]<=sim[i]) right--;//右出q，维护递减子序列
        if(sum[i]>0) deque[right++]=i;//进q
    }
    return res;
}
```

#### ex:绝对差不超过限制的最长连续子数组

> 维护一个递增和一个递减栈

![image-20211205185603914](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211205185603914.png)

![image-20211205190242850](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211205190242850.png)



# 数组和矩阵

## ex:对二维数组排序

```c++
void Sort(int * a,int n)
{
    for(int i=0;i<n-1;i++)
    {
        int min=i;
        for(int j=i+1;j<n;j++)
        {
            if(a[j]<a[min]) min=j;
        }
        swap(a[min],a[i]);
    }
}

int main()
{
    int a[N][N];
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            scanf("%d",&a[i][j]);
    sort(&a[0][0],N*N);
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<N;j++) printf("%d",a[i][j]);
        printf("\n");
    }
        
}
```

## 动态规划:数组/矩阵消除递归

>动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**二维数组[矩阵]**来保存。

模板三步：

**第一步骤**：定义**数组元素的含义**[一般都题目里要求的值]，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？

**第二步骤**：找出**数组元素之间的关系式[递推关系]**，我觉得动态规划，还是有一点类似于我们高中学习时的**归纳法**的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用**历史数据**来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。

**第三步骤**：找出**初始值**。学过**数学归纳法**的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是**所谓的初始值**。

#### ex:跳台阶

>一个台阶总共有n级。如果一只青蛙一次可以跳1级，也可以跳2级，也可以跳3级。编写算法对于给定的n，计算出青蛙跳到最顶层总共有多少种跳法。

1. dp[i]:青蛙跳到第i层总共有多少种跳法
2. 递推关系：`F(n)=F(n-1)+F(n-2)+F(n-3)`
3. 初始值：`F(1)=1` `F(2)=2` `F(3)=4`

```c++
//其实也不用一整个数组=>三个变量f1,f2,f3记录f(n-1/2/3)
int F(int n)
{
    int *f=new int[n+1];
    f[1]=1;
    f[2]=2;
    f[3]=4;
    for(int i=3;i<=n;i++)
    {
        f[i]=f[i-1]+f[i-2]+f[i-3];
    }
    return f[n];
}
```

#### ex:最大子数组和

>给定一个含n个整数的数组，数组里可能有正数、负数和零。数组中连续的一个或多个元素组成一个子数组，每个子数组都有一个和。请设计算法求所有子数组之和的最大值。

1. f[i]:以位置i为终点的最大子数组和
2. 递推关系：<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211205194029094.png" alt="image-20211205194029094" style="zoom:50%;" />
3. 初始值：f(0)=a[0]

```c++
//不用数组f(i)=>仅需一个变量f1记录f(i-1)

int MaxSubArraySum(int a[],int n,int & maxStart,int & maxEnd)
{
    int f=a[0],start=0,end=0;
    int maxSum=a[0];maxStart=0;maxEnd=0;
    for(int i=1;i<n;i++)
    {
        if(f>0) f=f+a[i];
        else {f=a[i];start=i}//需更新起点
        end=i;
        if(f>maxSum) {maxSum=f;maxStart=start;maxEnd=end;}
        //若要是最大最短：
        // if(f>maxsum||((maxsum==f)&&(end-start)<(maxend-maxstart)))
    }
}
```

#### ex:最大子数组乘积

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211205194900668.png" alt="image-20211205194900668" style="zoom:50%;" />

## 前缀和

> 在数组不被修改的情况下**数组区间求和**

```c++
sum[0]=0;
for(int i=0;i<=n;i++) sum[i]=sum[i-1]+a[i];
```

#### 差分数组

>频繁对数组的某个**区间**的元素进行**增减**

```c++
diff[0]=a[0];//!!!
for(int i=1;i<n;i++) diff[i]=a[i]-a[i-1];
```

* 对区间i至j的所有元素加上d

```c++
diff[i]+=d;
if(j+1<n) diff[j+1]-=d;
```

* 利用diff恢复数组a

```c++
a[0]=diff[0];
for(int i=1;i<n;i++) a[i]=a[i-1]+diff[i];
```

#### 尺取法

#### ex：正整数数组和大于等于S最短区间

```c++
int MinInterval(int a[],int n,int S)
{
    int s=0,t=0;//两个指针指向区间的起点和终点
    int sum=a[0],min=n+1;
    while(1)
    {
        while(t<n-1&&sum<S) sum+=a[++t];//终点还在a内且sum还未达到S
        if(sum<S) break;//终点已经不在a内，sum还未达到S=>无符合条件的（因为全为正整数=>起点在往后移更不可能达到sum）
        if(t-s+1<min) min=t-s+1;//更短=>更新min
        sum-=a[s++];//起点再向后移一位
    }
    if(min==n+1) min=0;
    return min;
}
```

#### ex:数组循环移位

> 数组循环左移k位：
>
> <=>逆转数组三次：[0,k-1]  [k,n-1] [0,n-1]

```c++
void reverse(int A[],int i,int j)
{
    while(i<j)
    {
        swap(A[i],A[j]);
        i++;
        j--;
    }
}

void Shift(int A[],int n,int k)
{
    reverse(A,0,k-1);
    reverse(A,k,n-1);
    reverse(A,0,n-1);
    
}
```

#### ex:最小未出现正整数

> hashmap

```c++
int FindMissMin(int A[],int n)
{
    int res=0;
    int * map=new int[n+1]();//因为最小未出现正整数最大为n+1，（最小为1）更大就没意义了
    for(int i=0;i<=n;i++) if(A[i]>=1 && A[i]<=n) map[A[i]]=1;
    for(int i=1;i<=n;i++) if(map[i]==0) {res=i;break;}
    delete B;
    return res;
}
```

#### ex:幂集

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211206195515133.png" alt="image-20211206195515133" style="zoom:50%;" />

# 字符串

#### KMP

##### 最长相等前后缀/失败函数

* 动态规划：
  	1. f[j]:p[0~j]的最长相等前后
  	1. 递推关系：<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211206202137277.png" alt="image-20211206202137277" style="zoom:50%;" />
  	1. 初始值：f(0)=-1

```c++
//m是模式串p的长度
void Fail(char P[],int f[],int m)
{
    int k=-1;
    f[0]=-1;
    for(int j=1;j<m;j++)
    {
        while(k>=0&&P[k+1]!=P[j]) k=f[k];
        if(P[k+1]==P[j]) k++;
        f[j]=k;
    }
}
```

##### KMP

```c++
int KMP(char *S,char *P)
{
    int n=strlen(S);
    int m=strlen(P);
    int f[N];
    int i=0,j=0;
    Fail(P,f,m);
    while(j<m&&i<n)
    {
        if(S[i]==P[j])
        {
            i++;
            j++;
        }else if(j==0)
        {
            i++;
        }else
        {
            j=f[j-1]+1;
        }
    }
    if(j==m) return i-m;
    return -1;
}
```

> 给定主串s和模式串p，编写程序输出p在s中出现的首位置，若p不在s中则输出-1。字符串下标从0开始。

```c++
#include <iostream>
#include <string.h>
using namespace std;

int KMPSearch(char * pat,char * mai);
int * LPSArray(char * pat,int m,int * lps);

int KMPSearch(char * pat,char * mai)
{
    int m=0,n=0;
    m=strlen(pat);
    n=strlen(mai);
    int * lps=new int[m];
    lps=LPSArray(pat,m,lps);
    int i=0,j=0;
    for(int k=0;k<m;k++) printf("%d ",lps[k]-1);
    printf("\n");
    for(;i<n;i++)
    {
        if(pat[j]==mai[i]) j++;
        else if (j!=0)
            {
                j=lps[j-1];i--;
            }
        if(j==m) return i-j+1;
    }
    return -1;
}

int * LPSArray(char * pat,int m,int * lps)
{
    int len=0;//length of the matching prefix
    int i=1;//from 1!!
    lps[0]=0;
    for(;i<m;i++)
    {
        if(pat[i]==pat[len])
        {
            lps[i]=len+1;
            len++;
        }
        else if(len!=0)
        {
            len=lps[len-1];
            i--;//recompare!!
        }
             else lps[i]=0;
    }
    return lps;
}

int main(void)
{
    char pattern[100010];
    char mainstring[100010];
    scanf("%s",mainstring);
    scanf("%s",pattern);
    printf("%d",KMPSearch(pattern,mainstring));
    return 0;
}

```



#### ex:求字符串循环节

* 循环结长度：`L=m-f[n-1]-1`
* 判断是否可由循环节完全循环组成：`n%L==0`
* 若不能，需要补齐`L-(n%L)`个字符

#### ex:最长重复子串

* 第二长相等前后缀长度：`f[f[n-1]]+1`
* 最长重复前缀:`max(f[])`
* 最长重复子串：以任意字符开头：`for(int i=0;i<n;i++) {Fail(p+i,f,m-i);max=max(max,max(f[]));}`

#### ex:最短前后缀

```c++
for(int i=0;i<n;i++)
{
    while(f[i]!=-1) f[i]=f[f[i]];
}
```

> ```c++
> #include <iostream>
> #include <string.h>
> using namespace std;
> 
> 
> 
> int * LPSArray(char * pat,int m,int * sps)
> {
>     int len=0;//length of the matching prefix
>     int i=1;//from 1!!
>     sps[0]=0;
>     for(;i<m;i++)
>     {
>         if(pat[i]==pat[len])
>         {
>             sps[i]=len+1;
>             len++;
>         }
>         else if(len!=0)
>         {
>             len=sps[len-1];
>             i--;//recompare!!
>         }
>         else sps[i]=0;
>     }
>     return sps;
> }
> 
> int main(void)
> {
>     int n=0;
>     long long int add=0;
>     scanf("%d",&n);
>     char * str=new char[n];
>     int * sps=new int[n];
>     scanf("%s",str);
>     //将最长相等前后缀保存在sps中
>     sps=LPSArray(str,n,sps);
>     //for(int i=0;i<n;i++) printf("%d",sps[i]);
>     //计算最短相等前后缀
>     for(int i=2;i<n;i++)
>     {
>         if(sps[i]!=0)
>         {
>             int s=sps[i]-1;
>             if(sps[s]!=0) sps[i]=sps[s];
>         }
> 
>     }
>     //for(int i=0;i<n;i++) printf("%d",sps[i]);
>     for(int i=0;i<n;i++)
>     {
>         if(sps[i]!=0) add+=i+1-sps[i];
>     }
> 
>     printf("%lld",add);
>     return 0;
> }
> 
> ```
>
> 

#### BM

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211206204153821.png" alt="image-20211206204153821" style="zoom: 33%;" /><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211206204212495.png" alt="image-20211206204212495" style="zoom: 33%;" />

# 树

* 定义

| 树               |                                                              |
| ---------------- | ------------------------------------------------------------ |
| 度/次数 Degree   | 子结点（子树）的数目                                         |
| 叶结点、分支结点 | degree=0、degree>0                                           |
| 层数（自上而下） | <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102193113218.png" alt="image-20211102193113218" style="zoom:25%;" />**从0开始** |
| 路径长度         | 经历的边数 *=根结点到该结点的层数*                           |
| 高度（自下而上） | 叶节点=0 = 最大层数                                          |
| **二叉树**       |                                                              |
| 五种形态         | <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102193607044.png" alt="image-20211102193607044" style="zoom:25%;" />**别忘记空** |
| 满二叉树         |                                                              |
| 完全二叉树       | <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102194809435.png" alt="image-20211102194809435" style="zoom:33%;" /> |

* 性质

| 二叉树                                                       |
| ------------------------------------------------------------ |
| 含有n个结点的二叉树   <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104141038754.png" alt="image-20211104141038754" style="zoom: 33%;" />  的形态 <=> 二叉树先根序列为1…n时，有<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104141038754.png" alt="image-20211104141038754" style="zoom: 33%;" />种可能的中根序列 <=>  对于入栈序列1…n，有<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104141038754.png" alt="image-20211104141038754" style="zoom: 33%;" />可能的合法出栈序列 |
| 二叉树中层数为 i 的结点至多有 **2^i^** 个，i≥0               |
| 高度为k的二叉树中至多有 **2^k+1^-1** 个结点, k≥0             |
| 叶子结点(度为0)个数为n0，度为2的结点个数为n2，则有：**n0＝n2＋1** |
| **满二叉树**                                                 |
| 有 **2^k+1^-1** 个结点 （高度为k）                           |
| 满二叉树叶结点(度为0)的个数等于非叶结点(度为2)个数加1 **n0＝n2＋1** |
| **完全二叉树**                                               |
| <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102195527695.png" alt="image-20211102195527695" style="zoom: 50%;" /> *按层次顺序*<br/>① 若i≠1，则编号为 i  的结点的父 结点的编号为 $\lfloor i/2 \rfloor$  <br/>②若2i≤n，则编号为 i  的结点的 左孩子的编号为 2i,否则 i  无左孩子<br/>③若2i＋1≤n，则 i 结点的右孩子 结点编号为2i+1,否则 i无右孩子 |
| 一棵具有n个结点的完 全二叉树分支结点个数为 $\lfloor n/2 \rfloor$ ，叶结点个数为n- $\lfloor n/2 \rfloor$ |
| 具有n (n>0)个结点的完全二叉树的高度是$\lfloor log2n \rfloor$  . |

## 二叉树

#### 二叉树存储结构

##### 顺序存储[层次顺序]

* 完全二叉树

> A[i]存储编号为i的结点，结点A[i]的左孩子(若存在)存放在A[2i]处，而A[i]的右孩子(若存在)存放在A[2i+1]处
>
> *这种顺序存储方式是完全二叉树最简单、最节省空间的存储方式。它实际上**只存储了结点信息域之值**， 而未存储其左孩子和右孩子地址，**通过计算即可找到它的左孩子、右孩子和父结点**，寻找子孙结点和祖先结点也非常方便*

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102204543163.png" alt="image-20211102204543163" style="zoom: 33%;" />

* 一般二叉树

> 先加入若干虚结点将其转换成一棵“完全二叉树”，然后再对原来的结点和虚结点统一编号，最后完成顺序存储

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102204713920.png" alt="image-20211102204713920" style="zoom:50%;" />

##### 链接存储

* 结点 NODE

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102205050916.png" alt="image-20211102205050916" style="zoom:33%;" />

```c++
template <typename T>
class Node
{
public:
    Node():data(0),left(NULL),right(NULL){};
    Node(char d):data(d),left(NULL),right(NULL){};
    T data;
    Node *left, *right;
};
```

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102205205355.png" alt="image-20211102205205355" style="zoom:33%;" />

```c++
template <typename T>
class Node
{
public:
    Node():data(0),left(NULL),right(NULL),parent(NULL){};
    Node(char d):data(d),left(NULL),right(NULL),parent(NULL){};
    T data;
    Node *left, *right,*parent;
};
```

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102205505697.png" alt="image-20211102205505697" style="zoom:50%;" />

#### 二叉树遍历

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102212207672.png" alt="image-20211102212207672" style="zoom: 67%;" />

##### 递归遍历

###### 先根遍历

```c++
void PreOrder(Node * t)
{
    if(t==NULL) return;
    printf("%d ",t->data);
    PreOrder(t->left);
    PreOrder(t->right);
}
```

###### 中根遍历

```c++
void InOrder(Node * t)
{
    if(t==NULL) return;
    InOrder(t->left);
    printf("%d ",t->data);
    InOrder(t->right);
}

```

###### 后根遍历

```c++
void PostOrder(Node * t)
{
    if(t==NULL) return;
    PostOrder(t->left);
    PostOrder(t->right);
    printf("%d ",t->data);
}
```

##### 非递归遍历

<img src="https://thenafi36.files.wordpress.com/2014/09/traversal1.png" alt="UVa 536 – Tree Recover | thenafi36" style="zoom: 67%;" />

###### 非递归先根遍历

1. 

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102221254551.png" alt="image-20211102221254551" style="zoom:50%;" />

```c++
void NPreOrder(Node * t)
{
    LinkStack s;
    Node * p = t;
    while(1)
    {
        while(p!=NULL)//自上而下 沿左分支访问结点并压栈（为之后处理右子树保存）
        {
            cout<<p->data;///访问顺序=进栈顺序
            s.push(p);///当前节点压栈
            p=p->left;//左
        }
        
        if(s.IsEmpty()) return;//s为空代表排序结束
        
        p=s.pop();//弹栈保存的左head结点
        p=p->right;//对弹栈的head结点的右子树处理
    }
}
```

2.

> 与1.没什么区别就是压栈的对象不同罢了，1.压栈的是左侧结点，再弹栈后访问其右子树，而2.是直接压栈左侧结点的右子树，再弹栈直接访问

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211102223130188.png" alt="image-20211102223130188" style="zoom:50%;" />

```c++
void NPreOrder(Node * t)
{
    LinkStack s;
    Node * p = t;
    while(1)
    {
        while(p!=NULL)//自上而下 沿左分支访问结点并压栈（为之后处理右子树保存）
        {
            cout<<p->data;//访问顺序=进栈顺序
            s.push(p->right);//右孩子压栈
            p=p->left;//左
        }
        
        if(s.IsEmpty()) return;//s为空代表排序结束
        
        p=s.pop();
    }
}
```

[跳回](######非递归先根遍历树)

###### 非递归中根遍历

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104140123335.png" alt="image-20211104140123335" style="zoom:50%;" />

```c++
void NInnOrder(Node * t)
{
    LinkStack s;
    Node * p = t;
    
    while(1)
    {
        while(p!=NULL)//自上而下 沿左分支访问结点并压栈（为之后处理右子树保存）
        {
            //cout<<p->data;///访问顺序=进栈顺序【先序遍历】
            s.push(p);///当前节点压栈
            p=p->left;//左
        }
        
        if(s.IsEmpty()) return;//s为空代表排序结束
        
        p=s.pop();///出栈
        cout<<p->data;///访问顺序=出栈顺序【后序遍历】
        p=p->right;//右
    }
}
```

> ///:先根算法：结点进栈顺序就是先根访问的顺序，即进栈序列=先根序列
>
> ​	 中根算法：结点出栈顺序就是中根访问的顺序，即出栈序列=中根序列

###### 非递归后根遍历

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104141656315.png" alt="image-20211104141656315" style="zoom: 50%;" />

1. 不弹栈p，只取栈顶元素

> Node * pre:记录前一个访问的结点，看右子树是否已经被访问过

```c++
void NPostOrder(Node * t)
{
    LinkStack s;
    Node * p = t;
    Node * pre = NULL;
    while(1)
    {
        while(p!=NULL)//自上而下 沿左分支*不*访问结点并压栈（为之后处理右子树保存）
        {
            //cout<<p->data;///访问顺序=进栈顺序【先序遍历】
            s.push(p);///当前节点压
            p=p->left;//左
        }
        
        if(s.IsEmpty()) return;//s为空代表排序结束
        
        p=s.top();///先只观察当前节点不出栈
        if(p->right==NULL||pre==p->right)//若无右子树||右子树已经访问过=>才能访问根节点
        {
            p=s.pop();
            cout<<p->data;///*访问*：访问顺序=出栈顺序【后序遍历】
            pre=p;
            p=NULL;
        }
        else p=p->right;//右子树还没访问
        
    }
}
```

2. 弹栈p后让其马上让p再进栈

> 允许结点多次进出栈，栈元素增加关于进栈/ 出栈次数的信息
>
> <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104143121841.png" alt="image-20211104143121841" style="zoom:33%;" />



<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104142944423.png" alt="image-20211104142944423" style="zoom:50%;" />

```c++
void NPostOrder(Node * t)
{
    LinkStack s;//特殊栈：元素为二元组[node,index]
    BiNode * b=NULL;
    Node * p=NULL;//node（普通节点）
    s.push(t,1);//第二个元素为进出栈次数
    while(!s.IsEmpty())
    {
        b=s.pop();
        p=b->node;
        i=b->index;
        if(i==1)//准备访问左子树
        {
            s.push(p,2);
            if(p->left!=NULL) s.push(p->left,1);//访问左子树
        }
        if(i==2)//准备访问右子树
        {
            s.push(p,3);
            if(p->right!=NULL) s.push(p->right,1);//访问右子树
        }
        if(i==2)//准备访问该结点
        {
            cout<<p->data;//*访问*
        }
    }
}
```

##### 层次遍历

> 非递归根遍历：辅助栈【DFS】
>
> (非递归)层次遍历：辅助队列【BFS】

```c++
void LevelOrder(Node * t)
{
    LinkQueue q;
    if(t!=NULL) q.InQueue(t);
    Node * p=NULL;
    while(!q.IsEmpty())
    {
        p=q.Dequeue();
        cout<<p->data;
        if(p->left!=NULL) q.InQueue(p->left);
        if(p->right!=NULL) q.InQueue(p->right);
    }
}
```

> 如何识别每层的结束:
> 设置一个空节点来表示每层的结束，遍历第一层时先将根结点入队，**再将NULL入队**，在遍历过程中若遇到NULL出队则表示此层遍历完毕，再将NULL入队，作为下一层结点的结束

```c++
int depth=0;
void LevelOrder(Node * t)
{
    LinkQueue q;
    
    if(t!=NULL) q.EnQueue(t);
    q.InQueue(NULL);//再将NULL入队
    
    Node * p=NULL;
    while(!q.IsEmpty())
    {
        p=q.Dequeue();
        //在遍历过程中若遇到NULL出队则表示此层遍历完毕
        if(p=NULL)
        {
            depth++;
            //再将NULL入队，作为下一层结点的结束
            q.Enqueue(NULL);
            continue;
        }
        cout<<p->data;
        if(p->left!=NULL) q.EnQueue(p->left);
        if(p->right!=NULL) q.EnQueue(p->right);
    }
}
```

#### 二叉树操作

##### ==二叉树操作框架==

| 算法f (t)<br/>         [处理空树]<br/>        ①处理根（递归出口）结点<br/>        ②递归处理左子树f (Left(t)).<br/>        ③递归处理右子树f (Right(t)).<br/>RETURN.▐ |
| ------------------------------------------------------------ |

***在递归过程中找到某一需要操作的目标状态，插入目标操作***

##### 搜索父节点

* 关键操作：当某节点的左子结点或者右子结点=给出结点，返回该结点

  ​      			  若不等，则在左子树或者右子树里搜索父结点并返回

```c++
Node * Father(Node * t,Node * p)
{
    Node * q=NULL;
    if(t==NULL||p==t) return NULL;
    if(t->left==p||t->right==p) return t;
    q=Father(t->left,p);
    if(q!=NULL) return q;
    return Father(t->right,p);
}
```

##### 搜索item

```c++
Node * Find(Node * t,int item)
{
    Node * q=NULL;
    if(t==NULL) return NULL;
    if(t->data==item) return t;
    q=Find(t->left,item);
    if(q!=NULL) return q;
    return Find(t->right,item);
}
```

##### 释放二叉树

```c++
void Release(Node * t)
{
    if(t==NULL) return;//空树
    Release(t->left);
    Release(t->right);
    delete t;
}

```

##### 删除子树

> 需修改待删除子树的父节点的指针域，设为NULL，防止野指针
>
> 其他直接调用Release

```c++
void DeleteSubTree(Node * t,Node * p)
{
    Node * q=NULL;
    if(p==NULL) return;
    if(p==t) Release(t);//无需修改父结点

    //修改父结点
    q=Father(t,p);
    if(q->left==p) q->left=NULL;
    if(q->right==p) q->right=NULL;
    
    Release(p);
}
```

##### 创建二叉树

> 通过两种遍历序列(非层次遍历)

* 中序&后序

> +**错误检测**

###### 字符串多组输入

###### 字符串长度

```c++
#include <iostream>
#include <string.h>
using namespace std;

class Node
{
public:
    Node():data(0),left(NULL),right(NULL){};
    Node(char d):data(d),left(NULL),right(NULL){};
    char data;
    Node *left, *right;
};

//in:中序遍历 post:后序遍历 
//si:中根遍历序列起点 ei:中根遍历序列终点；sp:后根遍历序列起点 ep:后根遍历序列终点；
//flag用来记录本次创建是否成功（中根序列和后根序列是否能确认唯一二叉树）
Node * CreateBiTree(string & in,string & post,int si,int ei,int sp,int ep,bool & flag)
{
    //如果创建不成功没必要继续遍历（“剪枝”）
    if(flag==false)  return NULL;
    //error 1：
    //即此次划分的中根序列和后根序列长度不一，显然无法转换成二叉树
    if(ei-si+sp-ep!=0)
    {
        flag=false;
    }
    
    //从后根遍历里找到“根”=>即当前后根序列最后一个元素
    char x=post[ep];
    
    
    //找到当前“根”在中根序列的位置=>用来划分左右子树
    int i=0;
    int delta=0;//相对中根序列起点：根在中根序列位置
    for(i=si;i<=ei&&in[i]!=x;i++) delta++;//记录中序根结点位置
    //error 2：
    //即在中根序列中找不到（由后根序列确认的）根
    if(i>ei)
    {
        flag=false;
    }
    
    //以下就是当前序列满初步足确认二叉树的条件=>创建当前根、左子树、右子树
    //创建根
    Node * t=new Node(x);
    
    //当中根序列起点=终点，代表已经到达叶节点，无需对左右子树创建
    if(si==ei) return t;///！到尽头，递归出口=>要放在错误判断后！
    
    //left：划分条件：delta>=1=>存在左子树
    if(delta-1>=0) t->left=CreateBiTree(in,post,si,si+delta-1,sp,sp+delta-1,flag);
    //right：划分条件：ei-(si+delta)>=1=>存在右子树
    if(ei-si-delta-1>=0) t->right=CreateBiTree(in,post,si+delta+1,ei,sp+delta,ep-1,flag);///一定要加条件判断，不然会end<start

    return t;
}

void PreOrder(Node * t)
{
    if(t==NULL) return;
    printf("%c",t->data);
    PreOrder(t->left);
    PreOrder(t->right);
}

int Depth(Node * t)
{
    int dl=0,dr=0;
    if(t==NULL) return -1;//-1!!!不是0！！！

    dl=Depth(t->left);
    dr=Depth(t->right);

    if(dl<dr) return dr+1;
    return dl+1;
}
void Release(Node * t)
{
    if(t==NULL) return;//空树

    Release(t->left);
    Release(t->right);
    delete t;
}
int main(void)
{
    string in,post;
    //字符多组输入
    while(cin>>post&&cin>>in){
        int len=in.length();
        bool flag=true;
        //create tree
        Node * t=NULL;
        t=CreateBiTree(in,post,0,len-1,0,len-1,flag);
        if(flag)
        {
            //高度（自下而上）
            printf("%d\n",Depth(t));
            //preoder
            PreOrder(t);
        }else
        {
            printf("INVALID");
        }
        Release(t);
        printf("\n");
    }
    return 0;
}

```

* 先根序列

[跳回二叉树路径](####二叉树的路径)

>算法CreateBinTree
>
> 输入：包含空指针信息的先根序列 输出：创建的二叉树根指针 t .
>
>当读入’#’字符时，将其初始化为一个空指针；否则 生成一个新结点.
>
><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104153211680.png" alt="image-20211104153211680" style="zoom: 50%;" />



```c++
class Node
{
public:
    Node():data(0),left(NULL),right(NULL){};
    Node(int d):data(d),left(NULL),right(NULL){};
    int data;
    Node *left, *right;
};



Node * CreateBinTree()
{
    int x;
    scanf("%d",&x);
    if(x==0) return NULL;
    Node * t = new Node(x);
    t->left=CreateBinTree();
    t->right=CreateBinTree();
    return t;
}
```

##### 复制二叉树

```c++
Node * CopyBinTree(Node * t)
{
    if(t==NULL) return NULL;
    CopyBinTree(t->left);//复制右子树
    CopyBinTree(t->right);//复制左子树
    //生成根结点
    Node * p=new Node(t->data);
    p->left=new Node();
    p->right=new Node();
    return p;
}
```

##### 后序遍历计算二叉树结点数

> 典型的pure recursion(自下而上)：
>
> induction rule(处理返回的结果)：左子结点+右子节点+1

```c++
int Count(Node * t)
{
    int nl=0,nr=0;
    if(t==NULL) return 0;
    
    nl=Count(t->left);
    nr=Count(t->right);
    
    return nl+nr+1;
}
```

##### 路径长度/二叉树深度

> 典型的backtracking(自上而下)：
>
> 向下传父结点的深度信息=>子结点深度+1

```c++
void Length(Node * t,int depth)
{
    if(t==NULL) return;
    cout<<depth;//输出顺序为先根遍历结点对应的路径长度
    Length(t->left,depth+1);
    Length(t->right,depth+1);
}
```

##### 二叉树高度(自下而上)

> pure recursion:
>
> induction rule:`max(left,right)+1`

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104154543165.png" alt="image-20211104154543165" style="zoom:67%;" />

```c++
int Depth(Node * t)
{
    int dl=0,dr=0;
    if(t==NULL) return -1;//-1!!!不是0！！！叶节点是0
    
    dl=Depth(t->left);
    dr=Depth(t->right);
    
    if(dl<dr) return dr+1;
    return dl+1;
}
```



##### 二叉树中/先/后根序列的首末结点

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104155844121.png" alt="image-20211104155844121" style="zoom:80%;" />

> * 后跟第一个：从根结点开始，沿左分支找第一个叶结点，若找不到则在最左边的结点的右子树沿左分支找叶结点， 以此类推
> * 先跟最后一个：从根结点开始，沿右分支找第一个叶结点，若找不到则在最右边的结点的左子树沿右分支找叶结点， 以此类推

=>p在中根遍历顺序的下一个结点  <=>当p有右孩子时，P的右子树的中根序列第1个结点

​																  当p无右孩子时，将p包含在其左子树的最低祖先

​																							【可以不停搜索父结点直到Father(preFather)->right!=preFather】

## 红黑树

#### insertion

![img](https://media.geeksforgeeks.org/wp-content/uploads/20200506184828/output242.png)



* if the uncle is red, we do recolour 
* if the  uncle is black, we do rotations and/or recolouring 

##### X = root

 change its colour to black

##### X's uncle = red

![img](https://media.geeksforgeeks.org/wp-content/uploads/20200506185231/output243.png)

##### X's uncle = black(linear)

>X & X's parent & X's grandparent is linear
>
>LL rotation/RR rotation

* Left Left Case (LL rotation):

  

  ![img](https://media.geeksforgeeks.org/wp-content/uploads/20200506190350/output244.png)

* Right Right Case (RR rotation):

![img](https://media.geeksforgeeks.org/wp-content/uploads/20200506190822/output246.png)

##### X's uncle = black(triangle)

> X & X's parent & X's grandparent is triangle
>
> LR rotation/RL rotation

* Left Right Case (LR rotation):

![img](https://media.geeksforgeeks.org/wp-content/uploads/20200506190543/output245.png)

* Right Left Case (RL rotation):

![img](https://media.geeksforgeeks.org/wp-content/uploads/20200506191035/output247.png)

summary:

##### **Algorithm:**

![image-20220327114946306](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20220327114946306.png)



## 信息传递

#### backtracking自上而下

*DFS回溯*

> 信息是自上而下传递的:
>
> * 信息由parent node=>left/right node
>
> * 每条我们尝试的道路是互相不影响的

##### ex:二叉树所有路径

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211207184733906.png" alt="image-20211207184733906"  />

> * 传path，到叶节点直接打印
> * 传符合题目条件的字符串string

##### ex:二叉树路径和I

> 路径必须从上至下

* 这题从上至下backtracking即可，并结合了最大子数组和，用动态规划：f[i]以i结尾的前i位的最大子数组和
* [最大子数组和](####ex:最大子数组和)

1. 到叶子节点再判断最大子数组和

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;


const int N =110;
int MaxPath[N];
int MaxPathLength;
int maxl;

class Node
{
public:
    Node():data(0),left(NULL),right(NULL){};
    Node(int d):data(d),left(NULL),right(NULL){};
    int data;
    Node *left, *right;
};



Node * CreateBinTree()
{
    int x;
    scanf("%d",&x);
    if(x==0) return NULL;
    Node * t = new Node(x);
    t->left=CreateBinTree();
    t->right=CreateBinTree();
    return t;
}


//path是backtracking时经过保存的路径，id是path[]的index
//两者捆绑出现
void MaxLength(Node * t,int path[],int id)
{
    if(t==NULL) return;
    
    //更新path
    path[id]=t->data;
    
    //到叶节点找每条路径(根结点->叶节点)path[]的最大子数组和
    if(t->left==NULL&&t->right==NULL)
    {
        //求当前路径根结点->叶节点最大子数组和
        int f=path[0],start=0,end=0;
        int maxsum=path[0],maxstart=0,maxend=0;
        for(int i=1;i<=id;i++)
        {
            if(f>0) f=f+path[i];
            else
            {
                f=path[i];
                start=i;
            }
            end=i;
            if(f>maxsum||((maxsum==f)&&(end-start)<(maxend-maxstart)))
            {
                maxsum=f;
                maxstart=start;
                maxend=end;
            }
        }
        //更新global variables
        //比较当前路径的maxSum与之前考察过的所有路径的最大子数组和
        if(maxsum>maxl||((maxsum==maxl)&&(maxend-maxstart+1)<MaxPathLength))
        {
            maxl=maxsum;
            //maxpath先置零
            //置零也可使用memset：memset(MaxPath,0,sizeof(MaxPath))
            for(int i=0;i<MaxPathLength;i++) MaxPath[i]=0;
            for(int i=0;i<maxend-maxstart+1;i++) MaxPath[i]=path[maxstart+i];
            MaxPathLength=maxend-maxstart+1;
        }
    }
    MaxLength(t->left,path,id+1);//左
    MaxLength(t->right,path,id+1);//右
}


int main(void)
{
    Node * t=NULL;
    t=CreateBinTree();

    //初始化全局变量
    maxl=-INF;
    MaxPathLength=0;
    
    int path[N]={0};
    MaxLength(t,path,0);

    printf("%d\n",maxl);
    for(int i;MaxPath[i]!=0;i++) printf("%d ",MaxPath[i]);

    return 0;
}

```

2. 边backtracking边递推

> 这题不到叶子节点再判断最大子数组和也可
>
> 因为由上至下backtracking的过程就是一步步递推的过程
>
> * 第一种方法：
>
> 多传四个参：`void MaxLength(Node * t,int path,int id,int f,int Start,int End,int maxStart,int maxEnd)`=>用来保存每一步的状态，到叶节点仅需再看当时的maxstart和maxend,比较更新global variables
>
> * 第二种方法：
>
> 多传两个参：多传四个参：`void MaxLength(Node * t,int path,int id,int f,int Start,int End)`每一步不与这条路径的maxStart、maxend、maxsum比较，而是与全局变量（所有路径）比，时刻更新maxPath
>
> > 以下列出到叶子节点再判断最大子数组和+第二种方法

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int INF=0x3f3f3f3f;
const int N =110;

//global variables:c
//MaxPath:保存最大子数组和
//MaxPathLength：保存当前最大子数组和区间长度
//maxl：保存当前最大子数组和sum
int MaxPath[N];
int MaxPathLength;
int maxl;

class Node
{
public:
    Node():data(0),left(NULL),right(NULL){};
    Node(int d):data(d),left(NULL),right(NULL){};
    int data;
    Node *left, *right;
};



Node * CreateBinTree()
{
    int x;
    scanf("%d",&x);
    if(x==0) return NULL;
    Node * t = new Node(x);
    t->left=CreateBinTree();
    t->right=CreateBinTree();
    return t;
}

void MaxLength(Node * t,int path[],int id,int f,int Start,int End)
{
    if(t==NULL) return;

    //更新path
    path[id]=t->data;

    //当 id=0,即path[0]时做初始化:
    //f=path[0],start=0,end=0;
    //但当初始化f<=0（传入的初始调用f）时，可自动初始化

    //递推更新当前位置结尾的最大子数组和
    if(f>0) f=f+t->data;
    else {f=t->data;Start=id;}
    End=id;
    //与global variables比较并更新global variables
    if(f>maxl||((f==maxl)&&(End-Start+1)<MaxPathLength))
    {
        maxl=f;
        for(int i=0;i<MaxPathLength;i++) MaxPath[i]=0;
        for(int i=0;i<End-Start+1;i++) MaxPath[i]=path[Start+i];
        MaxPathLength=End-Start+1;
    }

    MaxLength(t->left,path,id+1,f,Start,End);
    MaxLength(t->right,path,id+1,f,Start,End);
}


int main(void)
{
    Node * t=NULL;
    t=CreateBinTree();

    //初始化全局变量
    maxl=-INF;//相当于初始化maxSum=path[0]
    MaxPathLength=0;


    //
    int path[N]={0};
    MaxLength(t,path,0,-INF,0,0);

    printf("%d\n",maxl);
    for(int i;MaxPath[i]!=0;i++) printf("%d ",MaxPath[i]);

    return 0;
}

```

##### ex:二叉树最深间隔最远结点

* 法一：

> 由于与层次有关，可以[层次遍历](#####层次遍历)，并用NULL进出队标识每层结尾，保存第k层所有节点

```c++
int depth=0;
void LevelOrder(Node * t)
{
    LinkQueue q;
    
    if(t!=NULL) q.EnQueue(t);
    q.InQueue(NULL);//再将NULL入队
    
    Node * p=NULL;
    while(!q.IsEmpty())
    {
        p=q.Dequeue();
        //在遍历过程中若遇到NULL出队则表示此层遍历完毕
        if(p=NULL)
        {
            depth++;
            //再将NULL入队，作为下一层结点的结束
            q.Enqueue(NULL);
            continue;
        }
        cout<<p->data;
        if(p->left!=NULL) q.EnQueue(p->left);
        if(p->right!=NULL) q.EnQueue(p->right);
    }
}
```

法二：

> 先根遍历统计depth(backtracking 自上而下)

```c++
#include<math.h>
using namespace std;

//这里新建了一个pair，用来同时保存结点data和depth
class Bituple
{
    public:
    Bituple():l(0),data(0){};
    Bituple(int v1,int v2):l(v1),data(v2){};
    int l;
    int data;
};

//global variable：
//length:保存每个叶节点的深度
//id:作为length的index
Bituple length[200];//保存每个叶节点的路径长度
int id;


class Node
{
public:
    Node():data(0),left(NULL),right(NULL){};
    Node(int d):data(d),left(NULL),right(NULL){};
    int data;
    Node *left, *right;
};

//由于建树也是自上而下的故可以边建树边找depth
//depth：保存maxdepth：引用传参，与做全局变量没啥区别
//length：表示当前深度
Node * CreateBinTree(int len,int & depth)
{
    int x;
    scanf("%d",&x);
    if(x==0) return NULL;
    Node * t = new Node(x);
    t->left=CreateBinTree(len+1,depth);
    t->right=CreateBinTree(len+1,depth);
    if(t->left==NULL&&t->right==NULL)
    {
        length[id].data=x;length[id].l=len;id++;//叶节点
        if(len>depth) depth=len;
    }
    return t;
}


int main(void)
{
    init();
    Node * t=NULL;//无用
    int depth=0;
    t=CreateBinTree(0,depth);
    int count=0;
    int res1=0,res2=0;
    for(int i=0;i<id;i++)
    {
        if(length[i].l==depth&&count==0) {res1=length[i].l;count=1;}
        if(length[i].l==depth&&count>0) {res2=length[i].l;count++;}
    }
    if(count<2) printf("0\n");
    else printf("%d",abs(res1-res2));
    return 0;
}

```

##### ex: good nodes in path

![image-20211207185505617](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211207185505617.png)

#### pure recursion自下而上

>站在当前这个结点，考虑两个问题：
>
>1. 我怎么**利用左、右子树（传过来）的信息**[子问题的结果]解决题目问题
>2. 假如我作为一个子结点[子问题]，我想要**传给父结点什么信息**才能在父结点那个层面解决题目问题

##### ex:二叉树路径和II

> 路径可以是人字形

```c++
maxSum==-INF;

int MaxPathSum(Node * t)
{
    //如果我是空节点：
    //1.我没有子结点返回的信息需要处理
    //2.那么我不会给我的父结点提供任何path value
    if(t==NULL) return 0;
    
    //让左、右子树给我传信息
    //传信息时做进一步处理：如果左/右子树传过来的maxpathsum<0,那么我们就不会加他们，而会加上0
    int left=MaxPathSum(t->left);
    int right=MaxPathSum(t->right);
    //1.我利用左、右子树（传过来）的maxpathsum，我作为一个“终止结点”想要更新maxSum[global variables]：
	//首先要选择我自己两种情况（人字形/一字型）里最大的那种，再与global variable比较更新
    left=max(0,left);
    right=max(0,right);
    //left+right+t->data即为我自己两种情况（人字形/一字型）里最大的那种
    maxSum=max(maxSum,left+right+t->data);
    
    //2.假如我作为一个子结点[子问题]，我想要传给父结点什么信息：我只能传给父结点包含我自己的一字型数据
    return max(left,right)+t->data;
    
}
```

##### ex：最大平均子树

> <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211207193302368.png" alt="image-20211207193302368" style="zoom: 80%;" />

1. 我怎么**利用左、右子树（传过来）的信息**[子问题的结果]解决题目问题:
   我拿到了左、右子树传过来的valueSum和nodeCount，在计算我自己的valueSum和nodeCount，比较更新global value

2. 假如我作为一个子结点[子问题]，我想要传给父结点什么信息：

   我要告诉他我这个子树的valueSum和nodeCount

>return valueSum和nodeCount时直接return一个数组res就可以
>
>res[0]:valueSum
>
>res[1]：nodeCount



![image-20211207193319430](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211207193319430.png)

##### ex:最长zigzag路径

> <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211207194744610.png" alt="image-20211207194744610" style="zoom:67%;" />
>
> ![image-20211207194911518](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211207194911518.png)

1. 我怎么**利用左、右子树（传过来）的信息**[子问题的结果]解决题目问题:
   我拿到了左、右子树传过来的各自从左边/右边传过来的zigzag路径长度，那么我们对右孩子传过来的左结尾zigzag路径长度+1，对左孩子传过来的右结尾zigzag路径长度+1，比较更新maxLength

2. 假如我作为一个子结点[子问题]，我想要传给父结点什么信息：

   我要告诉他我这个子树的左结尾zigzag路径长度和右结尾zigzag路径长度

   > return 左结尾zigzag路径长度和右结尾zigzag路径长度时直接return一个数组res就可以
   >
   > res[0]:左结尾zigzag路径长度
   >
   > res[1]:右结尾zigzag路径长度

   <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211207214703124.png" alt="image-20211207214703124" style="zoom:67%;" />

##### ex:最长连续单调路径

   >1. 我怎么**利用左、右子树（传过来）的信息**[子问题的结果]解决题目问题:
   >   我拿到了左、右子树传过来的各自decreasing&increasing路径长度，若当前结点比左/右结点大，则增加左&右increasing的path长度，反之
   >2. 假如我作为一个子结点[子问题]，我想要传给父结点什么信息：

   我要告诉他我这个子树的decreasing&increasing路径长度

#### ex:最深节点LCA

   > 由上至下统计深度
   >
   > 由下至上传递信息
   >
   > > 也可分开先求深度再找最深结点组的LCA

   ![image-20211207215045994](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211207215045994.png)

## LCA

> 自下而上：pure recursion
>
> summary:
>
> 1. 找满足条件的孙子结点
> 2. 套LCA模板

以二叉树为例共四种情况：

1. 左右子树分别能找到目标节点=>当前结点即为LCA
2. 两个目标结点都在左子树中=>当前结点的左子结点即为LCA
3. 两个目标结点都在右子树中=>当前结点的右子结点即为LCA
4. 左右子树都没有任一目标结点=>该结点子树中没有LCA
5. 目前节点即为目标结点=>当前结点即为LCA

可以分析发现，情况判断都要用到子树，所以需要自下而上的方法--回溯--DFS，即使用二叉树标准框架即可,在框架中判断这四种情况

```c++
//在root为根的二叉树中找a,b的LCA
//返回data型
int LeastCommonAncestors(node *root, int a, int b)
{
    if(root==NULL) return -1;
    if(root->data==a||root->data==b) return root->data;

    int left=LeastCommonAncestors(root->left,a,b);
    int right=LeastCommonAncestors(root->right,a,b);
    if(left!=-1&&right!=-1) return root->data;
    if(left!=-1) return left;
    if(right!=-1) return right;
    return -1;
}
//返回Node指针型
Node * LeastCommonAncestors(Node *root, Node * a, Node * b)
{
    if(root==NUL||root==a||root==b) return root;

    Node * left=LeastCommonAncestors(root->left,a,b);
    Node * right=LeastCommonAncestors(root->right,a,b);
    if(left!=NULL&&right!=NULL) return root;
    if(left!=NULL) return left;
    if(right!=NULL) return right;
    return NULL;
}

```

* 若给出的点可能不存在：可FindItem，若有一个为NULL，则直接返回NULL
* 若给出parent结点=>将问题转化为找[两个链表的交汇点](##ex:双指针：链表相交点)
* 若需给出多个（≥3）结点的LCA，则只用传这个数组，判断root是否=a/b变成一个for循环，判断root->data是否等于任一元素
* 若最深结点的LCA，则先[层次遍历/先根遍历把所有最深结点保存起来](#####ex:二叉树最深间隔最远结点)，在套LCA模板

## 线索二叉树

> 利用空指针域，使其指向结点的中根前驱或后继
>
> <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104161724340.png" alt="image-20211104161724340" style="zoom:33%;" />

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104161940836.png" alt="image-20211104161940836" style="zoom:50%;" />

* LThread=0 , left 域指示结点t的左孩子
* LThread=1 , left 域指示结点t的中根前驱
* RThread=0 , right 域指示结点t的右孩子
* RThread=1 , right 域指示结点t的中根后继

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104162347124.png" alt="image-20211104162347124" style="zoom: 67%;" />=><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104162602735.png" alt="image-20211104162602735" style="zoom:50%;" />



#### 遍历

##### 中根序列的首末结点

```c++
void FirstInOrder(Node * t)
{
    Node * p=t;
    while(p->LThread==0) p=p->left;
    return p;
}

void LastInOrder(Node * t)
{
    Node * p=t;
    while(p->RThread==0) p=p->right;
    return p;
}
```

##### 中根序列的前驱、后继结点

```c++
void PreInOrder(Node * t,Node * p)
{
    if(p->LThread==1) return p->left; 
    else return LastInOrder(left(p));//p之左子树中根序列的末结点
}

void NextInOrder(Node * t,Node * p)
{
    if(p->RThread==1) return p->right; 
    else return FirstInOrder(right(p));//p之右子树中根序列的首结点
}
```

##### 中根遍历

> 只要先找到中根序列中的第一个结点，然后依次找结点的后继直至其后继为空时为止

```c++
void InOrder(Node * t)
{
    Node * p=FirstInOrder(t);
    while(p!=NULL)
    {
        cout<<p->data;
        p=p->NextInOrder(t,p)
    }
}
```

#### 操作

##### 插入

> 在中序线索二叉树中插入结点p作为结点s的右子结点

无右子树：<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104170739387.png" alt="image-20211104170739387" style="zoom: 33%;" />有右子树：<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104170849328.png" alt="image-20211104170849328" style="zoom:50%;" />

```c++
void InsertRight(Node * p,Node * s)
{
    if(s==NULL||p==NULL) return;
    if(RThread==1) //p无右子树
    {
        p->RThread=1;
        p->LThread=1;
        p->right=s->right;//p的后继结点=s的后继结点
        p->left=s;
        
        s->right=p;
        s->RThread=0;
    }
    else  //p有右子树
    {
        p->RThread=0;
        p->right=s->right;//p的右子树就是s的右子树
        p->LThread=1;
        p->left=s;//p的前驱结点=s
        
        s->right=p;
        
        Node * q==FirstInOrder(p->right);
        q->left=p;//别忘记s原右子树的第一个结点的前驱节点变成p
    }
}
```

##### 删除结点

**考虑二叉树的五种形态**

> ① 若p为叶结点，只须修改s的RThread的值和Right指针
> ②若p无左子树，有右子树，且右子树的中根序列的第一个结点为temp，则把p的右子树变成s的右子树，并修改temp的前驱指针
> ③ 若p无右子树，有左子树，且左子树的中根序列的最后一个结点为temp，则把p的左子树变成s的右子树，并修改temp的后继指针.
> ==**④**==若p既有左子树，又有右子树，temp1为p的右子树的中根序列 中第一个结点， temp为p的左子树的中根序列中最后一个结点。 则把p的左子树变成s的右子树，p的右子树变成temp的右子树。 经过这样的重新链接，可以保证不改变原二叉树的中根序列。
>
> <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104171420169.png" alt="image-20211104171420169" style="zoom: 67%;" />

##### 二叉树中序线索化

> 只需将遍历算法中“访问结点”的操作=>为“建立当前访问的结点与 其中根前驱结点的线索关系”。
>
> pre(全局变量):始终指向当前访问结点p的中根前驱结点

![image-20211104172031050](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104172031050.png)

```c++
void Inorder_threading(Node * r,Node * &pre)
{
    if(p!=NULL)
    {
        Inorder_threading(r->left,pre);//中序线索化p左子树
        
        //处理当前节点和pre结点
        ///无需处理右子树为空的情况=>
        if(p->left==NULL)
        {
            p->LThread=1;
            p->left=pre;
        }
        if(pre!=NULL&&pre->right==NULL)
        {
            pre->RThread=1;
            pre->right=p;
        }
        pre=p;
        Inorder_threading(r->right,pre);//中序线索化p右子树
    }
}
pre->RThread=1;
```



#### 中序扩展二叉树

*只需会画图*

> 空间换时间，把LThread 和 Rthread换成指针域

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211104172444458.png" alt="image-20211104172444458" style="zoom:50%;" />

## 树和二叉树的应用

#### 哈夫曼树

| <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111163135791.png" alt="image-20211111163135791" style="zoom:50%;" /> | <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111163151082.png" alt="image-20211111163151082" style="zoom:33%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 最优二叉树                                                   | WPL值最小                                                    |

##### 存储结构

```c++
template <typename T>
class hNode
{
public:
    hNode():data(0),left(NULL),right(NULL){};
    hNode(int w,hNode * l,hNode * r):data(0),weight(w),left(l),right(r){};
    T data;
    int weight; //结点权值
    hNode *left, *right;
};
```

##### 关键思想

1. 初始操作：对给定的一维hNode数组按权值进行排序
2. step：每次取权值最小的两个结点合并得到新的子树重新插入数组并保持数组依然有序

##### ：构造Huffman树

* O(n^2^)

1. 初始化：森林：每个结点作为根结点作为一颗独立的树，其左右子树均为为空

2. step:在森林中选权值最小的两个**根结点**，new一根新结点作为两根结点的根，并将权值设为两根结点的和,得到新的子树重新插入数   组并保持数组依然有序

    直到森林中只剩一棵树(n-1次操作)=>huffman树

```c++
//假设H[1:n]数组已经排好序
//注意H中数据是从1到n的，不是0到n-1
void Huffman(hNode H[], int n)
{
    //初始化森林：每个结点构成一棵树
	for(int i=1;i<=n;i++)
    {
        H[i]->left=NULL;
        H[i]->right=NULL;
    }
    for(int i=1;i<=n-1;i++)
    {
        //在森林中选权值最小的两个**根结点**，new一根新结点作为两根结点的根，并将权值设为两根结点的和
        hNode * t=new hNode(H[i]->weight+H[i+1]->weight,H[i],H[i+1]);
        //新的子树重新插入数组并保持数组依然有序
        int j=i+2;
        while(j<=n&&H[j]->weight<t->weight)
        {
            H[j-1]=H[j];//向前移！
            j++;
        }
        H[j-1]=t;//是j-1不是j
    }
}
```

##### ：构造Huffman树+求WPL

```c++
//假设H[1:n]数组已经排好序
//注意H中数据是从1到n的，不是0到n-1
int Huffman(hNode H[], int n)
{
    int WPL=0;////////////
    //初始化森林：每个结点构成一棵树
	for(int i=1;i<=n;i++)
    {
        H[i]->left=NULL;
        H[i]->right=NULL;
    }
    for(int i=1;i<=n-1;i++)
    {
        //在森林中选权值最小的两个**根结点**，new一根新结点作为两根结点的根，并将权值设为两根结点的和
        hNode * t=new hNode(H[i]->weight+H[i+1]->weight,H[i],H[i+1]);
        //更新WPL
        WpL += t->weight;
        //新的子树重新插入数组并保持数组依然有序
        int j=i+2;
        while(j<=n&&H[j]->weight<t->weight)
        {
            H[j-1]=H[j];//向前移！
            j++;
        }
        H[j-1]=t;//是j-1不是j
    }
}
```

##### ：求WPL

不用构造树，直接对权值，权值和排序、操作即可

```c++
//给定W[1:n]数组仅有权值且已经排好序
void WPL(int W[],int n)
{
     int WPL=0;////////////
    //初始化森林：每个结点构成一棵树
	//for(int i=1;i<=n;i++)
    //{
    //    H[i]->left=NULL;
    //    H[i]->right=NULL;
    //}
    for(int i=1;i<=n-1;i++)
    {
        //在森林中选权值最小的两个**根结点**，new一根新结点作为两根结点的根，并将权值设为两根结点的和
        //hNode * t=new hNode(H[i]->weight+H[i+1]->weight,H[i],H[i+1]);
        //更新WPL
        t = W[i]+W[i+1];
        WPL += t->weight;
        //新的t重新插入数组并保持数组依然有序
        int j=i+2;
        while(j<=n&&H[j]<t)
        {
            H[j-1]=H[j];//向前移！
            j++;
        }
        H[j-1]=t;//是j-1不是j
    }
}
```

##### 根据哈夫曼树：编码

> 将哈夫曼树每个分支结点的左分支标上0，右分支标上1，把 从根结点到每个叶结点的路径上的标号连接起来，作为该叶结 点所代表的字符的编码

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111173808770.png" alt="image-20211111173808770" style="zoom:50%;" />

```c++
void Encode(hNode * t,char c,int index,int lr,int code[])
{
    if(t==NULL) return;


    if(index>=0) code[index]=lr;
    if(t->data==c)
    {
        for(int i=0;i<=index;i++) printf("%d",code[i]);
        return;
    }
    Encode(t->left,c,index+1,0,code);
    Encode(t->right,c,index+1,1,code);
}
```



##### 根据哈夫曼树：解码

>依次读入文件的二进制码，从哈夫曼 树的根结点出发，若当前读入0，则走向其左孩子，否则走向其右孩子，到达某一叶结点时，便 可以译出相应的字符

```c++
 while(cin>>str)
 {
     hNode * r=root;
     for(int i=0;i<id-1&&str[i]!='\0';i++)
     {
         if(str[i]=='0') r=r->left;
         else r=r->right;
         if(r->data!=0&&str[i+1]=='\0') {res[idx++]=r->data;break;}
         if(r->data==0&&str[i+1]=='\0') {flag=false;break;}
         if(r==NULL) {flag=false;break;}
         if(r->data!=0) {res[idx++]=r->data;r=root;}

     }
     if(flag) printf("%s",res);
     else printf("INVALID");
     printf("\n");
 }
```

##### ex:HUFFMAN

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

//global variables:
//求WPl
int WPL=0;

//Huffman NODE
class hNode
{
public:
    hNode():data(0),left(NULL),right(NULL){};
    hNode(char d):data(d),weight(1),left(NULL),right(NULL){};
    hNode(int w,hNode * l,hNode * r):data(0),weight(w),left(l),right(r){};
    char data;
    int weight; //结点权值
    hNode *left, *right;
};

//注意：如何申请节点（/自定义结构体）数组！
hNode **H = new hNode *[5010];
void init()
{
    for(int i=0; i<5010; i++)
    {
        H[i] = new hNode();
    }
}

//注意H中数据是从1到n的，不是0到n-1
hNode * Huffman(hNode * H[], int n)
{
	for(int i=1;i<=n;i++)
    {
        H[i]->left=NULL;
        H[i]->right=NULL;
    }
    for(int i=1;i<=n-1;i++)
    {
        hNode * t=new hNode(H[i]->weight+H[i+1]->weight,H[i],H[i+1]);
        WPL += t->weight;
        int j=i+2;
        while(j<=n&&H[j]->weight<=t->weight)
        {
            H[j-1]=H[j];
            j++;
        }
        H[j-1]=t;
        if(i==n-1) return t;
    }
}

//对输入的data，进行huffman Encode
//backtracking由上而下传信息，传每步走的path(0 or 1)=>放进code里，index做索引
//lr:上一步传来的是走左还是右
void Encode(hNode * t,char c,int index,int lr,int code[])
{
    if(t==NULL) return;

    //根结点无父结点传来的信息：index=-1
    if(index>=0) code[index]=lr;
    //如果data==c,则这条path就是我们想要的解码
    if(t->data==c)
    {
        for(int i=0;i<=index;i++) printf("%d",code[i]);
        return;
    }
    //左子树:lr=0
    //右子树：lr=1
    Encode(t->left,c,index+1,0,code);
    Encode(t->right,c,index+1,1,code);
}

int main(void)
{
    init();
    //t数组做一个hash映射，保存map(字符串ASCII=>H数组中的位置)
    //t[char]=0:不在H数组中
    //t[char]!=0:在H数组中的位置
    int t[123]={0};
    char temp;
    int id=1;
    int length=0;
    //未排序H数组：
    //首先输入Huffman[],完成其data和weight
    scanf("%c",&temp);
    while(temp!='\n')
    {
        //此字符不在H数组中（第一次出现）
        if(t[(int)temp]==0)
        {
            //创建H[id]:data&weight & 更新t[]:map
            H[id]->data=temp;
            H[id]->weight=1;
            t[(int)temp]=id;//不是0就是H数组位置
            id++;
        }else
        {
            //更新对应H数组位置的weight（+1）
            H[t[(int)temp]]->weight++;
        }
        scanf("%c",&temp);
        length++;
    }


    //对H[1:id-1]数组稳定排序（冒泡排序）
    for(int i=1;i<=id-1;i++)
        for(int j=1;j<=id-1-i;j++)
        if(H[j]->weight>H[j+1]->weight)
        {
            hNode * temp=H[j];
            H[j]=H[j+1];
            H[j+1]=temp;
        }

    //由于构造哈夫曼树时为保持每步剩余数组有序，会改变其排序，故需用a[]保存排序好的Huffman->data
    int a[5010]={0};
    for(int i=1;i<=id-1;i++)
    {
        a[i]=H[i]->data;
    }

    //构造HUFFMAN树
    hNode * root;
    root=Huffman(H,id-1);

    
    //压缩前文本长度（输入字符串长度）
    printf("%d ",length);
    //压缩后文本长度（ceil(WPL/8)）
    printf("%d\n",(int)ceil((float)WPL/8));

    //按排序好的huffman树，对每个data进行Encode
    for(int i=1;i<=id-1;i++)
    {
        int code[5010]={0};
        printf("%c:",a[i]);
        Encode(root,a[i],-1,0,code);
        printf("\n");
    }

    //对输入的01字符串解码
    string str;
    char res[5010];
    bool flag=true;
    int idx=0;
    while(cin>>str)
    {
        hNode * r=root;
        for(int i=0;i<id-1&&str[i]!='\0';i++)
        {
            //字符串输入0：走左子树/1：走右子树
            if(str[i]=='0') r=r->left;
            else r=r->right;
            //如果此时r->data!=0=>碰到字符了=>解码成功=>添加res
            //如果此时r->data==0=>未碰到字符&且没有输入的下一个01了=>解码失败
            //如果此时r->data==NULL=>解码失败
            if(r->data!=0&&str[i+1]=='\0') {res[idx++]=r->data;break;}
            if(r->data==0&&str[i+1]=='\0') {flag=false;break;}
            if(r==NULL) {flag=false;break;}
            if(r->data!=0) {res[idx++]=r->data;r=root;}
			//if(r->data!=0) {res[idx++]=r->data;}
			//if(r->data==0&&str[i+1]=='\0') {flag=false;break;}
			//if(r==NULL) {flag=false;break;}
        }
        if(flag) printf("%s",res);
        else printf("INVALID");
        printf("\n");
    }
    return 0;

}

```



##### 二叉树路径长度+WPL

> 二叉树的带权路径长度（WPL）是二叉树中**所有叶结点**的带权路径长度之和。给定一棵二叉树T，采用二叉链表存储，结点结构为<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111181008792.png" alt="image-20211111181008792" style="zoom: 50%;" />其中叶结点的weight域保存该结点的非负权值。设root为指向T 的根结点的指针，请设计求T的WPL的算法



* 先根遍历路径长度

关键操作：遍历到叶节点时，+weight*depth    [回顾：二叉树路径长度](#####路径长度)

```c++
int WPL=0;
void WPLpreorder(Node * t,int depth)
{
    if(t==NULL) return;
    if(t->left==NULL&&t->right==NULL)
    {
        WPL+=t->weight*depth;
        return;//到了叶节点也无需在访问左右子树
    }
    WPLpreorder(t->left,depth+1);
    WPLpreorder(t->right,depth+1);
}
```

* 层次遍历

[回顾:二叉树层次遍历](#####层次遍历)

关键操作：记录现在遍历到的层数，遍历到叶节点时，+weight*depth  

  				 怎么用层次遍历找路径长度=>*如何记录遍历到的层数？*遍历第一层时，将根节点入队后再将NULL入队，在遍历后层时，每当NULL出队，就将NULL再入队=>**NULL出队：已经遍历完一层**，NULL入队后即为下一层的结尾

```c++
int WPLLevelOrder(Tree & t)
{
    LinkQueue q;
    WPL=0;
    depth=0;
    
    if(t!=NULL) return 0;
    q.InQueue(t);
    q.InQueue(NULL);//遍历第一层时，将根节点入队后再将NULL入队
    
    Node * p=NULL;
    while(!q.IsEmpty())
    {
        p=q.Dequeue();
        //NULL出队：已经遍历完一层，层数+1，NULL再入队后即为下一层的结尾
        if(p==NULL)
        {
            depth++;
            q.InQueue(NULL);
            continue;
        }
        cout<<p->data;
        if(p->left!=NULL) q.InQueue(p->left);
        if(p->right!=NULL) q.InQueue(p->right);
    }
}
```

#### 表达式树



#### 并查集

> * 每棵树代表一个集合
> * 树的每个结点表示集合的一个元素，根结点表示集合的代表元

##### 存储结构

* Father数组

*方便向上查找*

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111200214401.png" alt="image-20211111200214401" style="zoom:50%;" />

##### 操作

###### 建立新集合

关键操作：为输入元素x生成一颗单结点树，x的父结点是特殊值（元素中没有这个特殊值）或是**自己**

```c++
void MakeSet(int x)
{
    Father[x]=0;
}
```

###### 查找所处集合代表元

关键操作：找到输入元素x所在树的根结点（父结点是特殊值（元素中没有这个特殊值）或是自己）

```c++
int Find(int x)
{
    if(Father[x]==0) return x;
    else return Find(Father[x]);
}
```

###### 合并集合

关键操作：合并x所在的树和y所在的树，即让一棵树的根结点的父结点指向另一棵树的根结点

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111201247108.png" alt="image-20211111201247108" style="zoom:50%;" />

```c++
void Union(int x,int y)
{
    Father[Find(x)]=Find(y);
}
```

##### 并查集的优化

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111201730324.png" alt="image-20211111201730324" style="zoom:33%;" />

> 最坏情况：导致Find和Union操作O(n)

=>优化后，均摊时间复杂度都为O(1)

###### 查找所处集合代表元优化

**路径压缩**：将x到根（/代表元）路5径上的所有点的Father改为根（/代表元）

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111202518052.png" alt="image-20211111202518052" style="zoom:50%;" />

```c++
int Find(int x)
{
    if(Father[x]==0) return x;
    //递归查找根结点，同时路径压缩
    Father[x]=Find(Father[x]);c21201206c21201206
    return Father[x];
}
```

###### 合并集合优化

**按秩合并**：具有较小秩的根指向具有较大秩的根.

​				只有根结点的秩在合并时起作用，根结点Father域空闲，故可以用**Father域保存结点的秩的相反数**。

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111201247108.png" alt="image-20211111201247108" style="zoom:50%;" />

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211111204910942.png" alt="image-20211111204910942" style="zoom: 33%;" />

> Father[x]>0：表示x父结点的地址；
> Father[x] ≤ 0：表示x是根， Father[x]值为x秩的相反数

```c++

void Union(int x,int y)
{
    //取xy所在的根
    int fx=Find(x);
   	int fy=Find(y);
    //x,y若在同一棵树
    IF(fx==fy) return;
    //按秩合并
    //fx秩大于fy：fy并入fx
    if(Father[fx]<Father[fy]) Father[fy]=fx;
    //fx秩等于fy：fy/fx并入fx/fy,注意秩+1，即秩的相反数-1
    if(Father[fx]=Father[fy]) {Father[fy]=fx;Father[fx]--;}
    //fx秩小于于fy：fx并入fy
    if(Father[fx]<Father[fy]) Father[fx]=fy;
}
```

##### ex:珍珠项链

```c++
#include<stdio.h>
using namespace std;
struct node {
    int data;
    node* firstChild;
    node* nextBrother;
};

int Father[30010];

void MakeSet(int x)
{
    Father[x]=0;
}

int Find(int x)
{
    if(Father[x]==0) return x;
    Father[x]=Find(Father[x]);//路径压缩
    return Father[x];
}

void Union(int x,int y)
{
    int fx=Find(x);
    int fy=Find(y);
    if(fx==fy) return;
    Father[fx]=fy;
}

int main()
{
    int n, m, T;
    scanf("%d", &T);
    while(T--){
        scanf("%d %d", &n, &m);
        //初始化n个集合
        for(int i=0;i<n;i++) MakeSet(i+1);
        //m个操作
        while(m--)
        {
            int a,b;
            scanf("%d %d", &a, &b);
            Union(a,b);
        }
        for(int i=0;i<n;i++) printf("%d ",Find(i+1));
        printf("\n");
        for(int i=0;i<n;i++) Father[i+1]=0;
    }
    return 0;
}

```



# 图

* 定义

| 简单路径           | 一条路径上除了起点和终点可以相同外，再不能 有相同的顶点      |
| ------------------ | ------------------------------------------------------------ |
| 简单回路           | 一条简单路径的起点和终点相同，且路径长度大于等于2            |
| 支撑子图           | 删边不删点                                                   |
| 连通图             | 无向图：V(G)中任意两顶点都可及                               |
| 强连通图           | 若G为有向图，且对于V(G)中任意两个不同的顶点vi 和vj ， vi与vj可及， vj与vi也可及 |
| 连通分量[不唯一]   | 连通子图Gk再加一个顶点就不连通了                             |
| 强连通分量[不唯一] | 强连通子图Gk再加一个顶点就不连通了                           |

* 性质

| 所有顶点的度数之和 = 2 × 边数                                |
| ------------------------------------------------------------ |
| 无向图的邻接矩阵是**对称**                                   |
| A^n^ i,j  :  顶点Vi到Vj的**路径长度为n**的路径条数           |
| 具有n个顶点的无向图，当至少有 **C^2^n-1+1**条边时可确保它一定是一个连通图（完全图边数+一条边） |
|                                                              |
|                                                              |

### 存储结构和度
| 邻接表   | 对顶点多边少的图（也称稀疏图）   |
| -------- | -------------------------------- |
| 邻接矩阵 | 对顶点少边很多的图（也称稠密图） |

#### 邻接表

> **顺序存储的顶点表**+**接存储的边链表**=>构成的图存储结构

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211112162857828.png" alt="image-20211112162857828" style="zoom: 50%;" /><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211112162934796.png" alt="image-20211112162934796" style="zoom:50%;" />

* 顶点表

```c++
class Vertax
{
public:
    Vertax():Vername(0),adjacent(NULL){}
    int Vername;//顶点名称
    Edge * adjacent;//边链表的头指针
};
```

* 边链表

> 这里边链表中结点排序不分先后，都是顶点的邻接点

```c++
//非权图
class Edge
{
public:
    Edge():VerAdj(0),Link(NULL){}
    Edge(int vid):VerAdj(vid),Link(NULL){}
    int VerAdj;//邻接顶点在顶点表中对应的index
    Edge * Link;//边链表的头指针
};
//权图
class Edge
{
public:
    Edge():VerAdj(0),cost(0),Link(NULL){}
    Edge(int vid,int w):VerAdj(vid),cost(w),Link(NULL){}
    int VerAdj;//邻接顶点在顶点表中对应的index
    int cost;
    Edge * Link;//边链表的头指针
};
```

##### 创建无向图

```c++
void createGraph(LGraph & g)
{
    int a,b,c;
    //顶点名称初始化
    for(int i=0;i<g.numVertax;i++)
    {
        g.Head[i].Vername=i+1;///
        g.Head[i].adjacent=NULL;
    }
    for(int i=0;i<g.numEdge;i++)
    {

        scanf("%d%d%d",&a,&b,&c);
        int v1=a-1,v2=b-1;///对应index
        Edge * q1=new Edge(v2,c);
        Edge * q2=new Edge(v1,c);
        Edge * p1=g.Head[v1].adjacent;
        Edge * p2=g.Head[v2].adjacent;
        q1->Link=g.Head[v1].adjacent;
        g.Head[v1].adjacent=q1;
        q2->Link=g.Head[v2].adjacent;
        g.Head[v2].adjacent=q2;

    }
}
```



##### 无向图的度

* 依序遍历顶点表，遍历过程中统计邻接表的结点个数:

  **用i扫描每个顶点，用p扫描每个顶点对应的邻接顶点/边链表**

##### 创建有向图

```c++
class Edge
{
public:
    Edge():VerAdj(0),cost(0),Link(NULL){}
    Edge(int vid,int w):VerAdj(vid),cost(w),Link(NULL){}
    int VerAdj;//邻接顶点在顶点表中对应的index
    int cost;
    Edge * Link;//边链表的头指针
};
class Vertax
{
public:
    Vertax():Vername(0),adjacent(NULL){}
    int Vername;//顶点名称
    Edge * adjacent;//边链表的头指针
};
class LGraph
{
public:
    LGraph(int v,int e):numVertax(v),numEdge(e){}
    int numVertax;
    int numEdge;
    Vertax Head[N];
};

//要对邻接顶点排序
void createGraph(LGraph & g)
{
    int a,b,c;
    //顶点名称初始化
    for(int i=0;i<g.numVertax;i++)
    {
        g.Head[i].Vername=i;///若从1开始要修改=>i+1
        g.Head[i].adjacent=NULL;
    }
    for(int i=0;i<g.numEdge;i++)
    {

        scanf("%d%d%d",&a,&b,&c);
        int v1=a,v2=b;///对应index:若从1开始要修改=>a-1,b-1
        Edge * q=new Edge(v2,c);
        Edge * p=g.Head[v1].adjacent;
        if(p!=NULL)
        {
            if(p->VerAdj>v2)
            {
                q->Link=g.Head[v1].adjacent;
                g.Head[v1].adjacent=q;
            }else
            {
                for(p;p->Link!=NULL&&p->Link->VerAdj<v2;p=p->Link){}
                Edge * s=p->Link;
                p->Link=q;
                q->Link=s;
            }


        }else
        {
            g.Head[v1].adjacent=q;
        }

    }
}
//不用对邻接顶点排序
void createGraph(LGraph & g)
{
    int a,b,c;
    //顶点名称初始化
    for(int i=0;i<g.numVertax;i++)
    {
        g.Head[i].Vername=i;///若从1开始要修改=>i+1
        g.Head[i].adjacent=NULL;
    }
    for(int i=0;i<g.numEdge;i++)
    {

        scanf("%d%d%d",&a,&b,&c);
        int v1=a,v2=b;///对应index:若从1开始要修改=>a-1,b-1
        Edge * q=new Edge(v2,c);
        q->Link=g.Head[v1].adjacent;
        g.Head[v1].adjacent=q;
    }
}
```

##### 打印图

```c++
void printGraph(Vertax Head[],int n)
{
    for(int i=0;i<n;i++)
    {
        if(Head[i].adjacent!=NULL) printf("%d:",i);
        for(Edge * p=Head[i].adjacent;p!=NULL;p=p->Link)
        {
            printf("(%d,%d,%d)",Head[i].Vername,p->VerAdj,p->cost);
        }
        if(Head[i].adjacent!=NULL) printf("\n");
    }
}
```

##### 图的删边

```c++
void deleteEdge(Vertax Head[],int n)
{
    int v1,v2;
    scanf("%d%d",&v1,&v2);
    Edge * p=Head[v1].adjacent;

    for(;p!=NULL&&p->VerAdj!=v2;p=p->Link){}
    if(p==Head[v1].adjacent)
    {
        Head[v1].adjacent=p->Link;
        delete p;
    }else
    {
        Edge * p1=Head[v1].adjacent;
        while(p1->Link!=p) {p1=p1->Link;}
        p1->Link=p->Link;
        delete p;
    }


}
```



##### 有向图的入度和出度

* 出度：同无向图的度

* 入度：

  * +哈希表

  ```c++
  int * count=new int[n](0);
  void InDegree(Vertax head[],n)
  {
      //用i扫描每个顶点，用p扫描每个顶点对应的邻接顶点/边链表
      for(int i=0;i<n;i++)
      {
          for(Edge * p=head[i].adjacent;p!=NULL;p=p->link)
          {
              int k=p->veradj;
              count[k]++;//count[k]即为顶点表中下标为k的入度的个数
          }
      }
      
  }
  ```

  * 逆邻接表(指向关系相反存储)

#### 邻接矩阵

> 即用矩阵存储
>
> 非权图：0：自己到自己/无边 1：存在边 
>
> 权图：0：自己到自己 权值：存在有权边 ∞：不存在边

##### 创建图

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 110;
const int INF = 0x3f3f3f3f;

class MGraph
{
public:
    MGraph(int v,int e):numVertax(v),numEdge(e){}
    int numVertax;
    int numEdge;
    int Edge[N][N];
};

void createGraph(MGraph & g)
{
    int a,b,c;
    //顶点初始化
    for(int i=1;i<=g.numVertax;i++)
        for(int j=1;j<=g.numVertax;j++)
            g.Edge[i][j]=INF;

    for(int i=0;i<g.numEdge;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        g.Edge[a][b]=c;
        g.Edge[b][a]=c;///无向or有向
    }
}
```



##### 无向图

> 无向图的邻接矩阵对称，可压缩存储；有n个顶点的 无向图所需存储空间为n(n+1)/2

* 无向图的度

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211112161731836.png" alt="image-20211112161731836" style="zoom:50%;" />

**度**：第i行/列有一个1就意味 着有一条以顶点Vi为端点的边

##### 有向图

> 存储空间n^2^

* 有向图的度

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211112161524954.png" alt="image-20211112161524954" style="zoom:50%;" />

**出度**：第i行有一个1，就意味着有一条由Vi引出的边

**入度**：第i列有一个1，就意味着有一条由Vi引入的边


### 图的遍历

> 为了避免重复访问，可设置一个标志顶点**是否被访问过的辅助数组 vis[]**，它的初始状态为 0，在图的 遍历过程中，一旦某一个顶点 i 被访问，就立即让 vis[i] 为 1，防止它被多次访问

#### DFS:递归回溯

对输入的vid访问，并将vis对应位置置为1，再访问vid的未被访问过邻接顶点和其邻接顶点=>调用DFS

```c++
//vis数组初始化
for(int i=0;i<n;i++) vis[i]=0;

//从序号为零的Vertax出发，DFS图
///对于连通图没有必要for循环调用，调用一次即可
for(int i=0;i<n;i++) 
    if(vis[i]=0) DFS(Head,i,vis);

//vid为出发顶点/当前顶点index
void DFS(Vertax Head[],vid,int vis[])
{	
    //访问当前顶点
    cout<<Head[vid].VerName;
    //更新访问数组
    vis[v]=1;
    //再访问其邻接顶点，对未访问邻接顶点a调用DFS
    for(Edge * p=Head[v].adjacent;p!=NULL;p=p->link)
    {
        if(vis[p->Veradj]==0) DFS(Head,p->Veradj,vis);
    }
}
```

*非连通图会多次调用DFS*=>用for循环对每个点调用DFS

#### DFS：栈迭代除递归

[回顾：树的非递归遍历](#####非递归遍历)基本相似：初始访问结点入栈，当栈不为空，循环步骤访问并将**更深入结点**入栈

1. 初始顶点V0入栈
2. 当栈不为空：step：pop一个顶点v，若v未被访问过则访问v，并更新vis[],将未被访问过邻接顶点入栈

```c++
void DFS(Vertax Head[],vid,int vis[])
{	
    LinkStack s;
    for(int i=0;i<n;i++) vis[i]=0;
    //初始顶点V0入栈
    s.push(vid);
    
    //模仿递归
    while(!s.IsEmpty())//while循环本质：扫描每个顶点的边结点，即图中所有边结点，故时间O(e)
    {
        //pop一个顶点v
        s.pop();
        //访问当前pop的顶点
        if(vis[s]==0) cout<<Head[vid].VerName;
        //更新访问数组
        vis[v]=1;
        //将未被访问过邻接顶点入栈
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->link)
        {
            if(vis[p->Veradj]==0) s.push(p->Veradj);
        }
    }
    
}
```

> O(n+e)

#### BFS：队列

> 基本思想：
>
> 1. 首先访问初始点顶点v0；
>
> 2. 之后依次访问与v0邻接的全部顶点w1，w2，...，wk；
>
> 3. 再顺次访问与w1，w2，...，wk邻接的尚未访问的全部顶点；
>
> 4. 再从这些被访问过的顶点出发，逐个访问与它们邻接的尚未访问过的全部顶；
>
> 5. 依此类推，直到连通图中的所有顶点全部访问完为止
>
>    <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211113150607161.png" alt="image-20211113150607161" style="zoom:33%;" />

[回顾：树的层次遍历](#####层次遍历)基本相似：树的层次遍历：初始访问结点入队，当队不为空，循环步骤访问并将**下一层将访问的点**入队

> 队中的顶点是为了保存还未被处理的点



*以下方法与之前BFS（先入队后访问）差不多，只不过我们先访问后入队=>队中的顶点是为了保存还未被处理的点的前一层 ***与先根遍历的版本一二的区别差不多***

1. 初始顶点V0访问后入队
2. 当队不为空：step：Dequeue一个顶点v，将未被访问过邻接顶点访问并更新vis[]后入队

```c++
void BFS(Vertax Head[],vid,int vis[])
{	
    LinkQueue q;
    for(int i=0;i<n;i++) vis[i]=0;
    
    //初始顶点V0先访问后入队
    cout<<Head[vid].VerName;
    vis[vid]=1;
    q.Inqueue(vid);
    
    while(!s.IsEmpty())//while循环本质：扫描每个顶点的边结点，即图中所有边结点，故时间O(e)
    {
        //出队一个顶点v
        v=p.Deuquq();
        //将未被访问过邻接顶点访问后入队
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->link)
        {
            if(vis[p->Veradj]==0)
            {
                //访问当前顶点
                cout<<Head[p->Veradj].VerName;
                //更新访问数组
                vis[p->Veradj]=1;
                //入队
                q.Inqueue(p->Veradj);
            }
        }
    }
}
```

#### 图的遍历应用

##### 无向图的连通分量数

> 之前在递归回溯中说如果是非连通图要多次调用DFS=>调用几次DFS,有多少连通分量

```c++
for(int i=0;i<n;i++) 
    if(vis[i]=0) 
    {
        DFS(Head,i,vis);
        count++;//记录DFS调用次数
    }
```

##### 判断无向图是否连通

> 同样，当DFS只调用一次就是连通的=>count==1

##### 判断顶点u，v是否存在路径

> 以u为起点遍历，看DFS遍历过程中是否经过v<=>访问v

```c++
//vid为出发顶点/当前顶点index
bool DFS(Vertax Head[],u,v,int vis[])
{	
    ////访问当前顶点=>无必要
    //cout<<Head[vid].VerName;
    //更新访问数组
    vis[u]=1;
    if(u==v) return true;//前提uv不同
    //再访问其邻接顶点，对未访问邻接顶点a调用DFS
    for(Edge * p=Head[v].adjacent;p!=NULL;p=p->link)
    {
        if(vis[p->Veradj]==0) 
            if(DFS(Head,p->Veradj,vis)) return true;
    }
    return false;
}
```

##### *顶点u，v路径*

> 再增加一个path[]（prev[]）数组，保存以u为起点遍历经过/访问的结点
>
> 遍历结束时，通过path数组反推路径
>
> <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211113155848453.png" alt="image-20211113155848453" style="zoom:50%;" />

``` c++
//vid为出发顶点/当前顶点index
bool DFS(Vertax Head[],u,v,int vis[])
{	
    ////访问当前顶点=>无必要
    //cout<<Head[vid].VerName;
    //更新访问数组
    vis[u]=1;
    if(u==v) return true;//前提uv不同
    //再访问其邻接顶点，对未访问邻接顶点a调用DFS
    for(Edge * p=Head[v].adjacent;p!=NULL;p=p->link)
    {
        if(vis[p->Veradj]==0) 
        {
            path[p->Veradj]=u;
            if(DFS(Head,p->Veradj,vis)) return true;
		}
    }
    return false;
}
//遍历结束时，通过path数组反推路径
if(DFS(Vertax Head[],u,v,int vis[]))
{
    int temp=v;
    cout<<v;
    while(path[temp]!=u)
    {
        cout<<path[temp];
        temp=path[temp];
    }
    cout<<u;
}//输出路径逆序
```

##### 无向图判环

> 深度/广度优先遍历，遍历过程中遇到之前访问过的顶点=>碰到vis[]=1=>即全程只能vis[]=0

##### 有向图判环

>无向图判环判环方法失效:
>
><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211113160221272.png" alt="image-20211113160221272" style="zoom: 50%;" />
>
>B被访问两次依然是无环状态

> ***三色法***
>
> 将vis增至三个状态：
>
> 1. vis[i]=0，顶点i尚未被遍历到。
> 2. vis[i]=1，顶点i已经被遍历到，但对于它的遍历尚 未结束。该顶点还有若干邻接顶点尚未遍历，当前 算法正在递归地深入探索该顶点的某一邻接顶点。
> 3. vis[i]=2，顶点i的所有邻接顶点（邻接顶点的邻接顶点也完成遍历）已完成遍历，其自身的遍历也已结束。
>
> ![image-20211114154729901](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211114154729901.png)
>
> =>**碰到vis[]=1的顶点=>该顶点还没遍历完，即其邻接顶点或邻接顶点的邻接... ...就是该顶点=>有环**

```c++
bool flag=false;
void HasCircle(Vertax Head[],vid,vis[])
{
    //1. 当前点标记为1
    vis[vid]=1;
    //2. 遍历neighborh：遇到1则有环，遇到零则继续DFS
    for(Edge * p=Head[vid].adjacent;p!=NULL;p=p->Link)
    {
        //如果碰到vis[]=1的顶点，有环
        if(vis[p->Veradj]==1) flag=true;
        //如果碰到vis[]=0的顶点，还未遍历=>遍历
        if(vis[p->Veradj]==0) HasCircle(Head,p->Veradj.vis);
        if(flag) return;//DFS剪枝
    }
    //3. neighborh遍历结束，当前点标记为2
    vis[vid]=2;
}
```

### 拓扑排序问题

> 前提：有向无环图
>
> ​			AOE网：顶点表示活动（或任务)，有向边表示活动（或任务）间的**先后关系**
>
> 拓扑排序就是把AOV网中的所有顶点排成一个**线性序列**[不唯一]：
>
> * 每个顶点出现且只出现一次
> * 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面

#### BFS 正序拓扑

> BFS Kahn算法, 基于贪心，每次从**入度为0**的点开始，正序为拓扑

1. 建图
2. 建入度数组 count[]  [邻接表：有向图的入度](#####有向图的入度和出度)
3. 找入口=>indegree=0入队
4. BFS拓扑排序：与BFS遍历不同（将未访问过的结点入队）=>将每轮更新（从图中删除该顶点及该顶点引出的所有边）的入度为零的顶点入队

```c++
//1. 建图
void BFS_TopoSort(Vertax Head[],int n)
{
    //2. 建入度
    int * count=new int[n]();
    //用i扫描每个顶点，用p扫描每个顶点对应的邻接顶点/边链表
    for(int i=0;i<n;i++)
        for(Edge * p=Head[i].adjacent;p!=NULL;p=p->Link)
            count[p->VerAdj]++;//count[k]即为顶点表中下标为k的入度的个数

    //3. 找入口
    LinkQueue q;
    //将所有入度为零的顶点入队
    for(int i=0;i<n;i++) if(count[i]==0) q.Enqueue(i);
    //4. BFS拓扑排序
    for(int i=0;i<n;i++)
    {
        //尚未输出n个顶点就没有入度为0的顶点了，说明有回路
        if(q.IsEmpty()) {flag=0;return;}
        //若当前入度为0的点有多个(>=2)，则说明拓扑排序不唯一
        //if(q.Member()>1) {flag=2;}
        //出队并访问
        int j=q.Dequeue();
        cout<<Head[j].Vername;
        //“删除”j和j引出的边<=>更新:j的邻接顶点的入度都减一,更新过程中碰到新入度=0的点入队
        for(Edge * p=Head[j].adjacent;p!=NULL;p=p->Link)
        {
            //更新:j的邻接顶点的入度都减一
            count[p->VerAdj]--;
            //更新过程中碰到新入度=0的点入队
            if( count[p->VerAdj]==0) q.Enqueue(p->VerAdj);
        }
    }

}
```

> 优化方法（×）：
>
> 用count数组的空闲位置（入度=0）组织栈或队列
>
> <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211114175039277.png" alt="image-20211114175039277" style="zoom: 33%;" />

#### DFS 逆序拓扑

> 基于搜索vis[]，每次保证当前点**出度为0**后才遍历,逆序为拓扑

* 用三色法 [回顾:有向图判环（vis的三个状态）](#####有向图判环)

1. 建图

2. 建vis[]

3. 所有unvisited点(vis[]=0)展开DFS

   1. 遍历当前点为进行中1

   2. 遍历neighbor:  遇到1则有环, 遇到0继续dfs
   3. 所有neighbor遍历结束，标记当前点为2，已遍历结束，再访问！

```c++
//1. 建图
//2. 建vis[]=>初值为0
void DFS_TopoSort(Vertax Head[],int vid,int vis[])
{
    //3. 所有unvisited点(vis[]=0)展开DFS
    ///1.历当前点为进行中1
    vis[vid]=1;
    ///2. 遍历neighborhood：遇到1则有环，遇到零则继续DFS
    for(Edge * p=Head[vid].adjacent;p!=NULL;p=p->Link)
    {
        //如果碰到vis[]=1的顶点，有环
        if(vis[p->Veradj]==1) {cout<<"有环"<<endl;return;}
        //如果碰到vis[]=0的顶点，还未遍历=>遍历
        if(vis[p->Veradj]==0) DFS_TopoSort(Head,p->Veradj,vis);
    }
    //3. neighborh遍历结束，当前点标记为2，并再访问
    vis[vid]=2;
    cout<<Head[vid].VerName;//别忘记访问！！！
    
}
```

### 关键路径问题

>AOE网：有向边表示活动或任务 (Activity)，用边上的权值表示活动的持续时间， 顶点称为事件(Event)：表示其入边的任务已完成， 出边的任务可开始的状态。
>
>关键路径：
>
>完成整个工程所需的最短时间取决于从源点（入度为0）到汇点（出度为0）的**最长路径长度**，即在这条路径上所有活动的持续时间之和

##### ①事件Vj的最早发生时间

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116130433977.png" alt="image-20211116130433977" style="zoom:50%;" />

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116130325954.png" alt="image-20211116130325954" style="zoom: 50%;" />

> 怎么知道哪个是vj的前驱顶点=>**拓扑排序**：先对 AOE网进行拓扑排序，然后按拓扑序递推

##### ②事件Vj的最晚发生时间

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116130630156.png" alt="image-20211116130630156" style="zoom:50%;" />

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116131707482.png" alt="image-20211116131707482" style="zoom:50%;" />

> 同样为保证Vj的后继结点=>拓扑排序：然后按拓扑逆序递推

##### ③活动ai的最早*开始*时间

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116131214083.png" alt="image-20211116131214083" style="zoom:50%;" />

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116131101760.png" alt="image-20211116131101760" style="zoom:50%;" />

> 由①=>③

##### ④活动ai的最晚*开始*时间

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116131307719.png" alt="image-20211116131307719" style="zoom:50%;" />

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116131352225.png" alt="image-20211116131352225" style="zoom:50%;" />

> 由②=>④

#### ①②③④=>关键路径

> 由以上4点可以看出最关键就是求出每个点的Ve最早发生时间和Vl最晚发生时间，再根据这两个算出活动的最早和最晚开始时间，当最早和最晚开始时间相等时就是关键活动

关键思路：

1. 对AOE网**拓扑排序**
2. 按拓扑序递推事件Vj的最早发生时间Ve<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116130325954.png" alt="image-20211116130325954" style="zoom: 33%;" />
3. 按逆拓扑序递推事件Vj的最晚发生时间Vl<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116131707482.png" alt="image-20211116131707482" style="zoom: 33%;" />
4. 根据ve和vl值，求活动ai的最早开始时间e和最晚开始时间l，若e=l,则对应活动是关键活动

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 210;
const int INF = 0x3f3f3f3f;
class Node
{
public:
    Node():data(0),next(NULL){};
    Node(int d):data(d),next(NULL){};
    int data;
    Node * next;
};

//带有“哨兵”结点的队列
class LinkQueue
{
public:
    LinkQueue():front(new Node()),rear(front){};//初始化空的带有“哨兵”结点的队列
    ~LinkQueue();
    void Enqueue(int d);
    int Dequeue();
    bool IsEmpty();
private:
    Node * front;
    Node * rear;
};


//销毁链式栈
LinkQueue::~LinkQueue()
{
    while(front!=NULL)
    {
        rear=front;
        front=front->next;
        delete rear;
    }
}

//从队尾入队
void LinkQueue::Enqueue(int d)
{
    Node * s=new Node(d);
    rear->next=s;
    rear=s;
}

//从队首出队
int LinkQueue::Dequeue()
{
    if(IsEmpty())
    {
        return -1;
    }
    else
    {
        Node * temp=front->next;//注意这里front一直为哨兵节点，故front->next才是第一个队员
        int tmp=temp->data;
        front->next=temp->next;
        delete temp;
        if(front->next==NULL) rear=front;//及判断删除的节点是否为rear，令rear=front则可满足队空条件
        return tmp;
    }
}

//判断是否为空栈
bool LinkQueue::IsEmpty()
{
    if(front==rear) return true;
    else return false;
}

class Bituple
{
public:
    Bituple():v1(0),v2(0){}
    Bituple(int vv1,int vv2):v1(vv1),v2(vv2){}
    int v1;
    int v2;
};

//global variables:
//flag:判断拓扑排序是否成功（是否有环）
//id:Topo[] index
//Topo[]：记录拓扑排序结果
//ve[]:事件Vj的最早发生时间
//vl[]:事件Vj的最晚发生时间
int flag;
int id;
int Topo[N];
int ve[N];
int vl[N];


class Edge
{
public:
    Edge():VerAdj(0),cost(0),Link(NULL){}
    Edge(int vid,int w):VerAdj(vid),cost(w),Link(NULL){}
    int VerAdj;
    int cost;
    Edge * Link;
};
class Vertax
{
public:
    Vertax():Vername(0),adjacent(NULL){}
    int Vername;
    Edge * adjacent;
};
class LGraph
{
public:
    LGraph(int v,int e):numVertax(v),numEdge(e){}
    int numVertax;
    int numEdge;
    Vertax Head[N];
};

void createGraph(Vertax Head[],int n,int e)
{
    int a,b,c;
    for(int i=0;i<n;i++)
    {
        Head[i].Vername=i+1;///
        Head[i].adjacent=NULL;
    }
    for(int i=0;i<e;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        int v1=a-1,v2=b-1;///
        Edge * q=new Edge(v2,c);
        q->Link=Head[v1].adjacent;
        Head[v1].adjacent=q;
    }
}

//1. 对AOE网拓扑排序=>int Topo[n]
void BFS_TopoSort(Vertax Head[],int n)
{
    int * count=new int[n]();
    for(int i=0;i<n;i++)
        for(Edge * p=Head[i].adjacent;p!=NULL;p=p->Link)
            count[p->VerAdj]++;

    LinkQueue q;
    for(int i=0;i<n;i++) if(count[i]==0) q.Enqueue(i);
    for(int i=0;i<n;i++)
    {
        if(q.IsEmpty()) {flag=0;return;}
        int j=q.Dequeue();
        //cout<<Head[j].Vername;
        Topo[id++]=j;
        for(Edge * p=Head[j].adjacent;p!=NULL;p=p->Link)
        {
            count[p->VerAdj]--;
            if( count[p->VerAdj]==0) q.Enqueue(p->VerAdj);
        }
    }

}


//2. 按正拓扑序递推事件Vj的最早发生时间=>int ve[n]
void VertaxEarliestTime(Vertax Head[],int n)
{
    //初始化所有结点最早发生时间为0即汇点的最晚发生时间（=最早发生时间）
	for(int i=0;i<n;i++) ve[i]=0;
    //从源点（0）到汇点的前驱结点（n-1 -1）向后递推结点最早发生时间
    for(int i=0;i<n-1;i++)
    {
        //按拓扑序找顶点
        int u=Topo[i];
        //向后递推结点最早发生时间(+maxCost)
        for(Edge * p=Head[u].adjacent;p!=NULL;p=p->Link)
        {
            if(ve[u]+p->cost>ve[p->VerAdj]) ve[p->VerAdj]=ve[u]+p->cost;
        }
    }
}

//3. 按逆拓扑序递推事件Vj的最晚发生时间=>int vl[n]
void VertaxLatestTime(Vertax Head[],int n)
{
    //初始化所有结点最早发生时间为ve(n-1)即汇点的最早发生时间（=最晚发生时间）
	for(int i=0;i<n;i++) vl[i]=ve[n-1];
    //（×）从汇点（n-1）到源点的后继结点（1）向前递推结点最晚发生时间
    //（√）由于向前递推不好实现（用邻接表），所以依然用向后递推(邻接顶点)的方式，只不过用后一项-minCost到前一项
    //    =>从汇点的前驱结点（n-1 -1）到源点（0）向后推结点最晚发生时间=>即与ve的区间一致
    for(int i=n-1-1;i>=0;i--)
    {
        //按拓扑逆序找顶点
        int u=Topo[i];
        //依然用向后递推(邻接顶点)的方式，只不过用后一项-minCost到前一项
        for(Edge * p=Head[u].adjacent;p!=NULL;p=p->Link)
        {
            if(vl[u]>vl[p->VerAdj]-p->cost) vl[u]=vl[p->VerAdj]-p->cost;
        }
    }
}


void Sort(Bituple CP[],int n)
{
    int flg=1;
    while(flg)
    {
        flg=0;
        for(int i=0;i<n-1;i++)
        {
            if(CP[i].v1>CP[i+1].v1||(CP[i].v1==CP[i+1].v1&&CP[i].v2>CP[i+1].v2))
            {
                Bituple temp=CP[i];
                CP[i]=CP[i+1];
                CP[i+1]=temp;
                flg=1;
            }
        }
    }
}

//4. 根据ve和vl值，求活动ai的最早开始时间e和最晚开始时间l，若e=l,则对应活动是关键活动
void ActivityStartTime(Vertax Head[],int n)
{
    int res=0;
    int k=0;
    //CP:记录critical path
    //Bituple:v1 & v2
    Bituple CP[N];
    
    //同样，由于最晚开始时间需要递推，故区间同上二，[0,n-2]
    for(int i=0;i<n-1;i++)
    {
        int u=Topo[i];
        for(Edge * p=Head[u].adjacent;p!=NULL;p=p->Link)
        {
            //最早开始时间e[u]=ve[u]
            int e=ve[u];
            //最晚开始时间l[u]=vl[u->next->Veradj]-u->next->cost:p=u->next即u的某个邻接顶点
            int l=vl[p->VerAdj]-p->cost;
            //若e=l,则对应活动是关键活动
            if(e==l)
            {
                //汇点的vl/ve即为完成工程所需的最短时间
                if(p->VerAdj==Topo[n-1]) res=vl[p->VerAdj];
                //加入critical path
                CP[k++]=Bituple(Head[u].Vername,Head[p->VerAdj].Vername);
            }
        }
    }
    //对Critical Path的v1和v2排序
    Sort(CP,k);
    printf("%d\n",res);
    for(int i=0;i<k;i++) printf("%d->%d\n",CP[i].v1,CP[i].v2);

}

int main(void) {

    int n=0,e=0;
    while(scanf("%d%d",&n,&e)!=EOF)
    {
        Vertax Head[N];
        createGraph(Head,n,e);
        flag=1;
        id=0;
        memset(Topo,0,sizeof(Topo));
        memset(ve,0,sizeof(ve));
        memset(vl,0,sizeof(vl));
        //1. 对AOE网拓扑排序=>int Topo[n]
        BFS_TopoSort(Head,n);
        //判断拓扑排序是否成功（是否有环）
        if(flag==0) {printf("unworkable project\n");continue;}
        //CP
        VertaxEarliestTime(Head,n);
        VertaxLatestTime(Head,n);
        ActivityStartTime(Head,n);
    }
    return 0;
}

```

> 时间复杂度皆为:O(n+e)

###最短路径SP问题

***direction*** & ***weight*** & ***cycle***

| 单源最短路径 SSSP     |                                |
| --------------------- | ------------------------------ |
| 无权&图规模大         | BFS                            |
| 非负权                | Dijkstra[+优化]                |
| 有负权                | *Bellman-Ford[+SPFA]* ==不考== |
| 对精度要求不高        | A*                             |
| **多源最短路径 MSSP** |                                |
| 图规模小              | Floyd                          |

> CONCEPT:
>
> Edge Relaxation:
>
> <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116161522059.png" alt="image-20211116161522059" style="zoom:50%;" />
>
> Dv+weight(<v,w>)<Dw, 则更新Dw的值,使Dw=Dv + weight(<v,w>) .
>
> 即拉紧<s,w>，会导致原来的<s,w>绳松弛，而更小的<s,v><v,w>绳紧绷

#### BSF:无权

[回顾:图的BFS遍历](####BFS：队列)

+ 引入两个辅助数组
  + **dist**[i]:记录顶点i到源点s的距离 
    + init: 源点：dist[s]=0/其他顶点：dist[i]=-1
  + **path**[i]:记录最短路径上顶点i的前驱顶点prev
    + init: 所有顶点:dist[i]=-1(源点无前驱顶点，故也为-1)
+ 删去vis[]:由于dist[]未被访问时为-1，即可以用来代替vis[]

关键操作：

1. 源点s 更新dist后入队

2. 当队不为空：step：Dequeue一个顶点v，将未被访问过邻接顶点更新dist和path后入队

```c++
//s:源点
void BFS_SSSP(Vertax Head[],int n,int s,int dist[],int path[])
{
    LinkQueue q;
    //初始化dist path为-1
    for(int i=0;i<n;i++){dist[i]=-1;path[i]=-1;}
    //源点
    dist[s]=0;
    q.Enqueue(s);
    while(!q.IsEmpty())
    {
        int v=q.Dequeue();
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->Link)
        {
            if(dist[p->VerAdj]==-1)
            {
                dist[p->VerAdj]=dist[v]+1;
                path[p->VerAdj]=v;
                q.Enqueue(p->VerAdj);
            }
        }
    }
    
}
```

##### ex:给定俩点

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 210;
const int INF = 0x3f3f3f3f;

class Node
{
public:
    Node():data(0),next(NULL){};
    Node(int d):data(d),next(NULL){};
    int data;
    Node * next;
};

//带有“哨兵”结点的队列
class LinkQueue
{
public:
    LinkQueue():front(new Node()),rear(front){};//初始化空的带有“哨兵”结点的队列
    ~LinkQueue();
    void Enqueue(int d);
    int Dequeue();
    bool IsEmpty();
private:
    Node * front;
    Node * rear;
};


//销毁链式栈
LinkQueue::~LinkQueue()
{
    while(front!=NULL)
    {
        rear=front;
        front=front->next;
        delete rear;
    }
}

//从队尾入队
void LinkQueue::Enqueue(int d)
{
    Node * s=new Node(d);
    rear->next=s;
    rear=s;
}

//从队首出队
int LinkQueue::Dequeue()
{
    if(IsEmpty())
    {
        return -1;
    }
    else
    {
        Node * temp=front->next;//注意这里front一直为哨兵节点，故front->next才是第一个队员
        int tmp=temp->data;
        front->next=temp->next;
        delete temp;
        if(front->next==NULL) rear=front;//及判断删除的节点是否为rear，令rear=front则可满足队空条件
        return tmp;
    }
}

//判断是否为空栈
bool LinkQueue::IsEmpty()
{
    if(front==rear) return true;
    else return false;
}



class Edge
{
public:
    Edge():VerAdj(0),Link(NULL){}
    Edge(int vid):VerAdj(vid),Link(NULL){}
    int VerAdj;//邻接顶点在顶点表中对应的index
    Edge * Link;//边链表的头指针
};
class Vertax
{
public:
    Vertax():Vername(0),adjacent(NULL){}
    int Vername;//顶点名称
    Edge * adjacent;//边链表的头指针
};
class LGraph
{
public:
    Vertax Head[N];
};

void createGraph(Vertax Head[],int n)
{
    //顶点名称初始化
    for(int i=0;i<n;i++)
    {
        Head[i].Vername=i;
        Head[i].adjacent=NULL;
    }
    for(int i=0;i<n;i++)
    {
        int v1=0,num=0;
        scanf("%d%d",&v1,&num);
        while(num--)
        {
            int v2=0;
            scanf("%d",&v2);
            Edge * q=new Edge(v2);
            Edge * p=Head[v1].adjacent;
            if(p!=NULL)
            {
                q->Link=Head[v1].adjacent;
                Head[v1].adjacent=q;
            }
        }

}


//s:source源点；tg:target汇点
void BFS_SSSP(Vertax Head[],int n,int s,int tg,int dist[])
{
    LinkQueue q;
    //初始化dist path为-1
    for(int i=0;i<n;i++){dist[i]=-1;}
    dist[s]=0;
    q.Enqueue(s);
    while(!q.IsEmpty())
    {
        int v=q.Dequeue();
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->Link)
        {
            if(dist[p->VerAdj]==-1)
            {

                dist[p->VerAdj]=dist[v]+1;
                if(p->VerAdj==tg) {printf("%d\n",dist[p->VerAdj]);return;};
                q.Enqueue(p->VerAdj);
            }
        }
    }
    printf("connection impossible\n");

}

int main() {
    int n=0,m=0;
    while(scanf("%d %d",&n,&m)!=EOF)
    {
        LGraph g;
        createGraph(g.Head,n);
        while(m--)
        {
            int v1,v2;
            scanf("%d %d",&v1,&v2);
            int * dist=new int[n]();
            BFS_SSSP(g.Head,n,v1,v2,dist);
        }

    }

    return 0;


}
```



#### Dijkstra:无负权

* 引入两个辅助数组

  + **dist**[i]:记录顶点i到源点s的距离 
    + init: 源点：dist[s]=0/其他顶点：dist[i]=+∞

  + **path**[i]:记录最短路径上顶点i的前驱顶点prev
    + init: 所有顶点:dist[i]=-1(源点无前驱顶点，故也为-1)

* 把所有顶点分成两个集合S和V-S

  * 引入hash数组集合S，对顶点i：*【类似vis[]】*
    * S[i]=0:i还未确定最短路径
    * S[i]=1:i已确定最短路径
  * 每次加入dist[i]最小的顶点加入S=>s[i]=1

关键操作：

1. 初始化所有顶点dist为+∞，源点s 的dist[s]=0，并把源点加入s，更新s的邻接顶点更新dist,path

2. n-1次step（剩下顶点进入S）：
   1. 选择未进入S中dist最小的顶点v加入S（S[v]=1）
   2. 将v未加入S的邻接顶点更新dist,path

```c++
//注意这里的n是包括源点的顶点数
void Dijkstra(Vertax Head[],int n,int s,int dist[],int path[])
{
    //1. 创建集合S
    int * S=new int[n]();
    //1.初始化dist path
    for(int i=0;i<n;i++){dist[i]=INF;path[i]=-1;}
    //1. 把源点加入s
    dist[s]=0;
    S[s]=1;
    //1.可直接更新s的邻接顶点更新dist,path
    for(Edge * p=Head[s].adjacent;p!=NULL;p=p->Link)
    {
            dist[p->VerAdj]=dist[s]+p->cost;
            path[p->VerAdj]=s;
    }
    //2.n-1次step（直到所有顶点进入s）
    for(int i=0;i<n-1;i++)
    {
        //2.1 选择未进入S中dist最小的顶点v加入S（s[v]=1）[第一次是源点进入s]
        int min=INF;
        int v=0;
        for(int j=0;j<n;j++)
            if(S[j]==0&&dist[j]<min)
                {min=dist[j];v=j;}
        //注意，当为选择到最短路径时（图不连通时）=>直接返回！不然会超时
        if(v==0) return;
        S[v]=1;
        //2.2 将v未加入S的邻接顶点更新dist,path
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->Link)
        {
            //if((S[p->VerAdj]==0&&((dist[v]+p->cost)<dist[p->VerAdj]))||(((dist[v]+p->cost)==dist[p->VerAdj])&&Cornercase(v,p->VerAdj,path)))
            if(S[p->VerAdj]==0&&dist[v]+p->cost<dist[p->VerAdj])
            {
                dist[p->VerAdj]=dist[v]+p->cost;
                path[p->VerAdj]=v;

            }
        }
    }
}
```

##### ex:corner case

> 顶点0到某顶点存在多条最短路径，则输出经过顶点最少的那条路径，例如图1(a)中0到4的经过顶点最少的最短路径为0 - 3 - 4。若存在多条最短路径且其经过顶点个数相等，则输出字典序最小者。例如图1(b)中0到5的满足条件的最短路径为0 - 2 - 5。

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 20010;
const int INF = 0x3f3f3f3f;

class Edge
{
public:
    Edge():VerAdj(0),cost(0),Link(NULL){}
    Edge(int vid,int w):VerAdj(vid),cost(w),Link(NULL){}
    int VerAdj;//邻接顶点在顶点表中对应的index
    int cost;
    Edge * Link;//边链表的头指针
};
class Vertax
{
public:
    Vertax():Vername(0),adjacent(NULL){}
    int Vername;//顶点名称
    Edge * adjacent;//边链表的头指针
};
class LGraph
{
public:
    LGraph(int v,int e):numVertax(v),numEdge(e){}
    int numVertax;
    int numEdge;
    Vertax Head[N];
};

void createGraph(LGraph & g)
{
    int a,b,c;
    //顶点名称初始化
    for(int i=0;i<g.numVertax;i++)
    {
        g.Head[i].Vername=i;
        g.Head[i].adjacent=NULL;
    }
    for(int i=0;i<g.numEdge;i++)
    {

        scanf("%d%d%d",&a,&b,&c);
        int v1=a,v2=b;//对应index
        //头插法
        Edge * q=new Edge(v2,c);
        Edge * p=g.Head[v1].adjacent;
        if(p!=NULL)
        {
            //若不需排序，直接尾插，不然会超时
            q->Link=g.Head[v1].adjacent;
            g.Head[v1].adjacent=q;
        }else
        {
            g.Head[v1].adjacent=q;
        }

    }
}

bool Cornercase(int v1,int v2,int path[])
{
    //比较路径长度
    int cnt1=0,cnt2=0;
    int vv1=v1,vv2=path[v2];

    if(path[v1]==-1) return false;
    while(path[v1]!=0)
    {
        if(path[v1]==-1) return false;
        cnt1++;
        v1=path[v1];
    }
    if(path[v2]==-1) return false;
    while(path[v2]!=0)
    {
        if(path[v2]==-1) return false;
        cnt2++;
        v2=path[v2];
    }
    if(cnt1+1<cnt2) return true;
    if(cnt1+1>cnt2) return false;//应该不存在
    //比较字典序
    while(path[vv1]!=path[vv2])
    {
        vv1=path[vv1];
        vv2=path[vv2];

    }
    if(vv1<vv2) return true;
    return false;
}

//注意这里的n是包括源点的顶点数
void Dijkstra(Vertax Head[],int n,int s,int dist[],int path[])
{
    //1. 创建集合S
    int * S=new int[n]();
    //1.初始化dist path
    for(int i=0;i<n;i++){dist[i]=INF;path[i]=-1;}
    //1. 把源点加入s
    dist[s]=0;
    S[s]=1;
    //1.可直接更新s的邻接顶点更新dist,path
    for(Edge * p=Head[s].adjacent;p!=NULL;p=p->Link)
    {
            dist[p->VerAdj]=dist[s]+p->cost;
            path[p->VerAdj]=s;
    }
    //2.n-1次step（直到所有顶点进入s）
    for(int i=0;i<n-1;i++)
    {
        //2.1 选择未进入S中dist最小的顶点v加入S（s[v]=1）[第一次是源点进入s]
        int min=INF;
        int v=0;
        for(int j=0;j<n;j++)
            if(S[j]==0&&dist[j]<min)
                {min=dist[j];v=j;}
        //注意，当为选择到最短路径时（图不连通时）=>直接返回！不然会超时
        if(v==0) return;
        S[v]=1;
        //2.2 将v未加入S的邻接顶点更新dist,path
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->Link)
        {
            if((S[p->VerAdj]==0&&((dist[v]+p->cost)<dist[p->VerAdj]))||(((dist[v]+p->cost)==dist[p->VerAdj])&&Cornercase(v,p->VerAdj,path)))
            //if(S[p->VerAdj]==0&&dist[v]+p->cost<dist[p->VerAdj])
            {
                dist[p->VerAdj]=dist[v]+p->cost;
                path[p->VerAdj]=v;

            }
        }
    }
}

//通过prev[]打印路径
void printPath(int path[],int n)
{
    bool flag=true;//保存路径是否连通
    //保存路径的逆序
    int * tmp=new int[n]();
    int idx=0;//tmp的index
    //i遍历路径target
    for(int i=1;i<n;i++)
    {
        //清零index
        idx=0;
        memset(tmp,0,sizeof(tmp));
        //tmp[0]=target
        int j=i;
        while(j!=0)
        {
            if(j<0) {flag=false;break;}
            tmp[idx++]=j;
            j=path[j];

        }
        if(flag)
        {
            printf("0");
            for(int i=idx-1;i>=0;i--) {printf("->%d",tmp[i]);}
            printf("\n");
        }


    }
}

int main() {
    int n=0,e=0;
    scanf("%d %d",&n,&e);
    LGraph g(n,e);
    createGraph(g);
    int * dist=new int[n]();
    int * path=new int[n]();
    Dijkstra(g.Head,g.numVertax,0,dist,path);
    printPath(path,n);
    return 0;


}

```

##### ex:无向图外增路径

![image-20211208212344078](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211208212344078.png)

* 是否增加外增路径？：
* 可以比对增加这个外增路径`(v1,v2)`后，`dist(s,v1)+dist(v1,v2)+dist(v2,t)`相比`dist(s,t)`是否变小了，如果变小了就更新

* 那么如何获得`dist(s,v1)`&`dist(v2,t)`?
  * :no_entry_sign: floyd:由于floyd可以获取任意俩点的路径，故我们首先想到的是floyd，但是题目中可以看出，有两万个顶点，如果我们用两万个顶点建图有`Edge[20010][20010]`:即使放在堆（全局变量）里也会空间不足
  * :heavy_check_mark: dijktra:我们可以使用两次dijkstra算法，分别求源点和汇点到其他顶点的SP

* 又由于是无向图，所以外增路径可能是`(v1,v2)`或`(v2,v1)`

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 20010;
const int INF = 0x3f3f3f3f;

//global variables:
//flag用来记录换乘站
int flag=-1;

class Edge
{
public:
    Edge():VerAdj(0),cost(0),Link(NULL){}
    Edge(int vid,int w):VerAdj(vid),cost(w),Link(NULL){}
    int VerAdj;//邻接顶点在顶点表中对应的index
    int cost;
    Edge * Link;//边链表的头指针
};
class Vertax
{
public:
    Vertax():Vername(0),adjacent(NULL){}
    int Vername;//顶点名称
    Edge * adjacent;//边链表的头指针
};
class LGraph
{
public:
    LGraph(int v,int e):numVertax(v),numEdge(e){}
    int numVertax;
    int numEdge;
    Vertax Head[N];
};

void createGraph(LGraph & g)
{
    int a,b,c;
    //顶点名称初始化
    for(int i=0;i<g.numVertax;i++)
    {
        g.Head[i].Vername=i+1;
        g.Head[i].adjacent=NULL;
    }
    for(int i=0;i<g.numEdge;i++)
    {

        scanf("%d%d%d",&a,&b,&c);
        int v1=a-1,v2=b-1;//对应index
        Edge * q1=new Edge(v2,c);
        Edge * q2=new Edge(v1,c);
        Edge * p1=g.Head[v1].adjacent;
        Edge * p2=g.Head[v2].adjacent;
        if(p1!=NULL)
        {
            q1->Link=g.Head[v1].adjacent;
            g.Head[v1].adjacent=q1;
        }else
        {
            g.Head[v1].adjacent=q1;
        }
        if(p2!=NULL)
        {
            q2->Link=g.Head[v2].adjacent;
            g.Head[v2].adjacent=q2;
        }else
        {
            g.Head[v2].adjacent=q2;
        }

    }
}

void Dijkstra(Vertax Head[],int n,int s,int dist[])
{
    int * S=new int[n]();
    for(int i=0;i<n;i++){dist[i]=INF;}
    dist[s]=0;
    S[s]=1;
    for(Edge * p=Head[s].adjacent;p!=NULL;p=p->Link)
    {
            dist[p->VerAdj]=dist[s]+p->cost;
    }

    for(int i=0;i<n-1;i++)
    {
        int min=INF;
        int v=0;
        for(int j=0;j<n;j++)
            if(S[j]==0&&dist[j]<min)
                {min=dist[j];v=j;}
        if(v==0) return;
        S[v]=1;
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->Link)
        {
            if(S[p->VerAdj]==0&&(dist[v]+p->cost)<dist[p->VerAdj])
            {
                dist[p->VerAdj]=dist[v]+p->cost;

            }
        }
    }
}


int main() {
    int n=0,s=0,t=0;
    while(scanf("%d %d %d",&n,&s,&t)!=EOF)
    {
        int e=0;
        scanf("%d",&e);
        LGraph g(n,e);
        createGraph(g);
        //我们可以使用两次dijkstra算法，分别求源点和汇点到其他顶点的SP
        int * dist1=new int[n]();
        int * dist2=new int[n]();
        Dijkstra(g.Head,g.numVertax,s-1,dist1);
        Dijkstra(g.Head,g.numVertax,t-1,dist2);
        
        int pls=0,flag=-1;
        int res=dist1[t-1];
        //pls：外增路径数
        scanf("%d",&pls);
        while(pls--)
        {
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);
            int v1=a-1,v2=b-1;//对应index
            //增加这个外增路径`(v1,v2)`后，`dist(s,v1)+dist(v1,v2)+dist(v2,t)`相比`dist(s,t)`是否变小
            //又由于是无向图，所以外增路径可能是`(v1,v2)`或`(v2,v1)`，两次比对
            if(dist1[v1]+dist2[v2]+c<res || (dist1[v1]+dist2[v2]+c==res&&v1<flag))
            {
                flag=v1;
                res=dist1[v1]+dist2[v2]+c;
            }

            if(dist1[v2]+dist2[v1]+c<res || (dist1[v2]+dist2[v1]+c==res&&v2<flag))
            {
                flag=v2;
                res=dist1[v2]+dist2[v1]+c;
            }
        }
        printf("%d\n",res);
        if(flag!=-1) printf("%d\n",flag+1);
        else printf("no metro\n");
        flag=-1;
    }
    return 0;


}
```



#### A*:精度要求低

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211116172238672.png" alt="image-20211116172238672" style="zoom:50%;" />

#### Floyd:MSSP

**核心思想**：在i,j顶点间插一个k点（在除i，j之外遍历尝试），若dist<i,k>+dist<k,j><dist<i,j>,更新dist<i,j>

​					三层循环：

​					`for(int k=0;k<n;k++)`

​							`for(int i=0;i<n;i++)`

​									`for(int j=0;j<n;j++)`

=>用**邻接矩阵**

* 引入二维数组A[n] [n]：A[i] [j]是 vi 至 vj 最短路径长度
* 引入二维数组path（prev）：path[i] [j]表示i至j的最短路径中顶点 j 的前一个顶点的编号,若无则为-1（以i为源点的path[j]）

关键思想：

1. 初始化结果矩阵A[i] [j]=edge[i] [j] &path[i] [j]=i/-1
2. 三层循环（i，j中插k），若dist<i,k>+dist<k,j><dist<i,j>,更新dist<i,j>，path[i] [j]更新为path[k] [j]

```c++
void Floyd(int Edge[N][N],int n,int (&A)[N][N],int (&path)[N][N])
{
    //初始化结果矩阵A[i][j]&path[i][j]
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            //两点间初始距离初始化为两点间最大距离：权值
            A[i][j]=Edge[i][j];
            //两点间prev数组初始化为前顶点，若两点不连通，则初始化prev为-1
            if(A[i][j]<INF) path[i][j]=i;
            else path[i][j]=-1;
        }
    //三层循环（i，j中插k）
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
        	for(int j=1;j<=n;j++)
            {
                //若dist<i,k>+dist<k,j><dist<i,j>,更新dist<i,j>，path[i][j]
                if(A[i][j]>A[i][k]+A[k][j])
                {
                    A[i][j]=A[i][k]+A[k][j];
                    path[i][j]=path[k][j];//更新为path[k,j]不是k!!!
                }
            }
}
```

#### :star:通过prev[]打印路径

```c++
//通过prev[]打印路径
void printPath(int path[],int n)
{
    bool flag=true;//保存路径是否连通
    //保存路径的逆序
    int * tmp=new int[n]();
    int idx=0;//tmp的index
    //i遍历路径target
    for(int i=1;i<n;i++)
    {
        //清零index
        idx=0;
        memset(tmp,0,sizeof(tmp));
        //tmp[0]=target
        int j=i;
        while(j!=0)
        {
            if(j<0) {flag=false;break;}
            tmp[idx++]=j;
            j=path[j];

        }
        if(flag)
        {
            printf("0");
            for(int i=idx-1;i>=0;i--) {printf("->%d",tmp[i]);}
            printf("\n");
        }


    }
}
```



### 最小支撑树MST问题

> 由G中n个顶点和**n-1条**边构成且**边权之和**最小的连通子图

* 引入TE[n-1]保存结果边：三元组：`int head,int tail,int cost`
  * count：MST中已加入边的计数器，做index

#### prim算法:逐点加入

> 逐点加入最小跨集合边=>直至加入所有点

* 引入两个辅助数组：
  * U[v]:集合U，将原点集分成U和V，同时标记顶点是否在v集合和若不在则保存最小跨边Lowcost的左端点
    * 若某点v未加入U，则U[v]保存该点和已经加入U的点的最小边权的U的那个点
    * 若某点v已经加入U，则U[v]=-1以标识
  * **Lowcost[v]**:以免每次找最小跨边都要重复**计算U中所有顶点和V-U中所有顶点的最小跨边**，**保存**以下次使用
    * 若某点v未加入U，则Lowcost[v]保存该点和已经加入U的点的最小边权
    * 若某点v已经加入U，则Lowcost[v]=0以标识

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211120182250647.png" alt="image-20211120182250647" style="zoom:50%;" />



核心思路:

1. 初始化：任加一点进入U（U(v)=-1）
2. 直到U=V（n-1次循环）:step:找边权最小的跨集合边，TE保存结果，更新U和lowcost（将边加入TE并将边另一点加入U）

```c++
class Trituple
{
public:
    Trituple(int h,int t,int c):head(h),tail(t),cost(c){}
    int head;
    int tail;
    int cost;
}

int Lowcost[N];
int U[N];

void Prim(int Edge[N][N],int n)
{
    //1.初始化：将顶点1加入集合U，并更新count，Lowcost，U
    for(int i=1;i<=n;i++)
    {
        //Lowcost(最小跨边)都初始化为1与其他边距离
        Lowcost[i]=Edge[1][i];
        //a'u'o'yo边未进入U，初始化为1(最小跨边的U点)
        U[i]=1;
    }
    //1.将顶点1加入集合U,count=1
    U[1]=-1;
    int count=1;
    
    //2.n-1次循环每次加入最小跨边的点（直到U=V）
    for(int i=1;i<=n-1;i++)
    {
        //找未加入U集合的最小跨边边权(Lowcost(!=0)的最小值)和对应（U-V）的点
        int v=0,min=INF;
        for(int j=1;j<=n;j++)
        {
            if(U[j]!=-1&&Lowcost[j]<min)
            {
                v=j;
                min=Lowcost[j];
            }
        }
        if(v==0) return;//加入U的点还没有n,就找不到最小跨边，表明图不连通，直接退出算法
        //像结果数组添加一条边
        //v:最小跨边权对应U-V中点（右顶点）
        //U(v):最小跨边权对应U中点（左顶点）
        //Lowcost[v]:最小跨边权
        TE[count]=Trituple(U(v),v,Lowcost[v]);
        //由于U加入v,更新count，U[v]，Lowcost[v]=0
        count++;U[v]=-1;
        Lowcost[v]=0;
        //由于集合变化（v移到U集合），以v为左端点(Edge[v][U-V])重新比较更新(U-V)中的Lowcost和U-V集合中的U值
        for(int j=1;j<=n；j++)
        {
            if(U[j]!=-1&&Edge[v][j]<Lowcost[j])
            {
                U[j]=v;
                Lowcost[j]=Edge[v][j];
            }
        }
    }
    
}
```

##### ex:MST路径最大边

> 第一行为2个整数n和m，n为图中顶点个数，m为边的条数，n≤2000，m≤30000。接下来m行，每行3个整数a、b、c，表示顶点a和顶点b之间有一条权值为c的边，c不超过65535。随后一行为一个整数T，表示查询数目。接下来T行，每行2个整数a和b，表示查询最小支撑树中顶点a和b间路径中的最大边。

* 引入maxcost：保存任意两点之间MST路径的最大边权
  * 跨边：U-V中v，和U中最小跨边应的u=U[v]:
    * `maxcost[u][v]=Lowcost[v]`
    * `maxcost[v][u]=maxcost[u][v]`
  * U中任意点s和u=U[v] (已加入MST)确定maxcost:
    * `maxcost[s][v]=max(maxcost[u][v],maxcost[s][u])`
    * `maxcost[v][s]=maxcost[s][v]`

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 2010;

const int INF = 0x3f3f3f3f;

int Lowcost[N];
int maxcost[N][N];
int U[N];

class MGraph
{
public:
    MGraph():numVertax(0),numEdge(0){}
    int numVertax;
    int numEdge;
    int Edge[N][N];
};

MGraph g;

void createGraph(MGraph & g)
{
    int a,b,c;
    //顶点初始化
    for(int i=1;i<=g.numVertax;i++)
        for(int j=1;j<=g.numVertax;j++)
            g.Edge[i][j]=INF;

    for(int i=0;i<g.numEdge;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        g.Edge[a][b]=c;
        g.Edge[b][a]=c;
    }
}

void Prim(int Edge[N][N],int n)
{
    for(int i=1;i<=n;i++)
    {
        Lowcost[i]=Edge[1][i];
        U[i]=1;
    }
    U[1]=-1;
//    int count=1;
    for(int i=1;i<=n-1;i++)
    {
        int v=0,min=INF;
        for(int j=1;j<=n;j++)
        {
            if(U[j]!=-1&&Lowcost[j]<min)
            {
                v=j;
                min=Lowcost[j];
            }
        }
        if(v==0) return;//表明图不连通，直接退出算法
//      TE[count]=Trituple(U(v),v,Lowcost[v]);

        ///update maxcost
        int u=U[v];
        maxcost[u][v]=Lowcost[v];
        maxcost[v][u]=maxcost[u][v];
        for(int s=1;s<=n;s++)
        {
            if(U[s]==-1)
            {
                maxcost[s][v]=max(maxcost[u][v],maxcost[s][u]);
                maxcost[v][s]=maxcost[s][v];
            }
        }

//        count++;
        U[v]=-1;
        Lowcost[v]=0;
        //由于集合变化（v移到U集合），以v为左端点重新比较更新Lowcost和U-V集合中的U值
        for(int j=1;j<=n;j++)
        {
            if(U[j]!=-1&&Edge[v][j]<Lowcost[j])
            {
                U[j]=v;
                Lowcost[j]=Edge[v][j];
            }
        }
    }

}


int main(void) {

    int n=0,e=0;
    scanf("%d%d",&n,&e);
    g.numEdge=e;
    g.numVertax=n;
    createGraph(g);

    Prim(g.Edge,n);

    int t;
    scanf("%d",&t);
    while(t--)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        printf("%d\n",maxcost[a][b]);

    }

    return 0;
}

```

***=>可以通过这个最大边进而找次小支撑树***：

向最小生成树中加入剩余边的`max(u,v)`之后就会形成一个环，我们将环中的次长边[即MST路径(u,v)的最大边]删去，得到的依然是G的生成树。依次进行上述操作，并更新生成树的最小值。答案即为次小生成树的边权和。

`SecondMST = min(MST + w(u, v) - Max(u, v))  ((u, v) not belong to MST)。`

#### Kruskal算法:逐边加入

> 逐边加入权值最小的边T且不产生环=>直至仅剩一个连通分量

* 并查集: 连通分量=>集合，连通分量中顶点=>集合元素
  * [回顾：并查集](####并查集)

```c++
class Trituple
{
public:
    Trituple(int h,int t,int c):head(h),tail(t),cost(c){}
    int head;
    int tail;
    int cost;
}

void Sort(Trituple E[],int n)
{
    int flag=1;
    while(flag)
    {
        flag=0;
        for(int i=0;i<n-1;i++)
        {
            if(E[i].cost>E[i+1].cost)
            {
                Trituple temp=E[i];
                E[i]=E[i+1];
                E[i+1]=temp;
                flag=1;
            }
        }
    }
}

//E[]保存图中所有边（不用建图）
//res最小支撑树各边权值之和
void Kruskal(Trituple E[],int n,int res)
{
    //1.初始化：将每个顶点作为一个连通分量（集合）
    for(int i=1;i<=n;i++) MakeSet(i);
    //1.初始化：MST中已加入边的计数器count;j代表E[]中为未入TE的最小权边的index
    //1.初始化：对权值排序
    
    int j=0,count=1;
    //2.step:每次加入权值最小的边T且不产生环=>直到count=n
    while(count<n)
    {
        //未入TE的最小权边
        Trituple temp=E[j];
        ///集合中还没有（n-1）条边就找不到最小权边了=>无最小支撑树
        if(temp.head==0&&temp.tail==0) {flag=0;return;}
        //若该权边的两个端点不在一个连通分量=>不会产生环
        if(Find(temp.head)!=Find(temp.tail))
        {
            //该边是最小连通分量中边
            //更新TE,res并将两端点连通分量合一
            TE[count++]=temp;
            res+=temp.cost;
            Union(temp.head,temp.tail);
        }
        //observe下一条顺序权边
        j++;
    }
    
}
```

##### ex:最小支撑树边权之和

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 1510;
const int INF = 0x3f3f3f3f;

class Trituple
{
public:
    Trituple(int h,int t,int c):head(h),tail(t),cost(c){}
    Trituple():head(0),tail(0),cost(0){}
    int head;
    int tail;
    int cost;
};


int Father[N];
long long res;
Trituple TE[N];
int flag=1;

void MakeSet(int x)
{
    Father[x]=0;
}

int Find(int x)
{
    if(Father[x]==0) return x;
    Father[x]=Find(Father[x]);
    return Father[x];
}

void Union(int x,int y)
{
    Father[Find(x)]=Find(y);
}

void Sort(Trituple E[],int n)
{
    int flag=1;
    while(flag)
    {
        flag=0;
        for(int i=0;i<n-1;i++)
        {
            if(E[i].cost>E[i+1].cost)
            {
                Trituple temp=E[i];
                E[i]=E[i+1];
                E[i+1]=temp;
                flag=1;
            }
        }
    }
}

//E[]保存图中所有边（不用建图）[E已经对边按照权值递增排序]
void Kruskal(Trituple (&E)[N],int n)
{
    //1.初始化：将每个顶点作为一个连通分量（集合）
    for(int i=1;i<=n;i++) MakeSet(i);
    //1.初始化：MST中已加入边的计数器count;j代表E[]中为未入TE的最小权边的index
    int j=0,count=1;
    //2.step:每次加入权值最小的边T且不产生环=>直到count=n
    while(count<n)
    {
        //未入TE的最小权边
        Trituple temp=E[j];
        //集合中还没有（n-1）条边就找不到最小权边了=>无最小支撑树
        if(temp.head==0&&temp.tail==0) {flag=0;return;}
        //若该权边的两个端点不在一个连通分量=>不会产生环
        if(Find(temp.head)!=Find(temp.tail))
        {
            //该边是最小连通分量中边
            //更新TE,res并将两端点连通分量合一
            TE[count++]=temp;
            res+=temp.cost;
            Union(temp.head,temp.tail);
        }
        //observe下一条顺序权边
        j++;
    }

}


int main(void) {

    int n=0,e=0;
    while(scanf("%d%d",&n,&e)!=EOF)
    {
        Trituple E[N];
        for(int i=0;i<e;i++)
        {
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);
            E[i]=Trituple(a,b,c);
        }
        //1.初始化：对边按照权值递增排序
        Sort(E,e);
        res=0;flag=1;
        memset(Father,0,sizeof(Father));
        Kruskal(E,n);
        if(flag) printf("%lld\n",res);
        else printf("There is no minimum spanning tree.\n");
    }
    return 0;
}

```



| 算法    | 时间复杂度 | 适用         |
| ------- | ---------- | ------------ |
| Prim    | O(n^2^)    | 稠密图       |
| Kruskal | O(eloge)   | 稀疏图(点少) |

### 可及性与传递闭包问题

> 描述有向图顶点间可及关系的n阶方阵R，被称为可及矩阵, 若顶点vi 到vj 可及，则`R[i][j]=1`，否则`R[i][j]=0`.

#### Floyd-WarShall算法

同Floyd算法一样，做三层循环，不过循环内更新`R[i][j]=`

```c++
void Warshall(int Edge[][],int n)
{
    //1.初始化R[i][j]
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {当 Reach[i]计算结束时，清空used，以便计算其它顶点的Reach集合}

            if (i==j||Edge[i][j]!=INF) R[i][j]=1;//一定可及
            else R[i][j]=0;
        }
    //2.三层循环更新R[][]
    ////R[i][j]=1<=>i，j原本可及或i、j中有一点k使i，k可及且k，j可及
    for(int k=1;k<=n;k++)
        for(int k=1;k<=n;k++)
            for(int k=1;k<=n;k++)
                R[i][j]=R[i][j]||(R[i][k]&&R[k][j]);
}
```

> O(n^3^)

#### Tranclo算法

- [ ] ==数组里套数组才行？？==

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211121162604308.png" alt="image-20211121162604308" style="zoom:67%;" />

*可及i的点=i点本身+可及j的点*>由后继推前继：**拓扑逆序**

* 引入两个数组：

  * Reach[]:

  <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211121163208608.png" alt="image-20211121163208608" style="zoom:50%;" /><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211121163236245.png" alt="image-20211121163236245" style="zoom:50%;" />

  * used[]:记录顶点是否已经加入Reach集合
    * used[j] = 1 表示 j 已经加入 Reach[i]；used[j] = 0 表示 j 还没有加入 Reach[i]
    * 当 Reach[i]计算结束时，清空used，以便计算其它顶点的Reach集合

```c++
//邻接表方式存储，且表中顶点已拓扑排序
void Tranclo(Vertax Head[],int n)
{
    //1.初始化：used数组
    for(int i=0;i<n;i++) used[i]=0;
    for(int i=n-1;i>=0;i--)
    {
        
    }
}
```

>O(n^2.5^)

### 强连通分量

> **如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通strongly connected)。有向图的极大强连通子图，称为强连通分量(strongly connected components)**

* 引入两个辅助数组
  * markedlist[i]:标记顶点i是否已在某连通分量中
  * scList[t]:存放第t个连通分量中的顶点*（结果）*
    * t记录连通分量个数，作为index

```c++
//求图中所有强连通分量
void All_componet(int Edge[][],int n)
{
    //1.初始化：markedlist[]都为0
    for(int i=1;i<=n;i++) markedlist[i]=0;
    //1.初始化：连通分量个数=0
    t=0;
    
    //2.计算图的可及矩阵，得到R[][]
    Warshell(Edge,n);
    
    //3.n次循环
    for(int i=1;i<=n;i++)
    {
        //处理新的连通分量
        if(markedlist[i]==0)
        {
            t++;
            markedlist[i]=1;
            scList[t]=i;
            
        }
    }
}
```

## 排序

### 平方阶排序

#### [==直接插入==]

* 将一个记录插入到已排好序的有序表中，从而得到 一个新的、记录数增1的有序表=>使前1、2、3...个元素有序

```c++
//l , r 分别为文件记录序列的左端和右端下标[l,r]
void InsertSort(int R[],int l,int r)
{
    for(int j=l+1;j<=r;j++)
    {
        int i=j-1;//i扫描前(j-1)个有序元素
        int e=R[j];
        while(i>0&&R[i]>e)
        {
            R[i+1]=R[i];
            i--;
        }
        R[i+1]=e;
    }
}
```

#### 希尔排序

==不稳定==

* 把记录按下标的一定增量d分组,对每组使用直接插入法排序
* 将增量值d减小，将文件再分成多个组，每组使用直接插入法排序,以此往复
* 随着增量值逐渐减少，每组包含的元素越来越多， 当增量值减少到1时，整个文件恰被分成一组， 算法终止

>* 增量的取法
>增量可选如下的任意正整数序列：n > d1  > d2  > … > dt  > 1
>1. d1=floor(n/2), d2= floor(d1/2), 直到dt  = 1 .
>2. dj+1  = floor(dj /3)+1 .
>2. 取奇数
>2. 各增量互质
```c++
//增量取第一种取法:n要排序数组部分[1,n]长度
void ShellSort(int R[],int n)
{
    int d=n/2;
    while(d>0)
    {
        for(int j=d+1;j<=n;j++)
        {
            int i=j-d;
            int e=R[j];
            while(i>0&&R[i]>e)
            {
                R[i+d]=R[i];
                i=i-d;
            }
            R[i+d]=e;
        }
        d=d/2;
    }
}
```

#### 冒泡排序

```c++
void BSort(int R[],int n)
{
    int Bound=n;//每趟冒泡关键词比较的终止位置
    while(Bound)
    {
        int t=0;
        for(int j=1;j<Bound;j++)
        {
            if(R[j]>R[j+1])
            {
                t=j;
                int temp=R[j];
                R[j]=R[j+1];
                R[j+1]=temp;
            }
        }
        Bount=t;
    }
}
```

#### 直接选择排序

* 在未排序的序列中选最小的元素，并和首元素交换
* 在剩下的未排序的序列中再选出最小的元素与序列 中第二个元素交换
* 以此类推，最后形成递增的已排序序列

```c++
void SelectionSort(int R[]，int n)
{
    for(int i=1;i<n;i++)//i表示要处理的子数组的起点
    {
        int min_id=i;
        for(int j=i+1;j<=n;j++)
        {
            if(R[j]<R[min]) min=j;
        }
        int temp=R[i];
        R[i]=R[min];
        R[min]=temp;
    }
}
```

### 堆排序

```c++
//重建堆
///f是堆的根结点在数组R中下标, e使堆最后一个元素在R中下标
void Restore(int R[],int f,int e)
{
    int j=f;
    while(j<=e/2)
    {
        int m;
        if(2*j+1<=e && R[2*j]<R[2*j+1]) m=2*j+1;
        else m=2*j;
        if(R[m]>R[j])
        {
            swap(R[m],R[j]);
            j=m;
        }else return;
    }
}

//初始建堆
void HeapSort(int R[],int n)
{
    for(int i=n/2;i>0;i--)
    {
        Restore(R,i,n);
    }
    for(int i=n;i>=2;i--)
    {
        swap(R[1],R[i]);
        Restore(R,1,i-1);
    }
}

//上浮操作
void MoveUp(int R[],int n,int i)
{
    while(i>1&&R[i]>R[i/2])
    {
        temp=R[i];
        R[i]=R[i/2];
        R[i/2]=temp;
        i/=2;
    }
}

//下沉操作
void MoveDown(int R[],int n,int i)
{
    Restore(R,i,n);
}

//队尾插入
void HeapInsert(int R[],int &n,int x)
{
    R[++n]=x;
    MoveUp(R,n,n);
}

//删除R[i]
int HeapDelete(int R[],int &n,int i)
{
    int t=R[i];
    R[i]=R[n--];
    if(R[i]>t) Moveup(R,n,i);
    else MoveDown(R,n,i);
    return t;
}
```

### 快速排序

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int MAX=1010;

int L;
int R[MAX];

int Partition(int R[],int m,int n)
{
    int i=m;
    int j=n+1;
    int e=R[m];//基准元素

    while(i<j)
    {
        i++;
        while(R[i]<=e&&i<=n) i++;
        j--;
        while(R[j]>e) j--;
        if(i<j) swap(R[i],R[j]);
    }
    swap(R[m],R[j]);
    return j;
}

void QuickSort(int R[],int m,int n)
{
    if(m<n)
    {
        int j=Partition(R,m,n);
        for(int i=1;i<=L;i++) printf("%d ",R[i]);
        printf("\n");
        QuickSort(R,m,j-1);//j-left
        QuickSort(R,j+1,n);//j-right
    }
}


int main() {
    scanf("%d",&L);
    for(int i=1;i<=L;i++) scanf("%d",&R[i]);
    QuickSort(R,1,L);
    for(int i=1;i<=L;i++) printf("%d ",R[i]);
    printf("\n");
    return 0;
}

```



# 上机题型

## 树

### 二叉树的路径 

[总结](https://blog.csdn.net/walker_xingruiguo/article/details/118422450)

1. 建树

* [先根序列创建二叉树](#####创建二叉树)

2. 先根遍历

* 过程中遇到叶节点即保存了一条从根到叶节点的路径
* 再对路径数组做 *最大子数组和*   、 *kmp*等[数组的算法](待补充)

> 二叉树路径和

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

#define INF 0x7ffffff

const int N =110;//对深度即路径最大值设置
int MaxPath[N];
int MaxPathLength=INF;//初始化最大路径的长度为正无穷
int maxl;

class Node
{
public:
    Node():data(0),left(NULL),right(NULL){};
    Node(int d):data(d),left(NULL),right(NULL){};
    int data;
    Node *left, *right;
};



Node * CreateBinTree()
{
    int x;
    scanf("%d",&x);
    if(x==0) return NULL;
    Node * t = new Node(x);
    t->left=CreateBinTree();
    t->right=CreateBinTree();
    return t;
}



void MaxLength(Node * t,int path[],int id)
{
    if(t==NULL) return;
    path[id]=t->data;

    if(t->left==NULL&&t->right==NULL)//叶节点，路径完，找到最大path子数组和
    {
        //求最大子数组和（带end和start）
        int f=path[0],maxsum=path[0];
        int start=0,end=0,maxstart,maxend;
        for(int i=1;i<=id;i++)
        {
            if(f>0) f=f+path[i];
            else
            {
                f=path[i];
                start=i;
            }
            end=i;
            if(f>maxsum||((maxsum==f)&&(end-start)<(maxend-maxstart)))
            {
                maxsum=f;
                maxstart=start;
                maxend=end;
            }
        }
        //比较最大path
        if(maxsum>maxl||((maxsum==maxl)&&(maxend-maxstart+1)<MaxPathLength))
        {
            maxl=maxsum;
            for(int i=0;i<MaxPathLength;i++) MaxPath[i]=0;//可要可不要
            for(int i=0;i<maxend-maxstart+1;i++) MaxPath[i]=path[maxstart+i];//更新路径
            MaxPathLength=maxend-maxstart+1;//别忘记更新最大路径节点数
        }
    }
    MaxLength(t->left,path,id+1);//左
    MaxLength(t->right,path,id+1);//右
}


int main(void)
{
    Node * t=NULL;
    t=CreateBinTree();

    //将第一个根结点作为最大路径的初始值
    maxl=t->data;//不然小于零的都不可
    MaxPath[0]=t->data;
    MaxPathLength=1;

    int path[N]={0};
    MaxLength(t,path,0);

    printf("%d\n",maxl);
    for(int i;MaxPath[i]!=0;i++) printf("%d ",MaxPath[i]);

    return 0;
}
```

### 哈夫曼编码解码

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;


int WPL=0;
class hNode
{
public:
    hNode():data(0),left(NULL),right(NULL){};
    hNode(char d):data(d),weight(1),left(NULL),right(NULL){};
    hNode(int w,hNode * l,hNode * r):data(0),weight(w),left(l),right(r){};
    char data;
    int weight; //结点权值
    hNode *left, *right;
};

hNode **H = new hNode *[5010];
void init()
{
    for(int i=0; i<5010; i++)
    {
        H[i] = new hNode();
    }
}

//注意H中数据是从1到n的，不是0到n-1
hNode * Huffman(hNode * H[], int n)
{
	for(int i=1;i<=n;i++)
    {
        H[i]->left=NULL;
        H[i]->right=NULL;
    }
    for(int i=1;i<=n-1;i++)
    {
        hNode * t=new hNode(H[i]->weight+H[i+1]->weight,H[i],H[i+1]);
        WPL += t->weight;
        int j=i+2;
        while(j<=n&&H[j]->weight<=t->weight)
        {
            H[j-1]=H[j];
            j++;
        }
        H[j-1]=t;
        if(i==n-1) return t;
    }
}

void preorder(hNode * t){
    if(t==NULL) return;

    printf("%c\t%d\n", t->data, t->weight);
    preorder(t->left);
    preorder(t->right);
}

void Encode(hNode * t,char c,int index,int lr,int code[])
{
    if(t==NULL) return;


    if(index>=0) code[index]=lr;
    if(t->data==c)
    {
        for(int i=0;i<=index;i++) printf("%d",code[i]);
        return;
    }
    Encode(t->left,c,index+1,0,code);
    Encode(t->right,c,index+1,1,code);
}

int main(void)
{
    init();
    int t[123]={0};
    char temp;
    int id=1;
    int length=0;
    //未排序H数组
    scanf("%c",&temp);
    while(temp!='\n')
    {
        if(t[(int)temp]==0)
        {
            H[id]->data=temp;

            H[id]->weight=1;
            id++;
            t[(int)temp]=id-1;//不是0就是H数组位置
        }else
        {
            H[t[(int)temp]]->weight++;
        }
        scanf("%c",&temp);
        length++;
    }


    //H[1:id-1]数组稳定排序
    for(int i=1;i<=id-1;i++)
        for(int j=1;j<=id-1-i;j++)
        if(H[j]->weight>H[j+1]->weight)
        {
            hNode * temp=H[j];
            H[j]=H[j+1];
            H[j+1]=temp;
        }

    int a[5010]={0};
    for(int i=1;i<=id-1;i++)
    {
        a[i]=H[i]->data;
    }

    //构造HUFFMAN树
    hNode * root;
    root=Huffman(H,id-1);

//    preorder(root);
    printf("%d ",length);
    printf("%d\n",(int)ceil((float)WPL/8));

    for(int i=1;i<=id-1;i++)
    {
        int code[5010]={0};
        printf("%c:",a[i]);
        Encode(root,a[i],-1,0,code);
        printf("\n");
    }

    string str;
    char res[5010];
    bool flag=true;
    int idx=0;
    while(cin>>str)
    {
        hNode * r=root;
        for(int i=0;i<id-1&&str[i]!='\0';i++)
        {
            if(str[i]=='0') r=r->left;
            else r=r->right;
            if(r->data!=0&&str[i+1]=='\0') {res[idx++]=r->data;break;}
            if(r->data==0&&str[i+1]=='\0') {flag=false;break;}
            if(r==NULL) {flag=false;break;}
            if(r->data!=0) {res[idx++]=r->data;r=root;}

        }
        if(flag) printf("%s",res);
        else printf("INVALID");
        printf("\n");
    }
    return 0;

}

```

### LCA

## 图

### corner case dijkstra

> **最少点** **字典序 ** 最短路径
>
> 即对于多条最短路径（`(dist[v]+p->cost)==dist[p->VerAdj])`相等情况什么时候更新）选择哪条
>
> =>`if((S[p->VerAdj]==0&&((dist[v]+p->cost)<dist[p->VerAdj]))||(((dist[v]+p->cost)==dist[p->VerAdj])&&Cornercase(v,p->VerAdj,path)))`

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 20010;
const int INF = 0x3f3f3f3f;

class Edge
{
public:
    Edge():VerAdj(0),cost(0),Link(NULL){}
    Edge(int vid,int w):VerAdj(vid),cost(w),Link(NULL){}
    int VerAdj;//邻接顶点在顶点表中对应的index
    int cost;
    Edge * Link;//边链表的头指针
};
class Vertax
{
public:
    Vertax():Vername(0),adjacent(NULL){}
    int Vername;//顶点名称
    Edge * adjacent;//边链表的头指针
};
class LGraph
{
public:
    LGraph(int v,int e):numVertax(v),numEdge(e){}
    int numVertax;
    int numEdge;
    Vertax Head[N];
};

void createGraph(LGraph & g)
{
    int a,b,c;
    //顶点名称初始化
    for(int i=0;i<g.numVertax;i++)
    {
        g.Head[i].Vername=i;
        g.Head[i].adjacent=NULL;
    }
    for(int i=0;i<g.numEdge;i++)
    {

        scanf("%d%d%d",&a,&b,&c);
        int v1=a,v2=b;//对应index
        //头插法
        Edge * q=new Edge(v2,c);
        Edge * p=g.Head[v1].adjacent;
        if(p!=NULL)
        {
            //若不需排序，直接尾插，不然会超时
            q->Link=g.Head[v1].adjacent;
            g.Head[v1].adjacent=q;
        }else
        {
            g.Head[v1].adjacent=q;
        }

    }
}

bool Cornercase(int v1,int v2,int path[])
{
    //比较路径长度
    int cnt1=0,cnt2=0;
    int vv1=v1,vv2=path[v2];

    if(path[v1]==-1) return false;
    while(path[v1]!=0)
    {
        if(path[v1]==-1) return false;
        cnt1++;
        v1=path[v1];
    }
    if(path[v2]==-1) return false;
    while(path[v2]!=0)
    {
        if(path[v2]==-1) return false;
        cnt2++;
        v2=path[v2];
    }
    if(cnt1+1<cnt2) return true;
    if(cnt1+1>cnt2) return false;//应该不存在
    //比较字典序
    while(path[vv1]!=path[vv2])
    {
        vv1=path[vv1];
        vv2=path[vv2];

    }
    if(vv1<vv2) return true;
    return false;
}

void Dijkstra(Vertax Head[],int n,int s,int dist[],int path[])
{
    int * S=new int[n]();
    for(int i=0;i<n;i++){dist[i]=INF;path[i]=-1;}
    dist[s]=0;
    S[s]=1;
    for(Edge * p=Head[s].adjacent;p!=NULL;p=p->Link)
    {
            dist[p->VerAdj]=dist[s]+p->cost;
            path[p->VerAdj]=s;
    }

    for(int i=0;i<n-1;i++)
    {
        int min=INF;
        int v=0;
        for(int j=0;j<n;j++)
            if(S[j]==0&&dist[j]<min)
                {min=dist[j];v=j;}
        //注意，当为选择到最短路径时（图不连通时）=>直接返回！不然会超时
        if(v==0) return;
        S[v]=1;
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->Link)
        {
            //
            if((S[p->VerAdj]==0&&((dist[v]+p->cost)<dist[p->VerAdj]))||(((dist[v]+p->cost)==dist[p->VerAdj])&&Cornercase(v,p->VerAdj,path)))
            {
                dist[p->VerAdj]=dist[v]+p->cost;
                path[p->VerAdj]=v;

            }
        }
    }
}

void printPath(int path[],int n)
{
    int * tmp=new int[n]();
    int idx=0;
    for(int i=1;i<n;i++)
    {
        idx=0;
        tmp[idx++]=i;
        int j=i;
        if(path[j]<0) continue;
        while(path[j]!=0)
        {
            if(path[j]<0) continue;
            tmp[idx++]=path[j];
            j=path[j];

        }
        printf("0");
        for(int i=idx-1;i>=0;i--) {printf("->%d",tmp[i]);tmp[i]=0;}
        printf("\n");


    }
}

int main() {
    int n=0,e=0;
    scanf("%d %d",&n,&e);
    LGraph g(n,e);
    createGraph(g);
    int * dist=new int[n]();
    int * path=new int[n]();
    Dijkstra(g.Head,g.numVertax,0,dist,path);
    printPath(path,n);
    return 0;


}

```

### Floyd最短路经过点记数

![image-20211120125101068](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20211120125101068.png)

> 1. 最短路径数?
>
> **path数组**不再保存路径，改成保存<i,j>最短路径数，path数组更新关键：
>
> * `A[i][k]+A[k][j]<A[i][j]`更新：`path[i][j] = path[i][k]*path[k][j];`
> * `A[i][k]+A[k][j]=A[i][j]`更新：`path[i][j] += path[i][k]*path[k][j];`
>   * 若顶点i到顶点k有x条路径，点k到点j有y条路径，则k经过i到达j的路径有x*y条
>
> 2. <i,j>经过k的最短路径？
>
> floyd保存结果至path和A后，再做三层循环，res[k]:
>
> * ==A[i,j]是否经过k==？`A[i][k]+A[k][j]==A[i][j]`=>i,j间最短路径经过k
> * A[i,j]若经过k，有几条经过k？`path[i][k]*path[k][j]`=>i,j间最短路径经过k的条数

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 110;
const int INF = 0x3f3f3f3f;


class MGraph
{
public:
    MGraph(int v,int e):numVertax(v),numEdge(e){}
    int numVertax;
    int numEdge;
    int Edge[N][N];
};

void createGraph(MGraph & g)
{
    int a,b,c;
    //顶点初始化
    for(int i=1;i<=g.numVertax;i++)
        for(int j=1;j<=g.numVertax;j++)
            g.Edge[i][j]=INF;

    for(int i=0;i<g.numEdge;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        g.Edge[a][b]=c;
        g.Edge[b][a]=c;
    }
}


void Floyd(int Edge[N][N],int n,int (&A)[N][N],long long (&path)[N][N],long double (&res)[N])
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            A[i][j]=Edge[i][j];
            A[j][i]=Edge[j][i];
            if(A[i][j]<INF) path[i][j]=1;
            else path[i][j]=0;
        }
    for(int k=1;k<=n;k++)
    {
       for(int i=1;i<=n;i++)
       {
         for(int j=1;j<=n;j++)
            {
             	//关键操作1：更新i，j最短路径条数path[]
             	//情况1：有更短路径=>替换最短路径：path[i][k]*path[k][j]
                if(A[i][k]+A[k][j]<A[i][j])
                {
                    A[i][j]=A[i][k]+A[k][j];
                    path[i][j]=path[i][k]*path[k][j];
                //情况2：最短路径长度相同=>增加最短路径条数：+path[i][k]*path[k][j]
                }else if(A[i][k]+A[k][j]==A[i][j])
                {
                    path[i][j]+=path[i][k]*path[k][j];
                }

            }
       }

    }
    //关键操作2：哪些最短路径经过k?
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                //当i,j,k互不相等时，若i,k间最短距离+k,j间最短距离=i,j间最短距离=>存在经过k的最短路径
                if(i!=j&&k!=i&&k!=j&&A[i][k]+A[k][j]==A[i][j]) 
                    //经过k的最短路径条数:path[i][k]*path[k][j]
                    res[k]+=(long double)A[i][j]*(long double)path[i][k]*path[k][j]/path[i][j];

}

int main() {
    int n=0,e=0;
    scanf("%d %d",&n,&e);
    MGraph g(n,e);
    createGraph(g);
    int A[N][N];
    long long path[N][N];
    long double res[N];
    Floyd(g.Edge,g.numVertax,A,path,res);
    for(int i=1;i<=n;i++) printf("%.3Lf\n",res[i]);

    return 0;


}
```

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 20010;
const int INF = 0x3f3f3f3f;
int flag=-1;

class Edge
{
public:
    Edge():VerAdj(0),cost(0),Link(NULL){}
    Edge(int vid,int w):VerAdj(vid),cost(w),Link(NULL){}
    int VerAdj;//邻接顶点在顶点表中对应的index
    int cost;
    Edge * Link;//边链表的头指针
};
class Vertax
{
public:
    Vertax():Vername(0),adjacent(NULL){}
    int Vername;//顶点名称
    Edge * adjacent;//边链表的头指针
};
class LGraph
{
public:
    LGraph(int v,int e):numVertax(v),numEdge(e){}
    int numVertax;
    int numEdge;
    Vertax Head[N];
};

void createGraph(LGraph & g)
{
    int a,b,c;
    //顶点名称初始化
    for(int i=0;i<g.numVertax;i++)
    {
        g.Head[i].Vername=i+1;
        g.Head[i].adjacent=NULL;
    }
    for(int i=0;i<g.numEdge;i++)
    {

        scanf("%d%d%d",&a,&b,&c);
        int v1=a-1,v2=b-1;//对应index
        //头插法
        Edge * q1=new Edge(v2,c);
        Edge * q2=new Edge(v1,c);
        Edge * p1=g.Head[v1].adjacent;
        Edge * p2=g.Head[v2].adjacent;
        if(p1!=NULL)
        {
            //若不需排序，直接尾插，不然会超时
            q1->Link=g.Head[v1].adjacent;
            g.Head[v1].adjacent=q1;
        }else
        {
            g.Head[v1].adjacent=q1;
        }
        if(p2!=NULL)
        {
            //若不需排序，直接尾插，不然会超时
            q2->Link=g.Head[v2].adjacent;
            g.Head[v2].adjacent=q2;
        }else
        {
            g.Head[v2].adjacent=q2;
        }
    }
}


void Dijkstra(Vertax Head[],int n,int s,int t,int dist[],int path[])
{
    int * S=new int[n]();
    for(int i=0;i<n;i++){dist[i]=INF;path[i]=-1;}
    dist[s]=0;
    S[s]=1;
    for(Edge * p=Head[s].adjacent;p!=NULL;p=p->Link)
    {
            dist[p->VerAdj]=dist[s]+p->cost;
            path[p->VerAdj]=s;
    }

    for(int i=0;i<n-1;i++)
    {
        int min=INF;
        int v=0;
        for(int j=0;j<n;j++)
            if(S[j]==0&&dist[j]<min)
                {min=dist[j];v=j;}
        if(v==0) return;
        S[v]=1;
        for(Edge * p=Head[v].adjacent;p!=NULL;p=p->Link)
        {
            if(S[p->VerAdj]==0&&(dist[v]+p->cost<dist[p->VerAdj]))
            {
                dist[p->VerAdj]=dist[v]+p->cost;
                path[p->VerAdj]=v;

            }
        }
    }
    //加上轻轨
    int pls=0;
    scanf("%d",&pls);
    while(pls--)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        int v1=a-1,v2=b-1;//对应index
        if(dist[s,v1]+dist[v2,t]+c < dist[s,t])
        {
            flag=v1;
            dist[s,t]=dist[s,v1]+dist[v2,t]+c;
        }
        if(dist[s,v2]+dist[v1,t]+c<dist[s,t])
        {
            flag=v2;
            dist[s,t]=dist[s,v2]+dist[v1,t]+c;
        }
    }

}

void printPath(int path[],int n)
{
    int * tmp=new int[n]();
    int idx=0;
    for(int i=1;i<n;i++)
    {
        idx=0;
        tmp[idx++]=i;
        int j=i;
        if(path[j]<0) continue;
        while(path[j]!=0)
        {
            if(path[j]<0) continue;
            tmp[idx++]=path[j];
            j=path[j];

        }
        printf("0");
        for(int i=idx-1;i>=0;i--) {printf("->%d",tmp[i]);tmp[i]=0;}
        printf("\n");


    }
}

int main() {
    int n=0,s=0,t=0;
    while(scanf("%d %d %d",&n,&s,&t)!=EOF)
    {
        int e=0;
        scanf("%d",&e);
        LGraph g(n,e);
        createGraph(g);
        int * dist=new int[n]();
        int * path=new int[n]();
        s=s-1;t=t-1;//vername->id
        Dijkstra(g.Head,g.numVertax,s,t,dist,path);
        printf("%d\n",dist[s,t]);
        if(flag!=0) printf("%d\n",flag);
        else printf("no metro\n");
        return 0;
    }



}

```

# STL string

==**允许使用STL string，但不允许使用其中的find、insert、erase、substr、assign函数。**==

### scanf

```c++
char tmp[101];
scanf("%100s", tmp);
string a = tmp;
```

### size/length

```c++
str.length()
```

### 传参

```c++
//引用传参
bool Trans(string &str,string &str1);

//指针传参
int str_length(char *str)
{
    int i=0;
    while(*(str+i)!='\0'){
        /*Operation*/
        i++;
    }
}
```

#测试数据构造

## 构造随机数

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=50000;
int main()
{
       freopen("test_in.txt","w",stdout);
       // 这里的意思是生成一个以.txt结尾的文件，下面是文件的内容
       for(int i=0;i<N;i++)
        	cout<<rand()%N<<endl;//随机生成10000个数
       return 0;
}

#include <iostream>
using namespace std;

const int N=50000;

string rand_str(const int len)  /*参数为字符串的长度*/
{

    /*初始化*/
    string str;                 /*声明用来保存随机字符串的str*/
    char c;                     /*声明字符c，用来保存随机生成的字符*/
    int idx;                    /*用来循环的变量*/
    /*循环向字符串中添加随机生成的字符*/
    for(idx = 0;idx < len;idx ++)
    {
        /*rand()%26是取余，余数为0~25加上'a',就是字母a~z,详见asc码表*/
        c = 'a' + rand()%26;
        str.push_back(c);       /*push_back()是string类尾插函数。这里插入随机字符c*/
    }
    return str;                 /*返回生成的随机字符串*/
}

int main()
{
    freopen("test_in.txt","w",stdout);
    /*测试函数*/
    string str;                 /*声明字符串*/
    str = rand_str(N);         /*调用函数 输入字符串长度*/
    cout << str << endl;        /*输出字符串*/
    return 0;
}

```

## 测试

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
    ///提交记得删除！！
    freopen("test_in.txt","r",stdin);//设置 cin scanf 这些输入流都从 test.in中读取
    freopen("test_out.txt","w",stdout);//设置 cout printf 这些输出流都输出到 test.out里面去
    
//    int a[10000];
//    for(int i=0;i<1e4;i++) scanf("%d",&a[i]);
//    for(int i=0;i<1e4;i++) printf("%d\n",a[i]);
}
```

```C++

#include <iostream>
#include <string.h>
using namespace std;

class DLNode
{
public:
    DLNode():data(0),right(NULL),left(NULL){};
    DLNode(char d):data(d),right(NULL),left(NULL){};//可以简化申请新节点空间
    char data;
    DLNode * right;
    DLNode * left;
};


int main (void)
{
    ///提交记得删除！！
    freopen("test_in.txt","r",stdin);//设置 cin scanf 这些输入流都从 test.in中读取
    freopen("test_out.txt","w",stdout);//设置 cout printf 这些输出流都输出到 test.out里面去
   DLNode * head=new DLNode;
   DLNode * rear=new DLNode;
   head->right=rear;
   rear->left=head;
   DLNode * p=head;
   int k=0;//k为偶数即为插入状态，奇数为改写状态
   char temp;
   scanf("%c",&temp);
   while(temp!='\n')
   {
       switch(temp)
       {
       case 'k':if(p!=head) p=p->left;break;
       case 'z':if(p!=rear->left) p=p->right;break;
       case 'w':p=head;break;
       case 's':p=rear->left;break;
       case 'q':if(p!=head) {DLNode * q=p;p=p->left;q->left->right=q->right;q->right->left=q->left;delete q;}break;
       case 'm':k++;break;
       default:
            DLNode * s=new DLNode(temp);
            s->right=p->right;
            s->left=p;
            p->right->left=s;
            p->right=s;
            p=s;
            if(k%2!=0)
            {
                if(p!=rear->left)
                {
                    DLNode * q=p->right;
                    q->left->right=q->right;
                    q->right->left=q->left;
                    delete q;
                }
            }
            break;

       }
       scanf("%c",&temp);
   }
   p=head->right;
   while(p!=rear)
   {
       printf("%c",p->data);
       p=p->right;
   }
   return 0;
}
```



# Tips

## 头文件

```c++
#include <iostream>
#include <string.h>
#include<math.h>
using namespace std;

const int N = 20010;///
const int INF = 0x3f3f3f3f;
```



## 绝对值

```c++
std::abs()[1]
刘艺璇,陈红,刘宇涵,李翠平.联邦学习中的隐私保护技术[J].软件报,2022,33(03):10571092.DOI:10.13328/j.cnki.jos.006446.
```

## memset

```c++
#include <string.h>

```

## 结构体数组

```c++
hNode **H = new hNode *[5010];
void init()
{
    for(int i=0; i<5010; i++)
    {
        H[i] = new hNode();
    }
}
```

## 多组输入

```c++
//字符
scanf("%c",&temp);
while(temp!='\n')
{
    
    scanf("%c",&temp);
}
//字符串
while(cin>>str)
{
    
}
//int
while(scanf()!=EOF)
{
    
}
```

## 数组长度

```c++
//char
strlen(arr);
//int
while(a[i]) i++;//实际数组长度
sizeof(a)/sizeof(int);//定义数组长度
```

## 引用传参

```c++
int (&A)[N][N];
int (&a)[];
```

# Tips

## 段错误

* 占用大内存数组申请在栈里=>应放在堆里
* 数组越界访问，可能大于/小于=>应加条件判断
* 空指针->data=>条件判断
* 野指针

## clang++

## long long/long double

