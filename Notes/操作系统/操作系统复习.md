# 操作系统

## 进程、线程与作业

#### ==多道程序设计==

<font color="red">**单道程序设计的缺点**</font>：（1）处理器资源利用率低（2）设备资源利用率低（3）内存资源利用率低

<font color="red">**多道程序设计**</font>:根本目标是提高整个计算机系统的效率(吞吐量)

![img](D:\markdown projects\pic\image-20220721102852233.png)

增加同时运行程序的道数可以提高资源利用率，从而提高系统效率，但道数应与系统资源数量相当。道数过少：系统资源利用率低。道数过多：系统开销增大，程序响应速度下降。

<font color="red">**多道程序设计对于系统的资源利用率所带来的影响包括**</font>:（1）设备资源利用率提高（2）内存资源利用率提高（3）处理器资源利用率提高（4）自然地表达一个程序内在的并行性。

<font color="red">**多道程序设计的问题**</font>：（1）处理器资源管理问题（2）内存资源管理问题（3）设备资源管理问题

#### ==进程的引入==

<font color="red">**进程**</font>是具有一定独立功能的程序关于一个数据集合的一次运行活动（**动态性**）/可参与并发执行的程序（**并发性**）

> 进程 = 进程控制块（PCB） + 程序（代码 + 数据+ 堆栈）

<font color="red">**进程的状态**</font>：运行（run）态、就绪（ready）态、等待（wait）态

![image-20220721103511296](D:\markdown projects\pic\image-20220721103511296.png)

<font color="red">**进程转换**</font>

![image-20220721103537880](D:\markdown projects\pic\image-20220721103537880.png)

![image-20220721103550836](D:\markdown projects\pic\image-20220721103550836.png)

<font color="red">**进程控制块（PCB）**</font>是标志进程存在的数据结构，其中包含系统对**进程进行管理**所需要的全部信息。

> 进程块存放在系统空间中，只有操作系统才能对其进行存取，用户程序不能访问。**进程控制块属于操作系统空间，而程序则属于用户空间。**

进程的程序（代码和数据）被称为<font color="red">**进程映像**</font>

将**进程**的**物理实体**与支持进程运行的**物理环境**合称为<font color="red">**进程上下文**</font>

<font color="red">**系统开销**</font>一般是指运行操作系统程序、对系统进行管理所花费的时间和空间。

<font color="red">**进程的队列（对应三种状态）**</font>：

1. 就绪队列 一般一个系统一个
2. 等待队列 每个等待事件一个
3. 运行指示字（仅一个，非队列）： 每个CPU一个

![image-20220721104258796](D:\markdown projects\pic\image-20220721104258796.png)

<font color="red">**实现状态转换**</font>：

1. 更新/创建/撤销**PCB**，并将PCB加入相应队列

2. 出运行态：**保存其运行环境**（psw）=>保存到进程PCB

   进运行态：**恢复其运行环境**（PSW）=>由进程PCB恢复

3. 分配/回收**资源**

<font color="red">**进程的类型**</font>：系统进程（OS程序，用于系统管理）和用户进程（应用程序，用于用户服务）

> 系统进程属于操作系统的一部分，运行于管态，可以执行包括特权指令在内的所有机器指令。

<font color="red">**进程的特性**</font>：并发性、动态性、独立性、交互性、异步性、结构性。

<font color="red">**进程与程序的联系：**</font>

* 程序是进程的组成部分之一
* 一个进程存在的目的就是执行其所对应的程序

<font color="red">**进程与程序的差别：**</font>

* 程序是静态的，而进程是动态的

* 程序可以写在纸上或者在某种存储介质上长期保存，而进程具有生存周期，创建后存在，撤销后消亡。

* 一个程序可以对应多个进程，但一个进程只能对应一个程序。

#### ==线程与轻进程==

<font color="red">**线程**</font>：又称轻进程，是进程内的一个相对独立的执行流，程序执行流的最小单元

> **进程是资源的分配单位，线程是CPU的调度单位！**

<font color="red">**与进程相比，线程具有如下优点：**</font>

* 上下文切换速度快：地址空间不变，上下文只涉及其寄存器和用户栈
* 系统开销小 ：不需要切换包含程序代码、静态数据、动态堆在内的地址空间
* 通信容易：同一进程内的线程共享数据空间（地址空间）

> <img src="D:\markdown projects\pic\image-20220819153455521.png" alt="image-20220819153455521" style="zoom:50%;" />

<font color="red">**线程控制块（TCB）**</font>是标志线程存在的数据结构，其中包含系统对线程进行管理所需要的全部信息。（核心级线程TCB属于操作系统空间，用户级线程TCB属于用户进程空间）

<font color="red">**线程的实现**</font>：**用户级别线程、核心级别线程、混合线程 **

**用户级别线程**：“从用户视角实现/能看到的线程”

![img](D:\markdown projects\pic\clip_image002.jpg)

* 基于库函数**（目态）实现**，系统不可见。
* 线程创建、撤销、状态转换在**目态**完成。
* TCB在用户空间，每个进程一个系统栈

> 优点：（1）不依赖于操作系统，调度灵活（2）同一进程中多线程切换速度快（不需中断进入操作系统）
>
> 缺点：（1）同一进程中多个线程不能真正并行（2）一个进程进入系统受阻，进程中其它线程不能执行

**核心级别线程**：“从操作系统内核视角看能看到的线程”

* 基于系统调用**（核心态）实现**。
* 基于系统调用，创建、撤销、状态转换均由操作系统完成。

> 优点：（1）同一进程内多个线程可以并行执行 （2）一线程进入核心等待，其它线程仍可执行
>
> 缺点：（1）系统开销大，同一进程内多线程切换速度慢 （2）调度算法不能灵活控制

***核心级线程才是处理机分配的单位！***

**混合线程：**

![img](D:\markdown projects\pic\clip_image004.jpg)

> 引入*轻进程*(Lightweight Process)—库函数实现；对用户可见，对操作系统也可见

* 映射关系(绑定)

  * 进程→轻进程：1→N(*N>=1*)

  * 用户级别线程→轻进程：n→N（n>=N）
  * 核心级别线程→轻进程：1→1

* 有与轻进程动态绑定的用户级别线程才能能够与核心通信

#### ==作业==

用户要求计算机系统为其完成的计算任务的集合称为<font color="red">**作业**</font>（job）

作业中的一个相对独立的处理步骤称为一个<font color="red">**作业步**</font>。作业步之间具有顺序或并发关系。一个作业步通常可以由一个进程来完成，作业与进程之间具有一对多的关系。

<font color="red">**作业控制块**</font>是标志作业存在的数据结构，其中包含系统对作业进行管理所需要的全部信息。

> 三个活动体：作业、进程、线程
>
> * 作业进入内存后变为进程
> * 一个作业通常与多个进程相对应

## 中断与处理器调度

#### ==中断==

在程序运行过程中出现某种紧急事件，必须中止当前正在运行的程序，转去处理此事件，然后再恢复原来运行的程序，这个过程称为<font color="red">**中断**</font>。

![image-20220721105642113](D:\markdown projects\pic\image-20220721105642113.png)

> * **中断**是让操作系统内核夺回CPU使用权的**唯一途径**
>   * 如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序，也就不存在并发
> * 操作系统是中断驱动的

中断装置（硬件部分：发现并响应中断）和中断处理程序（软件部分：处理中断）统称为<font color="red">**中断系统**</font>

<font color="red">**中断响应过程**</font>：（1）识别中断源 （2）保存现场（3）引出中断处理程序

> 1. **识别中断源**
>    * 当多个中断源同时存在时，由中断装置（硬件）选择优先级别最高的中断源
> 2. **保存现场**
>    * 将正在运行**进程的** ***用户栈**中的程序状态(PSW，保存运行环境)和指令计数器(PC)*压入**系统栈**
> 3. **引出中断处理程序**
>    * 将与中断事件对应的**中断向量(PSW',PC')**从中断向量表[内存]中取出
>    * 将此中断向量送入*程序状态字(运行环境)和[指令计数器](记录CPU即将要取出并执行的指令)*（无需压栈）中后便可开始执行中断处理程序
>      * 中断向量中PC’指向中断处理程序的入口地址
>      * 发生中断嵌套需要将正在执行中断处理程序的中断向量送入系统栈

<font color="red">**中断处理过程**</font>：根据中断码进一步分析中断源，进行相应的处理，最后根据情况决定是否需要切换进程

![中断响应和中断处理](D:\markdown projects\pic\image-20220721105849480.png)

引起中断的事件称为<font color='red'>**中断源**</font>。用于保存与中断事件*相关信息*的寄存器称为**<font color='red'>中断寄存器</font>**。中断寄存器中的内容称为**<font color='red'>中断字</font>**。

中断可以分为两大类：**强迫性中断**（*运行程序不期望的*）和**自愿性中断**（*运行程序主动的：访管指令 or系统调用*）。

因为对同类事件的处理方法是相同的，所以不是每个中断源都有一个中断处理程序，每类中断事件有一个中断处理程序，故存在一个**<font color='red'>中断向量表</font>**。

> * 8086存储于主存最底部（256类）——存放位置由硬件规定
>
> * 内容由OS在系统初始化时设置
>
> ![image-20220721105941519](D:\markdown projects\pic\image-20220721105941519.png)

每个中断处理程序有一个**入口地址（PC）及其运行环境（PSW）**，PSW和PC被称为**<font color='red'>中断向量</font>**。

系统在核心态处理一个中断事件的过程中又响应了更高级别的中断，则称发生**<font color='red'>中断嵌套</font>**。

> > 由于中断发送时，被中断程序的程序状态字和指令计数器的值是由硬件中断装置压入系统栈中的，因而**系统栈区的位置实际上是由硬件确定的**。
>
> * 现场保存与现场恢复：
>
>   * 中断嵌套中，新的中断发生时需要*保存被中断程序（旧的中断处理程序）的现场信息*，新的中断处理完成后，需要*恢复被中断程序（旧的中断处理程序）的现场*（压入系统栈，pop系统栈）
>   * 现场恢复的次序与现场保存的次序相反&中断在OS中处理:point_right:采用**系统栈**作为中断现场的保存区域
>
>   ![image-20220319154522804](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20220319154522804.png)
>
>   > * 中断相当于一种特殊的操作系统子程序调用，只不过它的发生时刻又不确定性
>   > * 第一层中断发生在用户级别，后层发生在核心级别

**<font color='red'>中断处理程序：</font>**

![image-20220721113350199](D:\markdown projects\pic\image-20220721113350199.png)

> 1. 保存现场&恢复现场过程中需要屏蔽中断（关中断）
>
> 2. 中断处理程序可能会占用通用寄存器，而里面还有被中断程序的信息:point_right:进一步保存现场信息
>
> 3. 中断处理程序需要根据中断码(强迫性中断)和访管号(自愿性中断)进一步分析中断源
>
> 4. 进行相应中断处理
>
> 5. 根据情况决定是否需要**切换进程**
>
>    * 等待：进程由核心运行变为等待态
>
>    * 剥夺：进程由核心运行变为就绪态

**<font color='red'>中断现场和进程切换现场</font>**：

* 中断现场：
  * 保存在**系统栈**中
    * 中断嵌套中，首次中断属于目态级别现场，后中断属于核心级别现场，**都保存在系统栈中**
* 进程切换现场：
  * 保存在**进程PCB**
    * 等待/剥夺由OS完成，故发生在核心态
    * 保存在PCB中的现场都是核心级别的现场，而不是目态程序的现场

> 总结：
>
> * 目态级别现场：保存在系统栈
> * 核心态/管态级别现场：
>   * 进程切换：保存在PCB
>   * 中断嵌套：保存在系统栈

**<font color='red'>进程状态转换的实现(加上中断—目态/核心态现场)</font>**

**![image-20220721113826885](D:\markdown projects\pic\image-20220721113826885.png)**

> ![image-20220721113919450](D:\markdown projects\pic\image-20220721113919450.png)

#### ==处理机调度==

**<font color='red'>处理器调度</font>**：指**CPU资源**在可运行实体之间的分配。进程是CPU资源分配的基本单位。

对处理器的一次连续使用称为**<font color='red'>CPU阵发期</font>**，对设备的一次连续使用称为**<font color='red'>I/O阵发期</font>**。

**<font color='red'>处理器调度过程</font>：**

> **中断事件处理过程完后**，如果需要进行**进程切换**，则转到处理器分派程序**dispatcher**，选择一个上升进程运行

1. **保存下降进程**的现场
   * 寄存器(***PSW,PC,*SP,通用寄存器,地址寄存器**) :arrow_right: PCB
2. **选择上升进程**
   * 按处理机调度算法在就绪队列中选择一个进程
   * 为防止就绪队列为空，系统通常安排一个“闲逛”进程，该进程永远也运行不完，且调度级别最低，当系统中无其它进程时，运行“闲逛”进程

3. **恢复上升进程**的现场
   * PCB :arrow_right: 寄存器
     * **先恢复通用寄存器和地址寄存器,最后恢复PSW,PC**
     * PSW和PC必须用一条指令恢复

**<font color='red'>处理器调度时机</font>：** （1）  运行进程结束（2）运行进程等待；（3）处理机被剥夺。

> **必然**引起进程切换（处理机调度）的中断：
>
> **【主动放弃CPU】**进程自愿结束；进程强行终止（非法指令，越界，kill）；进程等待
>
> **可能**引起进程切换的中断：
>
> **【被动放弃CPU】**时钟；设备I/O中断；系统调用
>
> > 有的系统中不允许剥夺/抢占调度

**<font color='red'>调度算法评价指标</font>：**

* **CPU利用率**：指CPU “忙碌”的时间占总时间的比例

  <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20220321110340173.png" alt="image-20220321110340173" style="zoom: 67%;" />

* **系统吞吐量**：单位时间内完成作业的数量

  <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20220321110526246.png" alt="image-20220321110526246" style="zoom:67%;" />

* **周转时间**/**平均周转时间**

  <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20220321110936084.png" alt="image-20220321110936084" style="zoom:67%;" />

* **带权周转时间**/**平均带权周转时间**

  <img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20220321111114993.png" alt="image-20220321111114993" style="zoom:67%;" />

* **响应时间**：指从用户提交请求到首次产生响应所用的时间

* **等待时间**：指进程/作业处于等待处理机状态时间之和

**<font color='red'>处理器调度算法</font>：**

| 算法                         | 思想                                                         | 可剥夺？                      | 优点                                                         | 缺点                                                      | 考虑等待时间or运行时间？ | 饿死？ | 其他           |
| ---------------------------- | ------------------------------------------------------------ | ----------------------------- | ------------------------------------------------------------ | --------------------------------------------------------- | ------------------------ | ------ | -------------- |
| 先到先服务算法（FCFS）       | min AT                                                       | 非剥夺式                      | “公平”                                                       | 短作业等待时间长                                          | 等待时间                 | 不会   |                |
| 最短作业优先算法（SJF）      | min BT                                                       | 非剥夺式                      | 平均等待时间/周转时间最短（在所有进程都几乎同时到达时）      | 不公平，长作业可能被饿死                                  | 运行时间                 | 会     |                |
| 最短剩余时间优先算法（STRN） | min BT                                                       | 剥夺式                        | 平均等待时间/周转时间最短                                    | 不公平，长作业可能被饿死                                  | 运行时间                 | 会     |                |
| 最高响应比优先算法（HRN）    | max （1+**WT**/BT）                                          | 非剥夺式                      | 对于同时到达的任务，处理时间较短的任务将被优先调度，处理时间较长的任务将随其等待时间的增加而动态提升其响应比，因而不会出现饥饿现象。 |                                                           | 等待时间&运行时间        | 不会   |                |
| 最高优先数优先算法（HPF）    | max 优先级                                                   | (静)非剥夺式    (动/静)剥夺式 | （静态）开销较小   （动态）资源利用率高，公平性好            | （静态）响应速度慢，低优先数进程长期等待   （动态）开销大 | \                        | 会     | 适用于实时系统 |
| 循环轮转算法（RR）           | 轮流                                                         | 剥夺式                        | 公平、响应及时                                               | 时间片过长：响应速度慢；时间片过短：系统开销大            | \                        | 不会   | 适用于分时系统 |
| 多级队列算法（MLQ）          | 多个（多种）就绪队列                                         |                               |                                                              |                                                           |                          |        |                |
| 反馈排队算法（FB）           | 1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br/>2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。<br/>如果此时已经是在最下级的队列，则重新放回该队列队尾<br/>3. 只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片用于进程调度 | 剥夺式                        | （1）短进程优先处理（2）设备资源利用率高（3）系统开销较小    |                                                           |                          | 会     |                |

> BT：CPU  Burst Time/CPU阵发期/运行时间
>
> WT：Waste  Time/等待时间
>
> AT：Arrival  Time/到达时间
>
> ![image-20220727171758402](D:\markdown projects\pic\image-20220727171758402.png)

##### **==调度级别与多级调度==**

**<font color='red'>低级调度（处理器调度）</font>：**将**处理器**资源分配给进程或线程使其真正向前推进。

**<font color='red'>中级调度（内存调度）</font>：**是系统控制并发程度的一个调度级别。当系统并发度过高时，将**内存**中的某些暂时不能运行进程（就绪、等待）暂时交换到外存储器（进程状态为挂起），待以后系统并发度较低时再调回内存。

**<font color='red'>交换</font>**是进程在内存和外存储器之间的调度，交换的目标一般有两个：一是缓解内存空间系统等资源紧张的矛盾，二是减小并发度以降低系统开销。

**<font color='red'>并发度</font>**过高时：

（1）系统开销大（2）响应速度慢

（3）内存等资源紧张（4）进程（线程）频繁进入等待状态 （5）更多死锁

![具有中级调度（增加两种挂起状态）的进程状态转换关系](D:\markdown projects\pic\clip_image006.jpg)

****

**<font color='red'>高级调度（作业调度）</font>**：其职能是将一个**作业**由输入井**调入内存**，并为其建立相应的进程，使其具有运行的资格。

![img](D:\markdown projects\pic\clip_image008.jpg)

> 提交: 输入机向输入井传送
>
> 后备: 在输入井,尚未进入内存
>
> 执行: 分解为进程,在内存处理
>
> 完成: 处理完毕,结果在输出井
>
> 退出: 由输出井向打印机传送

![img](D:\markdown projects\pic\clip_image010.gif)

##### ==**实时调度**==

满足实时任务各自时间约束条件的调度称为**<font color='red'>实时调度</font>**。

**<font color='red'>实时任务</font>**按其发生规律可分为两类：随机性实时任务、**周期性实时任务**。

对于周期性实时任务来说，令![img](D:\markdown projects\pic\clip_image012.gif)为任务![img](D:\markdown projects\pic\clip_image014.gif)的处理时间，![img](D:\markdown projects\pic\clip_image016.gif)为任务P~j~的发生周期，则任务![img](D:\markdown projects\pic\clip_image018.gif)可调度的必要条件为![img](D:\markdown projects\pic\clip_image020.gif)

**<font color='red'>最早截止期优先（EDF）调度优先</font>**选择完成**截止期最早（周期末！不是完成时间）**的实时任务，对于*新到达（周期到达）的实时任务*，如果其完成截止期先于正在运行任务的完成截止期，则重新分派处理器，即**剥夺**。

**<font color='red'>单调速率调度（RMS）</font>**面向周期性实时任务，选择完成**发生周期最短**的实时任务，属于**非剥夺式**调度的范畴。

>  速率单调调度算法可调度的条件：![img](D:\markdown projects\pic\clip_image022.gif)

## 互斥、同步与通信

#### ==并发进程==

<img src="https://img-blog.csdn.net/20170516211055254?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWk5NzczMTM2Nzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="顺序和并发的对比" style="zoom: 67%;" />

> * 并发程序的非封闭性→不可再现性
> * 保持可再现性/Bernstein条件*包含写的不相交*：
>   * **读写集合**互不相交，**写写集合**也不相交<img src="D:\markdown projects\pic\image-20220801222437689.png" alt="image-20220801222437689" style="zoom: 50%;" />
>   * 读集：程序执行期间所***引用*的所有变量**的集合
>   * 写集：程序执行期间所***修改*的所有变量**的集合

并发进程的执行实际上是进程活动的某种交叉，*某些交叉次序可能得到错误结果*。由于具体交叉的形成与进程的推进速度有关，而速度又是时间的函数，因而将这种错误称为**<font color='red'>与时间有关的错误</font>**。

#### ==进程互斥==

多个进程均需访问的变量称为**<font color='red'>共享变量</font>**。(shared <一组变量>)

访问共享变量的程序称为**<font color='red'>临界区</font>**/**<font color='red'>临界段</font>**。(region <一组变量> do <语句> begin ... end;)

一次只允许一个进程使用的资源称为**<font color='red'>临界资源</font>**（打印机、绘图仪、一个临界区）

两个或两个以上的进程不能同时进入关于同一组共享变量的临界区，否则可能发生与时间有关的错误，这种现象称为**<font color='red'>进程互斥</font>**。

> 1. 不允许多个进程同时进入关于**同一组**共享变量的**不同**临界区
>
> 2. 不允许多个进程同时进入关于**同一组**共享变量的**相同**临界区 

**<font color='red'>实现框架</font>**：

![image-20220801224352332](D:\markdown projects\pic\image-20220801224352332.png)

**<font color='red'>进程互斥原则</font>**：

1. 互斥性：当一个进程进入其临界区后，另一进程不能进入其临界区
   * 先检查后上锁

2. 进展性/空闲让进：临界区空闲时，放行一个进入者
   * 进程交替访问、先上锁后检查

3. 有限等待性：一个想要进入临界区的进程在等待有限个进程进入并离开临界区后获得进入临界区的机会 
   * 进程交替访问、先上锁后检查

> * 检查和上锁需要一气呵成
>
> * 各进入区每步骤交错执行试试会不会违反某条原则

##### ==软件实现算法==

(有忙式等待问题：不进入等待状态的等待，即占有cpu等待)

**<font color='red'>Dekkel互斥算法</font>：**

* 设置一个可以表示进程是否想要进入或已经进入临界区的标志位flag[i]并标记turn当前正在临界区的进程号

* 某一进程要进入临界区，需要查看其它进程是否处于临界区（检查对应进程号的标志位flag是否为1），做出等待或进入临界区的动作

![image-20220801232612118](D:\markdown projects\pic\image-20220801232612118.png)

**<font color='red'>Peterson互斥算法</font>**：

* 进入区:1.主动争取;2.主动谦让;3.检查对方是否也想使用,且最后一次是不是己说了“客气话”

![image-20220801232658934](D:\markdown projects\pic\image-20220801232658934.png)

**<font color='red'>Lamport面包店算法</font>**:

> 银行排队取号

* 对每个进程增设一个“摇号”choosing[i]状态，以及摇出的号码number[i]。

* 进程处于“摇号”状态(choosing[i]=true)时不被获准进入临界区。

* 对于“摇号”结束(choosing[i]=false)的进程进行所持有号码的比较，小号先行原则(min number)。

![image-20220801232750721](D:\markdown projects\pic\image-20220801232750721.png)

**<font color='red'>Eisenberg-Mcguire算法</font>**

* 设置一个标志位表示空闲`idle`，准备进入`want_in`，已进入`in_cs`三种状态flag。并标记当前正在临界区的进程号。*（加强Dekker算法）*

* 某一进程想要进入临界区时，判断是否存在其他进程已在临界区

* 退出临界区时找到下一个非空闲的进程

![Eisenberg-Mcguire算法](https://img-blog.csdn.net/20170517130217401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWk5NzczMTM2Nzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

##### ==硬件实现算法==

**<font color='red'>TestAndSet指令</font>:**

* 上锁和检查一气呵成

* 检查（返回此前是否上锁）并上锁

![image-20220801233358510](D:\markdown projects\pic\image-20220801233358510.png)

> * 左边的算法非常简单，但是却不满足有限等待性。（当某一进程退出临界区时，该算法没有指定下一个可以进入临界区的进程）
> * 右边的算法则稍显复杂，但主要只增设了1个标志位，waiting表示是否处于等待态(从而得到其他多个进程的状态，可以指定下一个可以进入临界区的进程)；key表示是否被获准进入临界区（TS指令的返回值）

**<font color='red'>Swap指令</font>**：

* 逻辑和TestAndSet指令一样

![image-20220801233630656](D:\markdown projects\pic\image-20220801233630656.png)

**<font color='red'>“关中断”和“开中断”指令</font>**：

* 在临界区前后关开中断（**UNIX**）

#### ==进程同步==

一组进程，为协调其推进速度，在某些关键点处需要*相互等待与相互唤醒*，进程之间这种*相互制约的关系*称为**<font color='red'>进程同步</font>**，简称同步。

一组进程，如果它们单独不能正常进行，但并发可以正常进行，称这种现象为**<font color='red'>进程合作</font>**。

一段不可间断执行的程序称为原语。

> 同步机制：
>
> * 信号量与PV操作(semaphore and PV operations)
> * 管程(monitor)

#### ==信号量机制==

*（解决进程互斥和同步）*

<font color='red'>**信号量（semaphore）**</font>的数据结构为**一个值和一个指针**，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。

> 当它的值≥0时，表示当前可用资源的数量；当它的值＜0时，其绝对值表示等待使用该资源的进程个数。

信号量的值仅能由**<font color='red'>PV操作</font>**来改变：p操作（wait）：申请一个单位资源，进程进入；v操作（signal）：释放一个单位资源，进程出来

![image-20220802114808354](D:\markdown projects\pic\image-20220802114808354.png)

**<font color='red'>PV操作实现进程互斥</font>**：(s->value初值为1)

1. 分析几个并发进程的关键活动，划定临界区（对不同的临界资源需要设置不同的互斥信号量）

2. 设置<u>互斥信号量**mutex**</u>，初值为1

3. 每个程序中用户实现互斥的P、V操作必须成对出现，**先做P操作，进临界区，后做V操作，出临界区**。若有多个分支，要认真检查其成对性。

**<font color='red'>PV操作实现进程同步</font>**：

1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（**为每一对前驱关系设置一个<u>同步信号量</u>**)

2. 设置同步信号量s,初始为0

3. 在“前操作”之后执行v(S)；在“后操作”之前执行P(S)。[**前V后P/画图：V→P**]

**![image-20220802115206905](D:\markdown projects\pic\image-20220802115206905.png)**

**<font color='red'>经典进程互斥、同步问题</font>**：

1. 找出题目中描述的各个进程和资源，找到每个进程中的流程及流程间的顺序（若某流程使用互斥资源需要互斥P、V；不同进程内的流程操作有前后关系需要同步pv）

![img](D:\markdown projects\pic\clip_image002-16594123759651.gif)

2. 根据流程写P、V代码

> ![image-20220802115337523](D:\markdown projects\pic\image-20220802115337523.png)

**<font color='red'>生产者/消费者问题</font>**

* 同步：对于有那种最多可放n个东西的资源（如缓冲区）可以设置**full=0.empty=n**分别代表占用和空闲位置（队列） ，在放入资源前p操作申请empty-1，放入资源后使用v操作释放full+1；取资源前P（full）-1，取资源后V（empty）+1
  * full指的是缓冲区中资源类型，故多种资源要设不同full：frame=0；wheel=0（原full不需）
  * 若是组合资源，会发生死锁情况
    * 那么对不同资源的empty设最大值（原empty仍需）
    * 生产线问题—车架不超过k-2个；车轮不超过k-1个——设置emaphore S1=k-2;S2=k-1(与empty同操作)

* 不能同时放入或放出的资源，设置互斥信号量mutex=1，再放入放出操作前后使用PV上锁

[类似例题](https://www.bilibili.com/video/BV1wy4y1u7Fk?spm_id_from=333.337.search-card.all.click&vd_source=9353834ccbb19134b505a6b85c6f9287)

**<font color='red'>读者/写者问题</font>**

* 与生产者/消费者的不同在于，写写互斥，写读互斥、**读读不互斥**
  * 最先进入的R执行P，最后离开的执行V


**![img](D:\markdown projects\pic\clip_image002-16594128106102.gif)**

* **检测整型变量count再PV=>前后需要加上PV操作上锁**
* 为防止写者饿死=>公平性解法
  * 写者begin后P（w）结束后V（w）=>w上锁后指示有写者在写
  * 读者上锁前后检测是否有写者存在：P（w）V（w）


**<font color='red'>哲学家进餐问题</font>**

**![img](D:\markdown projects\pic\clip_image002-16594129737133.gif)**

* 一个最简单的解决方法就是持有所有所需资源前后PV上锁

#### ==管程== 

*（解决进程互斥和同步）*

![image-20220802120437720](D:\markdown projects\pic\image-20220802120437720.png)

#### 进程通讯

<font color='red'>**进程通讯模式**</font>:共享内存模式、消息传递模式（直接&间接；对称；非对称）



## 死锁与饥饿

一组进程中的每个进程**均等待此组进程中其他进程所占有的、因而永远无法得到的资源**，这种现象称为进程死锁，简称**<font color='red'>死锁</font>**。

>**<font color='red'>死锁的有关结论</font>：**
>
>1. 参与死锁的进程数目至少为**2**
>2. 参与死锁的所有进程均等待资源[**处于等待态**]
>3. 参与死锁的进程**至少有两个占有资源**
>4. 死锁进程是系统中当前正在运行的进程集合的一个子集

**<font color='red'>死锁的条件</font>**：（1）资源独占（互斥）（2）不可剥夺（3）保持申请（4）循环等待

> 当每类资源（每个进程需要的资源）只有一个时，循环等待是充要条件

**<font color='red'>死锁的处理</font>：**（1）**死锁预防**(静态，破坏四个必要条件之一)（2）**死锁避免** (动态，实时安全检测。如银行家算法) （3）死锁检测（4）死锁恢复

**<font color='red'>资源分配图</font>**: G=(V,E), V=PR,进程 P={p1,p2,…,pn},资源 R={r1,r2,…,rm},

* 申请边pi→rj: pi申请rj；
* 分配边=rj→pi: rj分配pi;

> ![image-20220802121146788](D:\markdown projects\pic\image-20220802121146788.png)

**<font color='red'>资源分配图的约简</font>：**

（1）寻找一个非孤立且没有请求边[指出]的节点pi, 若无算法结束

（2）去除pi的所有分配边[指入]使其成为一个孤立节点;

（3）寻找所有请求边[指出]都可满足的进程pj, 将pj的所有请求边全部改为分配边;

先分配，再看是否满足请求

（4）转步骤1

> **其实就是多轮查看所有进程是否能满足其请求，每轮都将可满足的进程的请求边和分配边删除，使该进程成为一个孤立点，多轮后[直到剩余的每个非孤立点都有请求边]看其是否还剩非孤立进程**

***算法结束时，若所有结点均为孤立结点，则称资源分配图是可以完全约简的，否则称为不可完全约简,即会发生死锁。***

**<font color='red'>死锁的预防</font>：**(预先分配策略、有序分配策略)

1. 预先分配策略：破坏**保持申请条件**。在运行前一次性地向系统申请它所需要的全部资源。在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

>  缺点：（1）资源利用率低（有些资源可能只需使用很短的时间）（2）一次提出申请困难。

2. 有序分配策略：破坏**循环等待条件**。规定进程必须按照资源编号由小到大的次序申请资源。

> 缺点：（1）资源编号困难（2）为保持按序申请,某些暂时不用的资源也需提前申请, 牺牲资源利用率。

**<font color='red'>死锁的避免</font>：**

**<font color='red'>安全状态</font>**：存在一个安全序列的系统

有安全序列：

![img](D:\markdown projects\pic\clip_image002-16594138284374.gif)

![img](D:\markdown projects\pic\clip_image004-16594138284385.gif)

无安全序列：

![img](D:\markdown projects\pic\clip_image006.gif)

**<font color='red'>银行家算法</font>**：资源分配算法、安全性检测算法

![img](D:\markdown projects\pic\clip_image002-16594138778206.gif)

> 不要忘记第一、二步

**<font color='red'>死锁检测</font>**：进程等待时；定时检测；资源利用率降低时检测

**<font color='red'>死锁恢复</font>**：重新启动；终止进程；剥夺资源+进程回退

当**等待时间给进程的推进和响应带来明显的影响**时，就称发生进程**<font color='red'>饥饿</font>**。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时，称该进程被**<font color='red'>饿死</font>**。

忙式等待条件下发生的饥饿,称为**<font color='red'>活锁.</font>**

**<font color='red'>饥饿/饿死vs死锁</font>**：

| 死锁                               | 饥饿/饿死                                                    |
| ---------------------------------- | ------------------------------------------------------------ |
| 死锁进程**处于等待**状态           | 忙式等待的进程**并非处于等待状态**, 但却可能被饿死           |
| 死锁进程等待**永远不会**释放的资源 | 饿死进程等待**可能被释放**,但却不会分给自己的资源,其等待时间没有上界 |
| 死锁一定发生了循环等待             | 饿死则不然                                                   |
| 死锁一定涉及**多个进程**           | 而饥饿或被饿死的进程可能只有**一个**                         |

**<font color='red'>简单组合资源死锁的静态分析</font>**

<img src="D:\markdown projects\pic\image-20220802143703092.png" alt="image-20220802143703092" style="zoom: 67%;" />

> * 不可同时到达：不可能死锁
>   * 环路中有相同被占有资源/环路中被占有某种资源数量超过其资源数量
> * 可同时到达：可能死锁
>   * 死锁位置就在环路的状态上滑条竖线

![image-20220802151214132](D:\markdown projects\pic\image-20220802151214132.png)

**<font color='red'>同种组合资源死锁的必要条件</font>**

![image-20220802151028898](D:\markdown projects\pic\image-20220802151028898.png)

![image-20220802151034790](D:\markdown projects\pic\image-20220802151034790.png)

## 存储管理

### ==存储管理功能==

**<font color='red'>存储分配和去配</font> ：**

* 对象：内存、外存(相同方法)

* 时刻：进程创建、撤销、交换、长度变化(栈溢出, execl)

> 分配表：记录已经分配的区域；空闲表：记录尚未分配的区域

**<font color='red'>存储共享</font>：**是指两个或者多个进程共用内存中的相同区域

* 目的：节省内存、相互通讯

* 内容：代码、数据

**<font color='red'>存储保护</font>**：防止地址越界、防止操作越权

**<font color='red'>存储扩充</font>**：

* 内存、外存结合，虚拟存储体系

* 速度接近内存，容量相当外存

**<font color='red'>地址映射</font>**:将逻辑地址转换为物理地址的过程

* 硬件支持：基址寄存器(base)、限长寄存器(limit)、快表；
* 不能正常完成地址映射时产生中断

### ==内存资源管理==

**<font color='red'>内存分区</font>**:

1. **<font color='red'>根据分区时刻划分</font>**：静态分区和动态分区

* 静态分区：在系统*运行之前*就将内存空间划分为若干个区域。

* 动态分区：在系统*运行的时刻*中划分内存空间

2. <font color='red'>**根据分区大小划分**</font>：等长分区和异长分区

* 等长分区：将存储空间划分为若干个*长度相同*的区域。

* 异长分区：将存储空间划分为若干个*长度不同*的区域。

> *  静态+等长（页式、段页式）
>
> * 动态+异长（段式、界地址）

**<font color='red'>内存分配</font>**:

* 静态等长分区的分配算法

  * 字位映象图/位图<img src="D:\markdown projects\pic\image-20220803230603569.png" alt="image-20220803230603569" style="zoom: 33%;" />

  * 空闲页面表<img src="D:\markdown projects\pic\image-20220803230749697.png" alt="image-20220803230749697" style="zoom:50%;" />

  * 空闲页面链<img src="D:\markdown projects\pic\image-20220803230823495.png" alt="image-20220803230823495" style="zoom:33%;" />

* 动态异长分区的分配算法

  * 最先适应 (First Fit)  *地址由小（0）到大* ——**UNIX**
  * 下次适应(Next Fit)  *地址由小（上次分配处）到大*
  * 最佳适应 (Best Fit)   *长度由小到大*
  * 最坏适应 (Worst Fit)   *长度由大到小*

> 数据结构为空闲页面表，取首个可满足区域
>
> <img src="D:\markdown projects\pic\image-20220803231032943.png" alt="image-20220803231032943" style="zoom:50%;" />

**<font color='red'>碎片</font>**：动态异常分区存储分配可能形成很小的空闲区域

**<font color='red'>紧凑</font>**：移动所有的占有区域，以使所有的空闲区域连成一片（但开销大）

### ==存储管理方式==

> 页框/内存块/物理块：内存空间的分区 *//物理地址*
>
> 页/页面：用户进程空间的分区 *//逻辑地址*
>
> 逻辑地址 → 物理地址

**<font color='red'>界地址管理方式（一维地址）</font>**

* 进程空间与内存空间
  * 内存空间分区：动态异长
  * 进程空间分区：一个进程一个区域，逻辑地址0~l-1

* 所需表目

  * 内存分配表：记录内存中所有已经被分配的区域（PCB中）
  * 空闲区域表：记录内存中尚未分配的区域

* 所需寄存器

  * 基址寄存器b: 保存正在运行进程起始地址
  * 限长寄存器l: 保存运行进程长度

* 地址映射

  *  a与l比较判断是否越界（0≤a≤l-1），越界中断
  * a与b相加得到物理地址

  ![image-20220804105312860](D:\markdown projects\pic\image-20220804105312860.png)

> UNIX中使用的其他技术：
>
> **<font color='red'>双对界</font>**：允许一个进程在内存中占有2个连续的区域
>
> * 代码(I空间)：一对界；数据(D空间)：一对界
> * 硬件需提供两对寄存器。代码区域和数据区域各自的首址寄存器和限长寄存器
>
> **<font color='red'>交换技术</font>**：（中级调度）
>
> * 当外存储器中有可运行进程时，系统试图将其调入内存
> * 当内存空间紧张时，系统将内存中的某些进程移出到外存（就绪、等待挂起）；
>
> **<font color='red'>覆盖技术</font>**：（中级调度）
>
> * 只将全局代码和数据静态装入内存, 其它部分动态装入同一块区域

**<font color='red'>页式管理方式（一维地址）</font>**

* 进程空间与内存空间

  * 内存空间分区：静态等长（页框）
  * 进程空间分区：静态等长（页面）

  <img src="D:\markdown projects\pic\image-20220804110833429.png" alt="image-20220804110833429" style="zoom:50%;" /><img src="D:\markdown projects\pic\image-20220804110957326.png" alt="image-20220804110957326" style="zoom:50%;" />

* 所需表目

  * 页表：每个进程中一个（PCB中）

  <img src="D:\markdown projects\pic\image-20220804152554539.png" alt="image-20220804152554539" style="zoom:33%;" />

  * 总页表（系统一个）

* 所需寄存器

  * 页表首址寄存器b（系统一个）
  * 页表长度寄存器l（系统一个）
  * 快表/TLB (系统一组）

  <img src="D:\markdown projects\pic\image-20220804112216433.png" alt="image-20220804112216433" style="zoom:33%;" />

  > * 页表的页号是连续的，所以可隐藏（在index中）；快表段号不连续
  > * 快表中的逻辑页号是进程中直接给出的p；而页表中的逻辑页号还需要加上页表首址b
  >   * 更新快表时不要更新错误！！

* 地址映射 逻辑地址(p,d)→物理地址(f,d)

  *  查快表：逻辑页号**p**->页框号f
  * 越界判断：由p与l比较（0≤p≤l-1），越界中断
  * 查页表：逻辑页号**p+b**->页框号f
  * 更新快表：(p,f)更新到快表，如满淘汰一个
  * 得物理地址：(f,d)

<img src="D:\markdown projects\pic\image-20220804165206464.png" alt="image-20220804165206464" style="zoom:50%;" /><img src="D:\markdown projects\pic\image-20220804165142664.png" style="zoom:50%;" />

> **<font color='red'>有效访问时间EAT</font>**=快表命中率×(快表访问时间+内存访问时间)+快表不中率×(快表访问时间+(n+1)×内存访问时间) ns
>
> > n是n级页表：例 
> >
> > 98%×(20+100)+2% ×(20+200)ns =122ns
>
> **<font color='red'>多级页表</font>**:
>
> ![image-20220804150743910](D:\markdown projects\pic\image-20220804150743910.png)
>
> **<font color='red'>反置页表</font>**：
>
> 对每个内存页框设置一个表项，表项的**序号为物理页框号f**，表项的内容为**进程标识pid**与**逻辑页号p**的有序对。
>
> ![image-20220804144708406](D:\markdown projects\pic\image-20220804144708406.png)
>
> （整个系统一个：为所有进程所共用）
>
> > 对于反置页表，查找需从头开始查找知道找到，若某页不存在则需要从头查找到尾：
> >
> > * 采用散列/杂凑技术
> >
> >   * 增加一级杂凑表(冲突计数和空闲标志)
> >
> >   * 查找杂凑表与反置页表至少需要两次访问内存
> >
> >   * 同样也可以增加TLB，进一步提高速度
> >
> >     ![image-20220804150049476](D:\markdown projects\pic\image-20220804150049476.png)
> >
> > 

**<font color='red'>段式管理方式（二维地址）</font>**

* 进程空间与内存空间

  * 内存空间分区：动态异长（段内连续，断间不连续）
  * 进程空间分区：静态异长（按照程序的自身逻辑分成若干段，每段一个一个段名，*每段从0开始编址*）

  ![image-20220804151730525](D:\markdown projects\pic\image-20220804151730525.png)

* 所需表目

  * 段表：每个进程中一个（PCB中）

  <img src="D:\markdown projects\pic\image-20220804150935662.png" alt="image-20220804150935662" style="zoom:33%;" />

  * 空闲表（系统一个）

* 所需寄存器

  * 段表首址寄存器b（系统一个）
  * 段表长度寄存器l（系统一个）
  * 快表/TLB (系统一组）

  <img src="D:\markdown projects\pic\image-20220804150915271.png" alt="image-20220804150915271" style="zoom:33%;" />

  > * 段表的段号是连续的，所以可隐藏；快表段号不连续
  > * 快表中的逻辑页号是进程中直接给出的段号s；而段表表中的逻辑段号还需要加上段表首址（s+b）
  >   * 更新快表时不要更新错误！！

* 地址映射 逻辑地址(s,d)→物理地址(b’,d)

  *  查快表：逻辑段号**s**->段首址b‘和段长度l’
  * 越界判断①：由s与l比较（0≤s≤l-1），越界中断
  * 查段表：逻辑段号**s+b**->段首址b‘和段长度l’
    * 越界判断②：由d与l‘比较（0≤d≤l’-1），越界中断
  * 更新快表：(s,b',l')更新到快表，如满淘汰一个
  * 得物理地址：(b',d)

<img src="D:\markdown projects\pic\image-20220804153403841.png" alt="image-20220804153403841" style="zoom:50%;" /><img src="D:\markdown projects\pic\image-20220804153421505.png" alt="image-20220804153421505" style="zoom:50%;" />

> **<font color='red'>段的共享</font>**：共享段允许不同进程的段对其访问
>
> 系统中引入一个**共享段表**：该表记录着所有的共享段
>
> ![img](https://img-blog.csdn.net/20180618184130689?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWRvbmdkb25nMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
>
> 进程段表(n)→共享段表(1)→共享段(1)
>
> * 当一个共享段被初次使用时，被登记在共享段表中，共享计数为1
> * 共享计数减到0时，表示没有进程再使用该段，可以释放所占用的存储空间
>
> **<font color='red'>段的保护</font>**：访问权限的设置
>
> <img src="D:\markdown projects\pic\image-20220804171040561.png" alt="image-20220804171040561" style="zoom: 67%;" />

**<font color='red'>段页式管理方式（二维地址）</font>**

> * 页式优点：消除”碎片“
>
> * 段式优点：便于共享和保护
>
> =>段页式 : 每个进程包含若干段 ; 每个段包含若干页

* 进程空间与内存空间

  * 内存空间分区：静态等长，页框（同页式）
  * 进程空间分区：一个进程<=>若干段 ; **一个段<=>若干页**

  ![image-20220804172229812](D:\markdown projects\pic\image-20220804172229812.png)

* 所需表目

  * 段表：每个进程中一个<img src="D:\markdown projects\pic\image-20220804172305414.png" alt="image-20220804172305414" style="zoom: 33%;" />

  * 页表：每个段一个<img src="D:\markdown projects\pic\image-20220804172344391.png" alt="image-20220804172344391" style="zoom:33%;" />
  * 总页表：系统一个

* 所需寄存器

  * 段表首址寄存器b：保存正运行程序段表首址
  * 段表长度寄存器l：保存正运行程序段表长度
  * 快表/TLB ：一组联想寄存器 (快段表+快页表) <img src="D:\markdown projects\pic\image-20220804172535751.png" alt="image-20220804172535751" style="zoom:33%;" />

* 地址映射 逻辑地址(s,p,d)→物理地址(f,d)

  *  查快表：逻辑段号**(s,p)**->页框号f
  * 越界判断①：由s与l比较（0≤s≤l-1），越界中断
  * 查段表：逻辑段号**s+b**->*页表*首址b‘和*页表*长度l’
    * p越界判断②：由p与l‘比较（0≤p≤l’-1），越界中断
  * 查页表：逻辑页号**p+b‘**->页框号f
  * 更新快表：(s,p,f)更新到快表，如满淘汰一个
  * 得物理地址：(f,d)

<img src="D:\markdown projects\pic\image-20220804173936538.png" alt="image-20220804173936538" style="zoom:50%;" /><img src="D:\markdown projects\pic\image-20220804173943261.png" alt="image-20220804173943261" style="zoom:50%;" />

## 虚拟存储管理

> 虚拟内存管理的工作基于**局部性原理**
>
> * 时间上的局限性
>
> * 空间上的局限性
>
> > 虚拟存储是一种**借助外存空间**，允许一个进程在其运行过程中**部分装入内存**的技术。

### 外存资源管理

**<font color='red'>外存空间</font>**是指磁盘等存储型设备上的存储区域，通常在逻辑上可以划分为4个主要部分

<img src="D:\markdown projects\pic\image-20220805101428121.png" alt="image-20220805101428121" style="zoom:50%;" />

* 外存空间分区：静态等长，块(block)***块是外存分配的基本单位，也是IO传输的基本单位***（如果需求不足一个完整块，会形成块内“零头”——由于外存空间很大，块内零头忽略）

* 外存空间分配：空闲块链（慢）、空闲块表（UNIX）、位图（即静态等长分区的分配算法）

**<font color='red'>进程空间与外存空间对应关系</font>**：

> 上章为进程空间与内存空间对应关系

* 界地址：
  * 每个进程占一组外存连续块（单对界）
  * 每个进程占两组外存连续块（双对界）
* 页式：内存一页，外存一块
* 段式：每段占外存若干连续块
* 段页式：内存一页，外存一块（与页式相同）

### 虚拟存储管理方式

> 无虚拟内存问题：
>
> * 进程全部装入内存，浪费空间（进程活动具有局部性）
>
> * 不能运行比内存大的程序

**<font color='red'>虚拟存储</font>：**运行前，进程部分装入内存，部分（或全部）装入外存；运行时，访问在外存部分动态调入，内存不够淘汰。

![image-20220805161819443](D:\markdown projects\pic\image-20220805161819443.png)

#### 虚拟页式存储管理

* 进程运行前：部分（或全部）装入外存，进程部分装入内存
* 进程运行时：访问在外存部分动态调入，内存不够淘汰
  *  访问页不在内存，发生缺页中断，中断处理程序：
    * 找外存：找到访问页在外存的地址
    * 更新内存：在内存找一空闲页面
      * 如没有，按淘汰算法淘汰一个
      *  如需要，将淘汰页面写回外存，修改页表和总页表
  * 读页：读入所需页面（切换进程）
  * 重新启动中断指令

**<font color='red'>虚拟页式存储的变化</font>：**

* 地址映射

> 以上讨论都是在**内存中每页都存在**的情况下
>
> 虚拟存储由于进程部分在外存，可能发生**缺**页

![image-20220805105341481](D:\markdown projects\pic\image-20220805105341481.png)

* 表目

  * 对页表的改进<img src="D:\markdown projects\pic\image-20220805105830723.png" alt="image-20220805105830723" style="zoom:33%;" />

  * 对快表的改进<img src="D:\markdown projects\pic\image-20220805105912039.png" alt="image-20220805105912039" style="zoom:33%;" />

**<font color='red'>内存页框分配策略</font>**（静态,进程之间）

（1）平均分配 （2）按进程长度比例分配（3）按进程优先级比例分配（4）按进程长度和优先级别比例分配

**<font color='red'>外存块的分配策略：</font>**（静态&动态）

（1）静态分配：外存保持进程的全部页面

>  优点：速度快，淘汰时不必写回(未修改情况) ;缺点：外存浪费

（2）动态分配：外存仅保持进程不在内存的页面

>  优点：节省外存 缺点：速度慢--淘汰时必须写回

**<font color='red'>页面调入时机</font>：**

1. 请调：发生缺页中断时进行调度

2. 预调：将要访问时调入（根据程序顺序行为，不一定准）

**<font color='red'>置换算法</font>：**用于*页淘汰、段淘汰、快表淘汰*

<font color='cornflowerblue'>**最佳淘汰算法（OPT）**</font>：淘汰以后不再需要的或者在最长的时间以后才会用到的页面 *(不可行）*

**<font color='cornflowerblue'>先进先出算法（FIFO）</font>**：淘汰最先进入内存的页面 

> * 实现：队列
> * 出现**Belady异常**：内存物理页面增多，页故障率反而增大

**<font color='cornflowerblue'>最近最少使用算法（LRU）</font>**：淘汰最后一次访问时间距离当前时间间隔最长的页面

> * 实现：栈 （当一页面被访问时, 从栈中取出压到栈顶,满时淘汰栈底）

**<font color='cornflowerblue'>最近不用的先淘汰算法（NUR）</font>**：淘汰最近一段时间内未用过的页面

> * 引入访问位/引用位：访问置1，定时清0
> * 按照以下次序先后淘汰：
> 1. 引用位 = 0， 修改位 = 0 ；直接淘汰
  2. 引用位 = 0， 修改位 = 1 ；存在修改，淘汰之前写回外存
  3. 引用位 = 1， 修改位 = 0  ；直接淘汰
  4. 引用位 = 1， 修改位 = 1 ；存在修改，淘汰之前写回外存

**<font color='cornflowerblue'>最不经常使用的先淘汰(LFU)</font>**：淘汰访问次数最少的页面

**<font color='cornflowerblue'>最频繁使用算法(MFU)</font>**：淘汰访问次数最多的页面

**<font color='cornflowerblue'>二次机会算法（second chance）</font>**：淘汰装入最久且最近未被访问的页面

> * FIFO（链表）**且**  访问位r为0 =>淘汰
> * 否则，再给一次机会暂不淘汰，并*将访问位清0*

<font color='cornflowerblue'>**时钟算法(clock algorithm)**</font>：**环形**的二次机会算法

**<font color='cornflowerblue'>改进的时钟算法</font>**：考虑**修改标志m**的时钟算法/NUR+时钟算法

> * 按照上述NRU次序先后淘汰：
>
> * 改进的时钟算法的步骤总结：
>
>   ①由指针当前位置开始扫描，选择最佳淘汰页面，**不改变引用位**，将第一个遇到的***r=0且m=0***的页面作为淘汰页面；
>
>   ②再次从原位置开始，找***r=0且m=1***的页面，将第一个满足上述要求的页面作为淘汰页面，同时**将扫描过页面的r位清0**；
>
>   ③指针再次回到原位置，重新执行①→②，此时定能找到

**<font color='red'>颠簸(thrashing)</font>：**页面在内存与外存之间频繁地调度

* 原因：（1）分给进程的页框数过少（2）置换算法不合理

* 处理：（1）增加分给进程的页框数（2）改进页面置换算法

> 内存中总保持一个空闲的物理页框:
>
> 若内存总保持一个空闲页框，当发生页故障时，所缺页面可以被立即调入内存，缺页进程只需等待一次I/O传输时间。读入后再立即淘汰一个内存页面，此时可能也需执行一次I/O传输，但对缺页进程来说不需等待，因而提高了响应速度。

**<font color='red'>工作集模型</font>：**进程在一段时间之内活跃地访问页面的集合。为使程序有效运行，工作集应能放入内存。

* 工作集模型与*窗口尺寸、时间*相关 
  * 窗口尺寸过大：浪费内存空间
  * 窗口尺寸过小：页故障率高

**<font color='red'>页故障率反馈模型PFFB</font>**：利用页故障率反馈信息, 实现动态调整页框的分配

#### 虚拟段式存储管理

* 进程运行前：进程运行前，全部装入外存，部分装入内存
* 进程运行时：访问段不再内存时，发生*缺段中断*
  * 紧凑：将内存中的所有空闲区合并
  * 淘汰：将内存中的某段移至外存


**<font color='red'>虚拟页式存储的变化</font>：**

* 地址映射

<img src="D:\markdown projects\pic\image-20220805151507239.png" alt="image-20220805151507239" style="zoom:80%;" />

* 表目

  * 对段表的改进<img src="D:\markdown projects\pic\image-20220805151629120.png" alt="image-20220805151629120" style="zoom:33%;" />

  * 对快表的改进<img src="D:\markdown projects\pic\image-20220805151640599.png" alt="image-20220805151640599" style="zoom:25%;" />

**<font color='red'>段的动态连接</font>**（静态&动态）

（1）静态连接：运行前连接，由link完成 (对程序库进行扫描，将整个程序涉及到的目标模块逐个调入内存并连接在一起)

>  缺点：（1）连接时间长 （2）所产生的目标代码长 （3）所连接的段在程序运行过程中不一定都能用得到

（2）动态连接：运行时连接，由OS完成 (在程序运行过程中需要某一个段时才将该段连接上)

**<font color='red'>段的动态连接的实现&与共享的矛盾</font>**

> 会考吗？？[动态连接的举例](https://mooc1.chaoxing.com/mycourse/studentstudy?chapterId=211262589&courseId=206870959&clazzid=52558052&cpi=155583927&enc=5c269a72ce4697768b6f43e96236bfe4&mooc2=1&openc=22886b783ef3fd71ac6af5eeae8ba525)

虚拟段页式存储管理

> * 段的动态连接
> * 段的共享
> * 段长度的动态变化

* 所需表目

![image-20220805155422827](D:\markdown projects\pic\image-20220805155422827.png)

* 所需寄存器

![image-20220805155641611](D:\markdown projects\pic\image-20220805155641611.png)

* 地址映射

![image-20220805154651995](D:\markdown projects\pic\image-20220805154651995.png)

### Linux存储管理

**<font color='red'>伙伴堆算法管理内存分配</font>**

* 对于块组2^i^按前后顺序两两结合成一对Buddy
  * 0/1:若一个空闲, 另一个全部或部分占用,  则位图相应位置1
  * 其他置0

* 空闲块组指针指向位图为1的页面

![image-20220805163921990](D:\markdown projects\pic\image-20220805163921990.png)

* 

1. 分配：fn为要申请的页框数

* 确定i：2^i-1^＜fn≤2^i^  => 2^i^即为要分配的页框数

* 确定j：从空闲块组i起向上找到有空闲块的快组j(j≥i) =>j即为要分配空闲块的快组

* 调整块组j的空闲链表

* 若j>i,则未分配的空闲页框加入到相应空闲快组链中

  > 比如，要分配4(2^2^)页的内存空间，算法会先从free_area[2]中查看nr_free是否为空，如果有空闲块，就直接从中摘下并分配出去，如果没有空闲块，就顺着数组向上查找，从它的上一级free_area[3]（每块32K）中分配，如果free_area[3]中有空闲块，则将其从链表中摘下，分成等大小的两部分，前四个页面作为一个块插入free_area[2]，后4个页面分配出去

* 修改位图:将2^i^个物理内存空间改为占用，再修改相应的位图

![image-20220805170341717](D:\markdown projects\pic\image-20220805170341717.png)

![image-20220805170405976](D:\markdown projects\pic\image-20220805170405976.png)

2. 释放

* 将对应物理内存空间改为非占用
* 修改对应主存映像图map
* 根据map中空闲块（位图为1的位置）更新空闲快组指针

![image-20220805170417902](D:\markdown projects\pic\image-20220805170417902.png)

## 文件系统

> **<font color='red'>文件</font>**是具有符号名且在逻辑上具有完整意义的信息项的有序序列。
>
> 文件与管理信息资源的程序集合称为**<font color='red'>文件系统</font>**。
>
> **<font color='red'>文件的访问方式</font>：**
>
> * 顺序访问：从文件起始位置开始顺序访问、从文件中间某处开始顺序访问
> * 随机访问：按记录编号随机访问、按关键字(key)随机访问

### 文件的组织

#### 逻辑组织

> 用户看到的文件组织形式

* **<font color='red'>记录式文件</font>**：以记录为基本单位

  * 等长记录 *优点：处理方便，速度快；缺点：空间浪费*
  * 不等长记录 *优点：省空间；缺点：处理不便，速度慢*

  > <img src="D:\markdown projects\pic\image-20220818205417144.png" alt="image-20220818205417144" style="zoom:50%;" />每行就是一条记录

* <font color='red'>**流式文件**</font>：以字节为基本单位 *【现代操作系统都用流式：UNIX 】*

#### 物理组织

> 操作系统看到的*文件数据是如何存放在外存中的* 
>
> 即 逻辑组织(*记录/字节序列*)到磁盘(*块序列*)的映射
>
> <img src="D:\markdown projects\pic\image-20220818213907512.png" alt="image-20220818213907512" style="zoom: 67%;" />

| 结构     | 思想                                     | 目录项内容  |                                                              |
| -------- | ---------------------------------------- | ----------- | ------------------------------------------------------------ |
| 顺序结构 | 一个文件占有若干个连续的磁盘/物理块      | 首块号&块数 | <img src="D:\markdown projects\pic\image-20220818214206992.png" alt="image-20220818214206992" style="zoom:33%;" /> |
| 链接结构 | 一文件可存于不连续块中，块间以指针相连   | 首块号&块数 | <img src="D:\markdown projects\pic\image-20220818215124004.png" alt="image-20220818215124004" style="zoom:33%;" /> |
| 索引结构 | 一文件可存于不连续块中，块号记在索引块中 | 索引块&块数 | <img src="D:\markdown projects\pic\image-20220818215439974.png" alt="image-20220818215439974" style="zoom:33%;" /> |
| 哈希结构 | hash(逻辑块号)=物理块号 & 顺序探查法     |             |                                                              |

索引+链接 【UNIX】

 <img src="D:\markdown projects\pic\image-20220818222219882.png" alt="image-20220818222219882" style="zoom:80%;" />

### 文件目录

**<font color='red'>文件控制块FCB</font>**是文件存在的标志，其中包含系统对文件管理所需要的全部信息。

> 一个文件对应一个FCB，一个FCB就是一个目录项，多个FCB组成**文件目录**

用于检索文件的目录称为**<font color='red'>文件(的)目录</font>**。保存文件目录的文件称为**<font color='red'>目录(的)文件</font>**。

#### 目录结构

**<font color='red'>单级目录</font>**：不可重名

**<font color='red'>二级目录</font>**：不能分组

**<font color='red'>多级目录</font>**：便于文件分类；查找速度快；可以实现文件的链接

> **<font color='red'>根目录</font>：**根节点对应的目录(保存在外存空间中的固定位置)
>
> **<font color='red'>当前目录</font>：**目前正在使用的工作目录
>
> > 文件目录的查找路径：从根节点开始/从当前目录开始

#### 文件目录的改进

> ![image-20220818213154802](D:\markdown projects\pic\image-20220818213154802.png)
>
> <img src="D:\markdown projects\pic\image-20220818211938188.png" alt="image-20220818211938188" style="zoom: 80%;" />
>
> 因为若目录项长度大，需要更多磁盘块存放这些目录项，每次读入一个磁盘块，I/O次数多

**<font color='red'>文件目录的改进</font>**：将文件控制块分为两部分，FCB主部和FCB次部

* 次部/目录项：只保存文件名、文件号（索引号）——保存在目录文件
* 主部/索引节点：保存其他信息——保存在外存inode区域，打开时读入内存

=>1)提高查找速度(减少磁盘I/O) ；2）实现文件的链接=>实现文件共享

### 文件共享

**<font color='red'>文件共享的目的</font>：**（1）节省存储空间（2）进程相互通信

**<font color='red'>文件共享的模式</font>：**（1）异步使用同一文件（2）同步使用同一文件

**<font color='red'>文件共享的实现</font>：**（1）公共目录（2）连接（3）共享说明

### 文件的保护、保密与安全

**<font color='red'>文件的保护</font>**：要防止用户对于文件文件进行非授权的访问

* 方法：（1）存取控制矩阵 （2）访问权限说明

**<font color='red'>文件的保密</font>**：防止文件内容泄露

* 方法：设置口令、密码

**<font color='red'>文件的安全</font>**：防止文件被破坏

* 完全转储：定期将磁盘上文件全部复制到磁带上
  * 恢复只需恢复最后一次转储磁带**（1次）**
* 增量转出：只复制上一次转储之后的修改部分
  * 恢复需要从初始磁带起重新转储到最后一次**（n次）**
* 差分转储：每次备份当天与第一次完全转储不同的部分
  * 恢复只需利用第一次完全转储磁带和最后一次转储磁带**（2次）**

### 文件系统的实现 

#### 内存所需表目

* 系统打开文件表 （系统一个）<img src="D:\markdown projects\pic\image-20220818224732840.png" alt="image-20220818224732840" style="zoom:33%;" />
* 用户打开文件表（每个进程一个）<img src="D:\markdown projects\pic\image-20220818224821797.png" alt="image-20220818224821797" style="zoom: 33%;" />

> 表目关系：
>
> <img src="D:\markdown projects\pic\image-20220818224854795.png" alt="image-20220818224854795" style="zoom:50%;" />

#### 外存空间管理

**<font color='red'>空闲块管理(成组连接)</font>**

100个空闲块为一组，组之间相互链接，最前面的组缓冲到内存。

<img src="D:\markdown projects\pic\image-20220818225311349.png" alt="image-20220818225311349" style="zoom:50%;" />

<img src="D:\markdown projects\pic\image-20220818230158922.png" alt="image-20220818230158922" style="zoom: 67%;" />

> s_nfree=100时
>
> <img src="D:\markdown projects\pic\image-20220818230257272.png" alt="image-20220818230257272" style="zoom:67%;" />

## 设备与I/O管理

**<font color='red'>设备的分类</font>：**（1）IO型设备（与网络设备）与存储型设备（2）独占型设备（块型&字符型）与共享型设备（块型）

#### 设备的物理特性

* **<font color='red'>IO设备的物理特性</font>：**以字符为数据传输的基本单位，传输一字节发生一次中断

* **<font color='red'>存储型设备的物理特性</font>：**以完整的块为数据传输的基本单位，传输一块/多块发生一次中断

**<font color='red'>磁盘的地址转换</font>：**设柱面数为l，盘面数为m，扇区数为n；又设柱面号为i，盘面号为j，扇区号为k；块号为b

<img src="D:\markdown projects\pic\image-20220818235511606.png" alt="image-20220818235511606" style="zoom:50%;" />

* **<font color='red'>三维转一维</font>**：<img src="D:\markdown projects\pic\image-20220818235623447.png" alt="image-20220818235623447" style="zoom: 50%;" />

* **<font color='red'>一维转三维</font>**：<img src="D:\markdown projects\pic\image-20220818235843667.png" alt="image-20220818235843667" style="zoom:67%;" />

> 由于读写延迟，扇区编号是不连续的，交错的。

#### IO传输方式

1. 程序控制查询方式  缺点：忙式等待

2. 中断驱动方式      CPU与设备并行工作，设备多时对CPU打扰多

3. 内存映射方式

4. DMA方式        

5. 通道方式：负责IO的**处理机**

#### 设备分配和去配

#### 设备驱动

#### 磁盘调度

> 由外向内：由小到大

![image-20220819002510065](D:\markdown projects\pic\image-20220819002510065.png)

> * C-SCAN/C-LOOK:只向一个方向扫描（两次）
>
> * SCAN VS. LOOK:
>
>   ![image-20220819003126403](D:\markdown projects\pic\image-20220819003126403.png)
>
> * C-SCAN VS. C-LOOK：
>
>   ![image-20220819003850804](D:\markdown projects\pic\image-20220819003850804.png)

* N-step SCAN（N步扫描）

<img src="D:\markdown projects\pic\image-20220819002534837.png" alt="image-20220819002534837" style="zoom:67%;" />

* 冻结扫描

#### 磁盘IO参数

![image-20220819002638934](D:\markdown projects\pic\image-20220819002638934.png)