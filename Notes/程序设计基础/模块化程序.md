# 模块化程序

## 一元二次方程的根

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201130182007595.png" alt="image-20201130182007595" style="zoom:67%;" />

## 判断能被3，5，7整除—switch妙用

```c
a=b=c=0;
if(n%3==0) a=1;
if(n%5==0) b=2;
if(n%7==0) c=4;
switch(a+b+c){
    case 0:printf("不能被整除")；break；/ 最后加 default:
    case 1:printf("能被3整除")break；
    case 2:
    case 4:
    case 3:
    case 6:
    case 5:
        
}
```

-------

## 求x年*后* n个闰年

```c
x=(x/4+1)*4； //求第一个可能的闰年 类似([x/4]+1)*4
do{
    if((x%4==0&&x%100!=0)||(x%400==0)){ //闰年判别：能被4整除不能被100整除||能被400整除
        printf x;
        n--;
    }
    x+=4;
}while(n!=0);
```

-----

## 素数

**1不是素数**

```c
bool check_prime(int n){
    for(i=n/2;i>=2;i--){ //'n/2'  '从2开始！！！'
        if(n%i==0)
            return false;
    }
    return true;
}
```

-----

## 哥德巴赫猜想

```c
bool goldbach(int n){
    flag=false;
    for(num=2;num<n/2;num++){   //从2到n/2
        if(check_prime(num)&&check_prime(n-num)){  //check_prime是检查素数函数
            printf(n=num+(n-num));
            flag=true;
        }
    }
    return flag;
}
```
---
## 公因数和公倍数

```c
int gcd(int m,int n){
    do{
        t=m%n;
        m=n;
        n=t;
    }while(t==0)
    return m;
}
int gcd(int m,int n){
    if(n==0) return m;    //返回值即为gys
    else return gcd(n,m%n);
}
gbs=m*n/gys;
```

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201130190402068.png" alt="辗转相除法" style="zoom:67%;" />

----

##判断不可约分数

```c
if(gcd(i,j)==1)   //使用公因数函数
```

---

## 进制的转换

```c
#include <stdio.h>
#include <string.h>
char a[129];  //用来保存进制转化结果
int i=0;
 /****将b1进制转化为10进制****/
int change_ten(char num[],int b){
    int n=0,i,len;
    len=strlen(num);
    for(i=0;i<len;i++){
            if(num[i]<='9'&&num[i]>='0') n=n*b+num[i]-'0';//*b不是*10
            else if(num[i]<='Z'&&num[i]>='A') n=n*b+(num[i]-'A'+10);//+10！！！！
                 else  n=n*b+(num[i]-'a'+10);
    }
    return n;
}
/****将10进制转化为b2进制(用递归倒序输出余数)****/
void change_result(int num,int b){
     int y=0;          //y=余数
     if(num){
          change_result(num/b,b);  
          y=num%b;
          if(y>=0&&y<=9) a[i++]=y+48; //48=-i+(int)'1'
          else a[i++]=y+55;    //55=-10+(int)'A'
     }
}
/****将10进制转化为b2进制(用循环正序输出余数-逆转)****/
void change_result(int num,int b){
     int i=0,y;          //y=余数
     while(num){
        y=num%b;
        if(y<10) a[i++]=y+48;
        else a[i++]=y+55;
        num=num/b;
     }
    a[i]='\0';
    inverse();
}
int main()
{
    char num[129];
    int num_10;
    int b1,b2;
    scanf("%d%d",&b1,&b2);
    getchar();
    gets(num);
    num_10=change_ten(num,b1);
    change_result(num_10,b2);
    a[i]='\0';
    printf("%s",a);
    return 0;
}
```



## 斐波那契数列

```c
v=1;
u=2;
printf(v,u)
while(结束条件){
    w=u+v;
    u=w;
    v=u;
    printf(w)
}
```

---

## 阶乘

```c
int factorial(int n){
    s=1;
    for(i=1;i<=n;i++){
        s=s*i;
    }
    return s;
}
```

---

## 跳出多重循环

**在控制条件中增加 `&&flag`

---

## 四舍五入

`a=(int)((float)n+0.5)`

---

## 浮点数精度

`fabs(n)>=1e-5`

##输入相关

#### 清除缓冲区

```c
if(scanf("%d", &n) != 1) {
				printf("请输入有效选项!\n");
				while(getchar()!='\n');   //清除缓冲区
                continue;
		}
```



#### 反复输入数据

```c
scanf()
    while(结束条件){
    ···//操作//
        scanf()
    }
```

---


#### 滤掉前导字符

```c
ch=getchar();
while(!(符合条件的)&&ch!='#'){
    ch=getchar();
}           //此时的ch符合条件
//+反复输入数据//
```

---

#### 滤掉所有不符合条件字符

```c
ch=getchar();
while(ch!='#'){    //注意！！！!!这里不能写'\0'因为这不是字符串不会自动补‘\0’结尾不是题目所给的结束符如'#'就是'\n'
  while(!(符合条件)&&ch!='#'){ //注意！！！！！千万别漏ch!='#'不然可能会一直等待输入
    ch=getchar();
  }               //滤掉前导字符；此时的ch已符合条件
  while(符合条件){
    //操作//       //（对单个字符操作/保存进数组）
    ch=getchar();
  }
}
```

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201202120400287.png" alt="image-20201202120400287"  />此处操作是打印ch

####读入单词

> 若想要将符合条件的字分段保存/当作单词(中间不符条件的即看作分隔符)

```c
char string[100];
int read_word(){        //读入单词并返回字符串长度
    int j=0;
    ch=getchar();
    while(!(符合条件)&&ch!='#'){
        ch=getchar();
    }
    while(符合条件){
        str[j++]=ch;     //j++在此语句结束后才生效--正确
        ch=getchar();
    }
    str[j]='\0';  //ch并非gets要自己补'\0'
    return j;
}
int main(){
    j=read_word();
    while(j!=0){
        //操作//
        j=read_word;  //反复读入单词
    }
}
```

> > 返回[回文字](####回文字)

#### gets函数

```c
scanf("%d",&n);
getchar();       //前加getchar()滤掉回车！！！！！
gets(array);
```

####scanf&gets读字符串

> * scanf**结束符**是空格或换行符
>
> * gets**结束符**是换行符

* 无空格：`scanf("%s",str)`

*  有空格：`gets(str)`

**同理先输入其他类型在输入字符时**

```c
scanf("%d %c",a,ch);//空格！！！！！
```

#### 多个字符串输入

```c
 char *str[5],str0[5][100];
     int i;
     for(i=0;i<5;i++)
        str[i]=str0[i];//填满躯壳
     for(i=0;i<5;i++)   
        scanf("%s",str[i]); //也可以只用数组
```

* 多个字符串：scanf
* 多行字符串：gets

#### 输入多行数据（有结束符）

> 包括多组测试数据。每组数据最多100个整数占用一行，以数字0结束(不计入100个整数里)。测试数据不超过20组，最后一行只包括-1，表示输入数据结束。

```c
int main(void){
   int i,j;
   int x,a[101];
   scanf("%d",&x);
   while(x!=-1){     //用两层while循环外层做-1停止数据读取
        i=0;
    while(x!=0){     //内层做0停止行数据读取
        a[i++]=x;
        scanf("%d",&x); 
    }
    /***操作***/
    scanf("%d",&x); //注意还有一个读入是行首数据（外层while的）
   }
   return 0;
}
```

---

## 输出格式相关

#### puts函数

**会自动在结束部分加'\n'**

#### 结尾去除多余字符

* 自设标记k

```c
int k=0;
for(i=0;i<n;i++){
    if(k++>0) printf(" %d",n);
    else  printf("%d",n);
}
```

#### 输出图形

> *“每个数字占用2位英文字符宽度，宽度不足2位的的在数字左侧补空格--右对齐”*

* 空格：两个
  数字：“%2d”（若是左对齐:"%-2d")

****

#### 时间输出

```c
printf("%02d:%02d:%02d",a,b,c);
```

> 输出格式：小时、分钟、秒都都是两位整数，数位不足用零补充

---

## 迭代法

牛顿好牛

----

## 求三角形重心

* 坐标/3
* 中线交点

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201130212444256.png" alt="image-20201130212444256" style="zoom:67%;" />

---

## 杨辉三角形

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201201132525532.png" alt="image-20201201132525532" style="zoom:67%;" />


| 1    |      |      |      |      | row0+1 |
| ---- | ---- | ---- | ---- | ---- | ------ |
| 1    | 1    |      |      |      | row1+1 |
| 1    | 2    | 1    |      |      | row2+1 |
| 1    | 3    | 3    | 1    |      | row3+1 |
| 1    | 4    | 6    | 4    | 1    | row4+1 |
####从左至右

`a[i]=b[i]+b[i-1]`

```c
for(i=0;i<n;i++){        //打印第i行
    for(j=0;j<n-i-1;j++) printf("   "); //3个空格
    for(j=0;j<=i;j++){             
        if(j==0||j==i)
            a[j]=1;
        else
            a[j]=b[j-1]+b[j];   
        printf("%-6d",a[j]);  //左对齐x**
    }
     for(j=0;j<=i;j++) b[j]=a[j];  //只能打印该行完毕后才能将a拷贝到b
    printf("\n");
}
```

####从右至左

`a[i]=a[i]+a[i-1]`

```c
for(i=0;i<n;i++){
    for(j=0;j<n-i-1;j++) printf("   "); //3个空格
    for(j=i;j>=0;j--){              //打印第i行
        if(j==0||j==i)
            a[j]=1;
        else 
            a[j]=a[j-1]+a[j];  //由于a[j-1]=a[j-1]+a[j-2]用不到改变的a[j]
        printf("%-6d",a[j]);  //左对齐x**
    }
    printf("\n");
}
```

---

##矩阵

#### 矩阵乘积

```c
int a[m][p],b[p][n],c[m][n];
void matrixproduct(float a[m][p],float b[p][n],float c[m][n] ){
     for(i=0;i<m;i++)
         for(j=0;j<n;j++){  //不用纠结i,j与m,n的关系
             e=0;           //计算c每个元素e都要清零
             for(k=0;k<p;k++)
                 e=e+a[i][k]*b[k][j]; //左行乘右列
             c[i][j]=e;
         }
}
```

---

#### 高斯消去法   *n×(n+1)*

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201203133853159.png" alt="image-20201203133853159" style="zoom: 80%;" /><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201203133924738.png" alt="image-20201203133924738" style="zoom: 80%;" />

```c
#include<stdio.h>
/////define/////
float matrix[10][11];
float x[10];
/////gaoss/////
void gaoss(int n){
     int i,j,k;
     float temp;
/////transform-to-up-triangle/////
     for(j=0;j<n-1;j++){            //与pad图不同：i，j交换->i:行控制/j:列控制
         for(i=j+1;i<n;i++){           
            temp=matrix[i][j]/matrix[j][j];  //注意是matrix[j][j]!!!!
            for(k=j;k<n+1;k++)
                matrix[i][k]=-temp*matrix[j][k]+matrix[i][k];   //第j列从j+1~n行依次消去元素a[i][j]变为0
         }
     }
////回代求根////
     for(i=n-1;i>=0;i--){
         temp=0;
         for(j=i+1;j<=n-1;j++)
            temp=temp+matrix[i][j]*x[j];      //求已解的解与系数相乘的和
         x[i]=(matrix[i][n]-temp)/matrix[i][i];
     }

}
/////input/////
int main (){
    int i,j;
    int n;
    scanf("%d",&n);
    for(i=0;i<n;i++)
        for(j=0;j<n+1;j++)
        scanf("%f",&matrix[i][j]);
/////solve/////
    gaoss(n);
/////output////
    for(i=0;i<n;i++)
        printf("%.2f ",x[i]);
    return 0;
}
```

#### 转置矩阵

```c
void T(int matrix[][10],int n){
    int i,j;
    int temp;
    for(i=0;i<n;i++){
        for(j=i+1;j<n;j++){   //这里j从i+1开始！！！也就是表示遍历右上角元素
            temp=matrix[i][j];
            matrix[i][j]=matrix[j][i];
            matrix[j][i]=temp;
        }
    }
}
```

#### n维矩阵的格式输出

```c
for(i=0;i<n;i++){
        for(j=0;j<n;j++){
            if(j==n-1)
               printf("%d\n",matrix[i][j]); 
            else
               printf("%d ",matrix[i][j]);
        }
}
```

#### 矩阵*M×N*的旋转与对称

* 顺时针90°: `new_arr[i][j]=arr[M-1-j][i]`                      ***行列互换 +列 (j)补差***

* 顺时针180°: `new_arr[i][j]=arr[N-1-i][M-1-j]`           ***行列补差***
* 顺时针270°: `new_arr[i][j]=arr[j][N-1-i]`                   ***行列互换 +行 (i)补差***
* 左右对称: `new_arr[i][j]=arr[N-1-i][j]`                       ***行补差***
* 上下对称: `new_arr[i][j]=arr[i][M-1-j]`                       ***列补差***

***这里用 `M-1` or `N-1` 去补差取决于减数是 `j` or `i` —对应***

> *以下为N×N方阵*

* 主对角线对称:`new_arr[i][j]=arr[j][i]`                          ***行列互换***
* 副对角线对称:`new_arr[i][j]=arr[N-1-j][N-1-i]`         ***行列互换+行列补差***

---

## 八皇后的本质解

> 运用回溯法与深度优先处理

```c
#include <stdio.h>
#include<stdlib.h>
#include<math.h>
int m=1;
int a[9];
int count;
int s[92][9]={0};
#define N 8
/*****比较是否有旋转与对称的解*****/
/***关于主对角线对称(行列互换)***/
int compare_symmetryMD(int i){  
     int j;
     for(j=1;j<=N;j++){
        if(a[s[i][j]]!=j) return 0;
     }
     return 1;
}
/***关于副对角线对称(行列互换+行列补差)***/
int compare_symmetryVD(int i){  
     int j;
     for(j=1;j<=N;j++){
        if(a[N+1-s[i][j]]!=N+1-j) return 0;
     }
     return 1;

}
/***关于左右对称(行补差)***/
int compare_symmetryLR(int i){  
     int j;
     for(j=1;j<=N;j++){
        if(a[N+1-j]!=s[i][j]) return 0;
     }
     return 1;
}
/***关于上下对称(列补差)***/
int compare_symmetryUD(int i){  
     int j;
     for(j=1;j<=N;j++){
        if(a[j]!=N+1-s[i][j]) return 0;
        }
     return 1;

}
/***顺时针旋转270(行列互换，行补差)***/
int compare_270(int i){  
     int j;
     for(j=1;j<=N;j++){
         if(a[s[i][j]]!=N+1-j) return 0;
     }
    return 1;

}
/***顺时针旋转180(行列补差)***/
int compare_180(int i){  
     int j;
     for(j=1;j<=N;j++){
         if(a[N+1-j]!=N+1-s[i][j]) return 0;
     }
    return 1;

}
/***顺时针旋转90(行列互换，列补差)***/
int compare_90(int i){  
     int j;
     for(j=1;j<=N;j++){
         if(a[N+1-s[i][j]]!=j) return 0;
     }
    return 1;
}
/****与前所有s数组内(过滤过)比较是否有重复解****/
int equal_check(){
     int i;
     for(i=1;i<=count;i++){                  if(compare_90(i)||compare_270(i)||compare_180(i)||compare_symmetryUD(i)||compare_symmetryLR(i)|| compare_symmetryMD(i)||compare_symmetryVD(i)) return 0;
     }
     return 1; 
}
/****过滤:非重复解/第一个解保存进数组s****/
void filt(void){
    int i;   
      if(count==0||equal_check()==1){
            count++;
            for(i=1;i<=8;i++)
               s[count][i]=a[i];
        }
        else return;

}
/****不合规则/N行全符合规则就变换位置****/
void change(void){
      while(a[m]==N) m--;//若列在最后一个，退行直到该行列不在最后一个(用来找位置)
      a[m]++; //不在最后一个则列+1(注意！！！！不在while语句里)
}
/****符合规则且还没到N行时就延伸****/
void extend(void){
     m++; //进行
     a[m]=1; //初始化为1
}
/****检查r行前是否符合规则****/
int check(int r){
     int i;
     for(i=1;i<r;i++){
        if(a[r]==a[i]) return 0;  //在同行->不合规则
        if(fabs(a[r]-a[i])==fabs(r-i)) return 0; //在斜对角线->符合规则

     }
     return 1;
}
int main(void){
    int i,j;
    a[0]=0;//a[0]无用
    a[1]=1;//a[1]从1开始搜索
    while(m>0){
        if(check(m)){
            if(m==N){     //即当N行全部合格时
                filt();   //过滤重复解
                change(); //换位进行下一个的查找 
            }else{
                extend(); //m<N时,延伸
            }
        }else{
            change(); //不合规则换位
        }
    }
/****output****/
    for(i=1;i<=count;i++){
        printf("No%d:",i);
        for(j=1;j<=8;j++)
            printf("%d ",s[i][j]);
        if(i!=count) printf("\n");
    }
    return 0;
}
```

输出：![image-20201228231630147](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201228231630147.png)

[跳回正整数分解](######回溯法与深度优先处理)

---
## 分类

#### 选择排序

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201201194413601.png" alt="image-20201201194413601" style="zoom:67%;" />

```c
void principal_sorting(int a[size]){
      for(i=0;i<size;i++){
          min=a[i];
          for(j=i;j<size;j++){
              if(min>a[j])
                  min=a[j];
          }
          a[j]=a[i]; //注意这里是交换a[i]和min!!!不是单纯将min赋值给a[i]!!!!
          a[i]=min;
      }
  }
```

  #### 冒泡排序

```c
void bubble_sort(int a[size]){
     int flag=1;
    while(flag){
        flag=0;
        for(i=0;i<size-1;i++) //size-1!!!!!
           if(a[i]>a[i+1]){
               temp=a[i];
               a[i]=a[i+1];
               a[i+1]=temp;
               flag=1;
           }
    }
}
```

#### 插入排序

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201201212523544.png" alt="image-20201201212523544" style="zoom:67%;" />

```c
void sequence_sort(int a[size]){
    for(i=1;i<n;i++){ //i=1!!!!
        j=i-1;
        while(a[j]>a[i]&&j>=0) j--; //此时的j就是j
        temp=a[i];
        for(k=j+1;k<i;k++) a[k+1]=a[k]; //blue
        a[j+1]=temp;  //red
    }
}
```

----

##检索

#### 顺序检索

```c
 int search(int a[],int n,int key){
     for(i=0;i<n&&a[i]!=key;i++);
     if(i==n)
         return -1;
     else 
         return i;  //返回其下标
 }
```

#### 二分检索

> 适用于已排序的数据

```c
int half_search(int a[],int n,int key){
    int low,middle,high;
    low=0;
    high=n-1;
    while(high>=low){   //>=!!!
        middle=(high+low)/2;
        if(key==a[middle])
            return middle;
        else{
            if(key>a[middle])
                low=middle+1;  //+1!!!!
            else
                high=middle-1;  //-1!!!
        }
    } 
    reurn -1;
}
```
----
## 回文

#### 回文字

```c
bool check_huiwenzi(char a[]){
     length=strlen(a);
    i=0;
    j=length-1;
    while(j>i){
        if(a[i]!=a[j])
            return false;
        i++;
        j--;
    }
    return true;
}
```

> > 输入部分参考 [读入单词](####读入单词)

#### 回文数

```c
bool check_huiwenshu(int num){
    int s=0;
    do{
        t=num%10;
        temp=num/10;
        s=s*10+t;
    }while(temp!=0);
    if(s==num)
        return true;
    else
        return false;
}
```
## 自守数

>若一个整数a满足条件a * a的尾数等于a则称a为自守数，例如25 * 25=625，76 * 76=5776， 9376 * 9376=87909376

```c
#include<stdio.h>
/****检查自守数****/
int check_number(int num){
    long b;
    b=num*num;
    while(num!=0){
         if(num%10!=b%10)
            return 0;
         num=num/10;
         b=b/10;
    }
    return 1;
}
```

----
## 栈 *stack*

### 基本操作

**声明**

```c
typeofelement stack[size];  //栈
int top;                    //栈顶指针->指向栈顶第一个！！空单元！！
```

**压入**

```c
bool push(type x){  //也可是void型
    if(top>=size)
        return false;
    else{
        stack[top]=x;
        top++;
        return true;
    }
}
```

**弹出**

```c
type pop(){
    if(top<=0) //<=0!!如果等于0即栈全空
        return 错误信号;
    else{
        top--;
        return stack[top];  //pop后此top指向栈顶第一个空单元
    }
}
```

#### 配对

> 括号的配对(以#为结束符)

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201202135024405.png" alt="image-20201202135024405" style="zoom:67%;" />

```c
#include<stdio.h>
#include<stdlib.h>
char stack[30];
int top=0;
void push(int ch){
     stack[top]=ch;
    top++;
    return;
}
char pop(void){
    top--;
    return stack[top];
}
void check(char ch){  //易错！！！
    char temp;
    temp=pop();    
    if(temp=='#'){
        printf("右括号多");
        exit (0);         //exit（0）别忘记！！！
    }
    else
        if(temp!=ch){
            printf("括号交叉");
            exit (0);     //exit（0）别忘记！！！
        }       
        else
            return ;
}
int main (void){
    char ch;
    push('#');
    ch=getchar();
    while(ch!='#'){
        swith(ch){
            case '(':
            case'[':
            case'{':push(ch);break;
            case')':check('(');break;
            case']':check('[');break;
            case'}':check('{');break;
        }
        ch=getchar();
    }
    ch=pop;
    if(ch=='#')
        printf("匹配");
    else
        printf("左括号多");
    return 0;
}
```

***典型错误***

```c
void check(char ch){
    if(pop()=='#')     //第一次pop（）
        printf("右括号多"); //没有exit
    else
        if(pop()!=ch)          //第二次pop（）->相当于pop了两次！！！！！绝不可以！！！
            printf("括号有交叉")；//没有exit
        else
            return 0;
}
```

---

## 队列 *queue*

### 基本操作

**声明**

```c
typeofelement queue[size];//队列
int inpointer=0,outpointer=0,count=0;//送入指针(指向第一个空单元)，取出指针(第一个要取出的数据)，计数器
```

**进队**

```c
bool putx(type x){
    if(count>=size)
        return false;
    else{
        queue[inpointer]=x;
        inpointer=(inpointer+1)%size;
        count=count+1;
        return true;
    }
}
```

**出队**

```c
bool getx(type *x){          //也可设全局变量/返回值设为x/statisc
    if(count<=0)
        return false;
    else{
        x=queue[outpointer];
        outpointer=(outpointer+1)%size;
        count=count-1;
        return true;
    }
}
```

#### 约瑟夫环(out的实现)

```c
#include<stdio.h>
#include<stdlib.h>

int main (void){
    int m,n;
    int count,i=0,k=0;
    int queue[100]={0};
    scanf("%d%d",&n,&m);
    count=n;
    for(i=0;i<n;i++)
        queue[i]=1;  //1即还活着
    i=0;
    while(count!=0){
        if(queue[i]!=0){   //当他没死时才能报数
            k++;           //k用来报数
            if(k==m){    
            queue[i]=0;  //记为死亡
            printf("%d ",i+1);
            count--;      //记人数-控制循环条件
            k=0;          //下一个人从1开始报
            }
        }
        i=(i+1)%n;      //队列的+1->因为是循环"%n！！！！！！"（不是%count）
    }
    return 0;
}
```

----

##二维数组传参

| 声明定义（形参类型）      | 调用                      | 函数内操作                                              |
| ------------------------- | ------------------------- | ------------------------------------------------------- |
| 指针（int *p,int m,int n) | (int*)数组名/数组名[0]    | `a[i*m+j]` `*(p+i*m+j)`                                 |
| 二维数组`(int a[][n])`    | 数组名                    | `a[i][j]` `*(a[i]+j)` `*(*(a+i)+j)`  `*((int*)a+i*n+j)` |
| 数组指针`(int (*a)[n])`   | 数组名                    | `a[i][j]` `*(a[i]+j)` `*(*(a+i)+j)`  `*((int*)a+i*n+j)` |
| 指针数组`(int *a[])`      | 数组名（前有声明int *a[]) | `*((int*)a+i*n+j)`                                      |
| 二级指针`(int **a,int n)` | (int**)数组名             | `*((int*)a+i*n+j)`                                      |

**实际上2 3等价**

> 且当4 5实参为指针a时，操作时可用a[i]

> > ```c
> > #include <stdio.h>
> > 
> > void subfun(int n, char *subargs[])
> > {
> >  int i;
> >  for (i = 0; i < n; i++) {
> >  	printf("subargs[%d] = %s\n", i, subargs[i]);
> >  }
> > }
> > 
> > void main()
> > {
> >    char *args[3] = {"abc", "def", "ghi"};
> >    subfun(3, args);
> > }
> > 
> > ```
> >
> > *test用函数*

## 循环右移k位

####使用两个数组

```c
void move_right(int a[],int size，int k){
    int b[size],i;
    for(i=0;i<n;i++)
        b[i]=a[i];
    k=k%size;                 //注意这里必须有个‘周期’
    for(i=0;i<size;i++)
        a[i]=b[(i+3)%size];   //相当于队列加法
}
```

#### 使用一个数组

```c
void move_right(int a[],int size，int k){
    int k0,i,temp;
    k=k%size;
    for(k0=0;k0<k;k0++){    //（循环右移一位）*k次
        temp=a[size-1];
        for(i=size-1;i>0;i--) a[i]=a[i-1];   //循环右移一位
        a[i]=temp;
    }
}
```

## 删除重复元素

```c
int delete_repeat(int a[],int n){
     int i,j,k;
     for(i=0;i<n-1;i++){
         for(j=i+1;j<n;j++){
            if(a[i]==a[j]){
                for(k=j;k<n-1;k++)
                    a[k]=a[k+1];
                n--;            //直接n--相当与删除最后一个元素（不用再设一个变量h用n-h，反正在函数内）
                j--;            //覆盖后回格
            }
         }
     }
     return n;
}
```

## 数域的构建

>(1) 1∈M ；
>
>(2) 若 x ∈M , 则 2x+1 ∈M , 3x+1 ∈M ；
>
>(3) 没有别的整数属于集合 M
>
>编程序按递增顺序生成并输出集合 M 的前n项

**穷举法**

```c
count=1;
a[0]=1;
num=1;
while(count<n){
    num++;      //利用穷举法，自然递增
     for(i=0;i<count;i++)
         if(num==2*a[i]+1||num==3*a[i]+1){
             a[count++]=num;
             break;   //注意这里的break一旦发现该数符合条件，就跳出“循环”，造成重复保存
         }
}
```

## 统计单词个数

> “单词”是指连续不含空格的字符串，各单词之间用空格分隔，空格数可以是多个

```c
int count_words(char str[]){
    int i,k=0;
    for(i=0;str[i+1]!='\0';i++){        //遍历字符串数组直到碰到‘\0’
        if(str[i]==' '&&str[i+1]!=' ')  //若前一个有空格后一个非空格则计数
            k++;          
    }
    return k+1;           //k是空格数，+1即为单词数
}
```

## 访问(遍历)二维数组的元素

**当作二维数组**

```c
int p,a[m][n];
for(p=0;p<m*n-1;p++){
    a[p/n][p%n]
}
```

**当作一维数组**

```c
int *p;
int a[m][n];
for(p=a[0];p<a[0]+m*n-1;p++){
    *p
}
```

##字符串

#### 字符串的复制（赋值）

***指针作为形参时，不可以将指针的地址改变，只可以对指针指向的值做改变***

> 将s所指字符串复制到str1中

```c
strcpy(str1,s); //对-指针指向的值做改变

v=-1;
do{
     v++;
     str1[v]=sp[v];
}while(sp[v]!=0); //对-循环赋值（或用指针或者双指针都可）
```

```c
str1=s;        //错-指针的地址改变

*(str1)=*s；     //错-指针指向一个数组（如字符串）-会使空数组str1=s[0]（当如果指针只指向一个值是对的）
```

#### 字符串排序

```c
void sort_string(char *a[],int n){
    char *temp;  //声明char temp[20]也可，此时后面还可用strcpy
/****exchange****/
    temp=a[i];
    a[i]=a[k];
    a[k]=temp;    //对于数组可以改变其地址，因为数组传递规则
}
```

#### 求字符串长度

```c
int str_length(char *str){
    int i=0;
    while(*(str+i)!='\0'){
        i++;
    }
    return i;
}
```

#### 字符串部分删除

> 使用自编函数char * str_delete(char *s, int v, int w)从字符串s的第v个字符开始删除w个字符，并将处理后的字符串首地址以函数返回值带回调用点

```c
char* str_delete(char *s,int v,int w){
    int i;
    static char str[256];  //一定要加static！！！否则则传了函数内声明值的地址（函数执行结束后收回）造成错误
/****v前的字符直接复制***/
    for(i=0;i<v-1;i++)
        *(str+i)=*(s+i);
/****再将v+w后的字符拼接到str后****/
    strcpy(str+i,s+v+w-1);//重要！！！！str+i即为str后的第一个地址，起拼接作用
    return str;
}
```

---

 ## 复数加法乘法

```c
/****复数类型结构体声明****/
typedef struct complex{
    float real_part,imaginary_part;
}complex;
/****复数加法****/
complex complex_add(complex x,complex y){
    complex new;
    new.real_part=x.real_part+y.real_part;
    new.imaginary_part=x.imaginary_part+y.imaginary_part;
    return new;     //返回结构体变量
}
/****复数乘法****/
complex complex_mul(complex x,complex y){
    complex new;
    new.real_part=x.real_part*y.real_part-x.imaginary_part*y.imaginary_part;
    new.imaginary_part=x.real_part*y.imaginary_part-x.imaginary_part*y.real_part;
    return new;
}
/****input****/
void input(complex *x,complex *y){   //输入函数一般都传指针（不用加&）
     scanf("%d%d%d%d",x->real_part,x->imaginary_part,y->real_part,y->imaginary_part);
}
/****output****/
void output(complex x){
    if(x.imaginary_part>0) printf("%d+%di",x.real_part,x.imaginary_part);
    else
        if(x.imaginary_part<0) printf("%d%di",x.real_part,x.imaginary_part);
        else
            printf("%d",x.real_part);
}
```

---

## 规则合并两个数列

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201223115742589.png" alt="image-20201223115742589" style="zoom:67%;" /> >*此处规则是递减排序*

***注意这里是while循环***

## 计算调和级数（通分减小误差）

> 要求结果是分数形式（![image-20201223120420254](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201223120420254.png)）

```c
#include<stdio.h>
/****分子分母相加****/
void add(int i,int *a,int *b){
    *a=(*a)*i+(*b);
    *b=(*b)*i;
}
/****求公因数****/
int gcd(int m,int n){
    if(n==0) return m;
    else return gcd(n,m%n);
}
/****约分****/
void reduce(int *a,int*b){
    int gys;
    gys=gcd(*a,*b);
    *a=(*a)/gys; 
    *b=(*b)/gys;
}
int main (void){
    int a=0,b=1,n;           //a=numerator b=denominater注意！！！这里a相当于和单元 b相当于积单元->赋初值1
    int i;
    scanf("%d",&n);
    for(i=1;i<=n;i++){
        add(i,&a,&b);
        reduce(&a,&b);
    }
    printf("    %d\n",a);
    printf("Hn=----\n");
    printf("     %d",b);
}
```

##Debruijn问题

> 如图所示由2^3 个二进制数字0和1组成一个环。使 2^3 个 3 位的二进制数正好在环中各出现一次。图中目前所示顺序是：0、1、2、5、3、7、6、4。设计生成这样环的程序，环由 2^n 个二进制数字组成，恰好包含 2^n 个互不相同的n位二进制数。
>
> 输入：n（n<=4)
>
> 输出：按照字典序输出符合的答案(当出现多组本质不同的解时，仅输出字典序中最小的那个序列)；每行数字间以一个西文空格间隔，行末有一个换行符。

<img src="https://p.ananas.chaoxing.com/star3/origin/694e4a9e75c45b7c2cf92469c9d03ba6.png" alt="Exp08-Enhance02.png" style="zoom:67%;" />

```c
#include <stdio.h>
#include<stdlib.h>
#include<math.h>
int bin[16]={0};  //用来保存2进制的穷举数
int n;
/******二进制转换******/
void binary(int num){
    int i;
     for(i=pow(2,n)-1;i>=0;i--){
        bin[i]=num%2;
        num=num/2;
     }
}
int main(void){
    int count,num,i,j,t;
    int k,s=0;
    int queue[16]={0};//标记2^n个n位的二进制数正好在环中各出现一次
    scanf("%d",&n);
    t=pow(2,n);    //代表有多少个需对应的数
    count=t;    
    for(i=0;i<16;i++)
        queue[i]=1;  //1：代表还未出现
    num=0;     //用来穷举数-环的二进制数对应的十进制数
    while(num<pow(2,t)){  //最大数是2^n^(n-1)-全为1时
/***********num转换二进制分别保存进数组bin***********/
        binary(num);   //num->binary_array
/****判断环是否对应2^n个互不相同的数0~2^n-1****/
        for(i=0;i<=t-1;i++){  //对bin数组做一个n元素的滑动窗口
            s=0;
            for(k=0;k<n;k++) s=s+bin[(i+k)%t]*pow(2,n-1-k); //将滑动窗口的n个元素二进制->十进制
            for(j=0;j<t;j++){     //j代表需对应的数
              if(j==s&&queue[j]){ //是否对应一个数(0~2^n)且该数不能被对应过（未out）
                  queue[j]=0;     //out的应用
                  count--;        //count表示还有n个数未被对应
                  break;
              }
            }
        }
/****如果包含2^n个互不相同的n位二进制数则打印****/
        if(count==0){
            for(i=0;i<t;i++){
                    if(i) printf(" %d",bin[i]);
                    else printf("%d",bin[i]);
            }
            exit (0);
        }
/****对下一个num的判断初始化！！！部分条件****/
        for(i=0;i<16;i++) queue[i]=1;
        count=t;
/****判断下一个数****/
        num++;
    }
    return 0;
}


```



##递归

> 深度优先算法用递归写起来比较方便。递归有**两个重要元素**：
>
> - 递归出口
> - 递归的表达式
>
> 递归对技巧性要求很高，大多数时候其关系式并不是很容易找到。而且对递归的设计与理解，很容易钻到具体细节的实现上。递归的优点就是可以让一些复杂问题简单化，把具体的细节交给计算机执行。**而过分钻研细节，就非常容易陷进去理不清头绪**。**对于递归的学习应该是多看看经典的递归写法，遇到类似问题会模仿写就行了，不一定要自己创造出一个递归关系式。**

#### 汉诺塔

六十四片->六十三片：把a针上的64 片金片,移动到b 针上, 移动过程中可以利用c针。

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201223125240312.png" alt="image-20201223125240312" style="zoom: 80%;" />

=>递推关系： 把x 针上的n片金片,移动到y 针上, 移动过程中可以利用z 针。

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201223130420385.png" alt="image-20201223130420385" style="zoom:80%;" />

递归出口：金片n=0时

```c
#include<stdio.h>
/*step2:移动一步*/
void move_one(char m,char n){
     printf("%c->%c\n",m,n);
}
/*x 针上的n片金片,移动到y针上,移动过程中可以利用z针*/
void move(int n,char x,char y,char z){
    if(n>0){
        move(n-1,x,z,y);  //1.
        move_one(x,y);    //2.
        move(n-1,z,y,x);  //3.
    }
    return;
}
int main (void){
    int n;
    scanf("%d",&n);
    move(n,'a','b','c');
    return 0;
}
```

#### 齿轮

 >三齿轮啮合问题。设有三个齿轮互相衔接， 求当三个齿轮的某两对齿互相衔接后到下一次这两对齿再互相衔接， 每个齿轮最少各转多少圈

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201223143509297.png" alt="image-20201223143509297" style="zoom: 50%;" />

```c
lowestcm3(x,y,z){
    lowestcm2(lowestcm2(x,y),z);
}
```

#### 打印所有组合C(n,m)

> 从前n个自然数1,2,...,n中取r个数做组合，按递增排序打印所有组合。

n->n-1：从1开始n个数取r个数进行组合

​                       ①从1开始从这n个数取一个数i(1~n-r+1)

​                       ②从i开始取r-1个数进行组合

递推关系：从s开始取j个数进行组合

​                        ①从s开始从这j个数取一个数i(s~n-j+1)

​                        ②从i+1开始取j-1个数进行组合

递归出口：当进行组合的个数(j)为一时

```c
#include<stdio.h>
int r,n;
int a[10]={0};      //数组保存之前的i，当j=1(出口)时，打印
void combination(int s,int j){ //s=start即取数起点；j代表取j个数进行组合
     int i,k;
     for(i=s;i<=n-j+1;i++){ //①从s开始取数i
        a[r-j]=i;          //r-j恰好是第i的位置(j=1时也要保存i)
        if(j>1)
            combination(i+1,j-1);
        else{
            for(k=0;k<r;k++) printf("%-2d",a[k]);
            printf("\n");
        }
     }
}
int main(void){
    scanf("%d%d",&n,&r);
    combination(1,r);//j=r时，start=1,剩下的数为r
    return 0;
}
```

[跳回正整数分解](######递归与回溯)

#### 截木条

>给定一个长度为n的木条，将其在大致2/5的位置截断，得到2个长度仍为整数的木条；如果新得到的木条的长度仍旧超过规定长度k，将继续按照上述方法处理得到的木条，直到所有木条的长度都不大于k。编写程序，用递归方法计算一个长度为n的木条，当规定长度为k时，其经过上述截断过程会得到多少根木条。

> 其中：n、k均为正整数，n>10，k>3，且假设木条截断所得短木条长度四舍五入为正整数，长木条长度为总长减去短木条长度。

````c
#include <stdio.h>
int k;
int amount(int a[],int count){
    int i;
/****遍历数组a若长度大于k就截****/
      for(i=0;i<count;i++){
        if(a[i]>k){
/****将新截的木棍长度保存进数组a****/
            a[count]=(int)((float)a[i]*2/5+0.5);//a[count]就是“未开发”数组的第一个位置
            a[i]=a[i]-a[count];//将原来那个被截的木棍长度用新的木棍（长的)长度覆盖覆盖掉
            i--;    //由于此时a[i]是新的木棍长度所以要-1看看他
            count++;//数组a“已开发”的长度+1
            }
      }
      return count;
}

int main()
{
   int n,num;
   int a[100]={0}; //用a数组保存
   scanf("%d%d",&n,&k);
   a[0]=n;
   num=amount(a,1);
   printf("%d",num);
   return 0;
}
````

----

#### 求解最长字符串

```c
#include<stdio.h>
#include<string.h>
int max;
char* StrMax(char *StrArr[ ],int n){ //注意第一个argument的传参
    if(n==0) return StrArr[max];  //顺序很重要！！！要放在第一个！若和下面那条交换位置，就比较了StrArr[0-1]
    if(strcmp(StrArr[max],StrArr[n-1])<0) max=n;
    return StrMax(StrArr,n-1);//
}
int main (void){
    char str[100][100];
    int n,i;
    char *str1[100];
    char *str_max;
    scanf("%d",&n);
    max=n-1;
    getchar();
    for(i=0;i<n;i++){
            gets(str[i]);
            str1[i]=str[i];
    }
    str_max=StrMax(str1,n-1);//第二个参数用来计数
    printf("%s",str_max);
    return 0;

}
```

---

####正整数分解

######回溯法与深度优先处理

> (仿[八皇后](##八皇后的本质解)方法)

```c
#include<stdio.h>
int n;
int a[15]={0}; // 存放划分结果
int m= 0; // 数组指针
/****输出****/
void output(){
    printf("%d=",n);
    for(int i=0;i<=m;i++){
        if(i) printf("+%d",a[i]);
        else printf("%d",a[i]);
    }
    printf("\n");

}
/****检查sum与n的大小关系****/
int check(){
    int sum=0;// 拆分项累加和
    for(int i=0;i<=m;i++){
        sum=sum+a[i];
    }
    if(sum>n) return 1;
    if(sum<n) return -1;
    return 0;
}
/****sum>n(不符合条件)时换位(回溯、加值)****/
void change(){
    while(check()==1) m--;//回溯直到sum<=n(符合条件)
    a[m]++;  //试探下一个值
}
/****sum<n(不符合条件)时延伸****/
void extend(){
    m++;     
    a[m]=a[m-1];  //从前一数的值开始，保证递增排序
}//注意！！！延伸不需考虑a[m]++，由于是“深度优先处理”：优先先扩张m，不是a[m]！！！！(在回溯时会慢慢一步步扩张a[m])

int main (void){
    scanf("%d",&n);
    a[0]=1;  //从1开始
    while(m>=0){
        if(check()==1) change();  //sum>n时换位(回溯、加值)
        else if(check()==-1) extend(); //sum<n(不符合条件)时延伸
              else{    //sum=n时
                output();   //输出
                change();   //换位(回溯、加值)
              }
    }
    return 0;
}

```

输出结果：![image-20201229210532857](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201229210532857.png)(n=4)

######广度优先处理

```c
#include<stdio.h>
int n;
int a[15]={0}; // 存放划分结果
int m= 0; // 数组指针
/****输出****/
void output(){
    printf("%d=",n);
    for(int i=0;i<=m;i++){
        if(i) printf("+%d",a[i]);
        else printf("%d",a[i]);
    }
    printf("\n");

}
/****检查sum与n的大小关系****/
int check(){
    int sum=0;// 拆分项累加和
    for(int i=0;i<=m;i++){
        sum=sum+a[i];
    }
    if(sum>n) return 1;
    if(sum<n) return -1;
    return 0;
}
/****sum>n(不符合条件)时归零、减值****/
void change(){
    if(a[m]==1) m=0; //由于是“广度优先处理”，故若最右值为1(不能再减)，直接回到根列
    a[m]--;  //对最右/根数减值
}
/****sum<n(不符合条件)时延伸****/
void extend(){
    m++;
    a[m]=a[m-1];//从前一数的值开始，保证递减排序
}

int main (void){
    scanf("%d",&n);
    a[0]=n;
    while(a[0]>0){
        if(check()==1) change();    //sum>n(不符合条件)时归零、减值
        else if(check()==-1) extend();//sum<n(不符合条件)时延伸
              else{     //sum=n时
                output();   //输出
                change();   //换位(归零、减值)
              }
    }
    return 0;
}
```

输出结果：![image-20201229213959451](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20201229213959451.png)(n=4)

######递归与回溯

>(仿[组合数](####打印所有组合C(n,m))法)

递推关系：从s开始将数r分解，已分解个数为count

​                        ①从s开始取一个数i(s~r)

​                        ②从s开始将数r-i分解，已分解个数为count+1

递归出口：sum=N，输出，回溯；sum<N,回溯；

```c
#include<stdio.h>
int N;
int a[15]; // 存放划分结果
/****输出****/
void output(int count){
    printf("%d=", N);
    for (int k=0; k<=count-1; k++) printf("%d+", a[k]);
    printf("%d\n", a[count]);
}
/****检查sum与n的大小关系****/
int check(int count){
    int sum=0;// 拆分项累加和
    for(int i=0;i<=count;i++){
        sum=sum+a[i];
    }
    if(sum>N) return 1;
    if(sum<N) return -1;
    return 0;
}
/****分解剩余数r(算法主体部分)****/
void division (int s,int r,int count) {//s=start r=rest count是记录已分解的个数用来计算sum&输出
    int i;
    for(i=s;i<=r;i++){  
        a[count]=i;  //保存已分解数 注意！！！！千万别在这写count++下面传count(still searching for the reason)
        if(check(count)==-1) division(i,r-i,count+1);  //sum<N-继续从i开始将剩余数分解
        else if(check(count)==0){output(count);return;}//sum==N-输出+回溯
              else return;  //sum>N-回溯

    }
}

int main ()
{
    scanf ("%d", &N);
    division (1,N,0);//初始时，start=1,rest=N,count=0
    return 0;
}
```

(以下别人的方法：没搞透彻)

```c
#include<stdio.h>

int N;

int s[31]; // 存放划分结果
int m = 0; // 数组指针
int sum = 0; // 拆分项累加和

void division (int i);
void output();

int main ()
{
    scanf ("%d", &N);
    division (1);
    return 0;
}

void division (int i) {
    if (sum == N) {output(); return;}
    if (sum > N) return;  //回溯
    for (int j=i; j<=N; j++) {  //sum<N
        s[m]=j;
        m++;  //下一层 
        sum+=j;
        division(j);
        sum-=j;  //sum>=n时返回一步sum减去j，还原s至上一步
        m--;     //还原m至上一步
    } // 算法主体
}

void output(){
    printf("%d=", N);
    for (int k=0; k<m-1; k++) printf("%d+", s[k]);
    printf("%d\n", s[m-1]);
}
```

## 链表

### 基本操作

#### 链表节点声明

```c
typedef struct LinkNode{
    int data;
    struct LinkNode *next;
}node,*pnode;
```

#### 初始化

```c
void initial(pnode head){
    *head=NULL;
}
```

#### 销毁

```c
void release(pnode head) {//释放单链表空间,head是单链表首结点指针
     pnode p;
     while(head!=NULL){
         p=head;
         head=head->next;
         free(p);
     }
}
```

#### 打印

```c
void print(pnode head){
    pnode p=head;   //有哨兵项:p=head->next
    while(p!=NULL){
        printf("%d",p->data);
        p=p->next;
    }
}
```

#### 创建单向链表

######头插

> 单链表的头部插入都需要改变表头指针的指向，所以不分情况可以直接操作

```c
/*外层循环调用headpush函数-创建链表*/
pnode head;
void headpush(int x){  //此时head必须为全局变量！！！否则函数返回与形参内都需有head
    pnode p;
    p=(pnode)malloc(sizeof(node));
    p->data=x;
    p->next=head;   //联系
    head=p;         //改变表头指针的指向
}
```

###### 尾插（以0结束）

```c
pnode backpush(void){
    pnode p,head,rear;
    int x;
    p=head=rear=NULL;
    scanf("%d",&x);
    while(x!=0){
        p=(pnode)malloc(sizeof(node));
        p->data=x;
        p->next=NULL;    //处理尾节点
        if(rear==NULL){  //判断为空链表
           head=p;
           rear=p;
        }else{           //判断为非空链表
          rear->next=p;  //联系
          rear=p;        //改变表尾指针的指向
        }
        scanf("%d",&x);
    }
    return head;
}
```

######创建有n个节点的链表（尾插）

```c
/****无哨兵项****/
pnode creatlink(int n){
    pnode head,p,rear;
    head=p=rear=NULL;
    while(n>0){
        p=(pnode)malloc(sizeof(node));
        scanf("%d",&p->data);
        p->next=NULL;    //处理尾节点
        if(rear==NULL){  //判断为空链表
           head=p;
           rear=p;
        }else{           //判断为非空链表
          rear->next=p;  //联系
          rear=p;        //改变表尾指针的指向
        }
        n--;
    }
    return head;  //返回链表头
}
/****有哨兵项****/
pnode creatlink(int n){
    pnode head,p,rear;
    p=(pnode)malloc(sizeof(node)); //头节点单独处理
    head=rear=p;
    while(n>0){
        p=(pnode)malloc(sizeof(node));
        scanf("%d",&p->data);
        rear->next=p;
        rear=p;
        n--;
    }
    rear->next=NULL;//尾节点单独处理
    return head;  //返回链表头
}
```

#### 遍历

```c
/****双指针****/
pnode p0,p;
p0=NULL;  //注意:此时不能用 p0->next=p1;联系二者=>p0是空，违法操作
p=head;
while(p!=NULL){
    //操作
    p0=p;
    p=p->next;
}
/****单指针****/
pnode p;
p=head;
while(p!=NULL){
    //操作
    p=p->next;
}
```

#### 查找位置

###### 已知key元素

```c
p0=NULL;
p=head;
while(p!=NULL&&p->data!=key){  //重点
    p0=p;
    p=p->next;
 }
```

###### 递增排序

```c
while(p!=NULL&&n>p->data){
    p0=p;
    p=p->next;
}
```

###### 中间节点

> 若中间结点有两个，则设定前一个为中间位置结点

*相当总数/2后四舍五入*

```c
int k=1;
while(k<(int)((float)count/2+0.5)){
    p=p->next;
    k++;
}
```

###### 已知位置

> 正数第k个：pos=k;
>
> 倒数第k个：pos=count-k-1
>
> ***第一个指针从链表的头指针开始遍历，在第k-1步之前，第二个指针保持不动；在第k-1步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。***

```c
 for (i=1;i<pos&&p!=NULL;i++) {
   p0=p;
   p=p->next;  //pm->no.m
 }
```

####插入 

```c
p=(pnode)malloc(sizeof(node));
p->data=x;
if(r==head){      //插入在头节点之前
      p->next=head;
      head=p;
}else{ 
      p->next=r;   //联系
      r0->next=p;  //联系
      p0=r;        //改变
}
```

#### 删除

```c
if(r==head){   //头删除
   head=head->next;
   free(r);
   r=head;
}else{
   r=r->next;
   free(r0->next);
   r0->next=r;
}
```

#### 交换

```c
/*****交换p->next，q->next(有中间变量g)*****/
if(p!=NULL&&q!=NULL&&m!=n){ //索引为m,n的结点位于链表中间
    g=p->next;
    p->next=q->next;
    q->next=g;
}
/*****交换p0->next(p),q0->next(q)*****/
if(p==head&&q!=head){  //p0==NULL
   q0->next=p;
   head=q;
}
if(q==head&&p!=head){  //q0=NULL
    p0->next=q;
    head=p;
}
if(q!=head&&p!=head){  //q0=NULL
    p0->next=q;
    q0->next=p;
}
/*****重新配对p0,p,q0,q(若无后续操作可以不要)*****/
p=p0->next;
q=q0->next;
```

### 例题

####实时保存排序

> 输入以0为结束符的0~1若干实数，按递增顺序实时保存

```c
#include <stdio.h>
#include <math.h>
#include<stdlib.h>

typedef struct LinkNode{
    float data;
    struct LinkNode *next;
}node,*pnode;

pnode insert(void){
    float n;
    pnode head,rear,r,r0,p;  //r,r0标记插入位置;p为工作指针
/*****构造0*****/
    head=(pnode)malloc(sizeof(node));
    head->data=0;
/*****构造1*****/
    rear=(pnode)malloc(sizeof(node));
    rear->data=1;
/*****连接0、1*****/
    head->next=rear;
    rear->next=NULL;   //不要忘记！！！
/****以0结束创建单向链表****/
    scanf("%f",&n);
    while(fabs(n)>1e-5){
        r=head;
        r0=NULL;
/*********查找位置*********/
        while(r!=NULL&&n>r->data){
            r0=r;
            r=r->next;
        }
/********插入********/
        p=(pnode)malloc(sizeof(node));
        p->data=n;
        r0->next=p;
        p->next=r;
        r0=p;
        scanf("%f",&n);
    }
    return head;
}

void print(pnode head){
    pnode p=head;   //有哨兵项:p=head->next
    while(p!=NULL){
        printf("%f ",p->data);
        p=p->next;
    }
}

void release(pnode head) {//释放单链表空间,head是单链表首结点指针
     pnode p;
     while(head!=NULL){
         p=head;
         head=head->next;
         free(p);
     }
}

int main(void) {
   pnode head;
   head=insert();
   if(head!=NULL)print(head);
   else printf("NULL");
   release(head);
   return 0;
}
```

#### 插入排序

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20210103212213960.png" alt="image-20210103212213960" style="zoom:67%;" />

```c
pnode insert_sort(pnode head){
    pnode p,r,r0,temp;//p是无序链表头;head是有序链表头;r,r0标记p插入有序链表的位置;temp用来指向独立的p
    p=head->next;    //p是无序链表头,从第二个数开始
    head->next=NULL; //head是有序链表头,此时,头即是尾
    while(p!=NULL){
/*****把p独立出来！！！！！！！！！！！！！！！(不然后面疯狂牵扯他一塌糊涂)用temp指向它******/
        temp=p;
        p=p->next; 
/*****找有序链表中插入位置*****/
        r=head;
        r0=NULL;
        while(r!=NULL&&(r->data<temp->data)){r0=r;r=r->next;}
/*****分情况插入*****/
               if(r==head){
                   temp->next=head;
                   head=temp;
                }else{
                    temp->next=r;
                    r0->next=temp;
                    r0=temp;
                }
        }
        return head;
}
```

**对于遍历用的p若要改变其连接顺序一定用temp标记后直接看下一个（p=p->next;），否则改变连接后，p=p->next就不是原来的下一个了**

***即遍历指针不能当作工作指针***

#### 多项式加法

![image-20210103221542967](C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20210103221542967.png)<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20210103211208529.png" alt="image-20210103211208529" style="zoom:67%;" />

```c
struct LinkNode{
    float x;
    int exp;
    struct LinkNode *next;
}node,pnode;
/*****构造新项放在r后面*****/
void add(int exp0,float x0,pnode r){
    pnode p;
    p=(pnode)malloc(sizeof(node));
    p->exp=exp0;
    p->x=x0;
    r->next=p;
    p->next=NULL;
}
/*****多项式加法*****/
pnode combine(pnode p,pnode q){
    pnode head,r;    //r是工作指针
    r=head=(pnode)malloc(sizeof(node)); //申请哨兵变量
    while((p!=NULL)&&(q!=NULL)){     //两个多项式都没到尾
        if(p->exp>q->exp){       //q的幂次小于p
            add(p->exp,p->x,r);
            p=p->next;
        }else{
            if(p->exp<q->exp){   //p的幂次小于q
                add(q->exp,q->x,r);
                q=q->next;
            }else{              //p的幂次等于q
                add(q->exp,q->x+p->x,r);  //注意exp是相同不要相加！！
                q=q->next;
                p=p->next;
            }
        }
        r=r->next;
    }
    while(p!=NULL){         //p多项式都没到尾
        add(p->exp,p->x,r);
        p=p->next;
        r=r->next;
    }
    while(q!=NULL){        //q多项式都没到尾
        add(q->exp,q->x,r);
        q=q->next;
        r=r->next;
    }
}
```

#### 删除重复节点

```c
void delete_same(pnode head){
    pnode p,r,r0;
    p=head;
    while(p!=NULL){   //不是p->next!=NULL!!!!!!
        r0=p;
        r=p->next;
        while(r!=NULL){
            if(r->data==p->data){
                r=r->next;
                free(r0->next);
                r0->next=r;
            }else{
                r0=r;
                r=r->next; //注意！！这里一定是else否则会漏掉一项
            }
        }
        p=p->next;
    }
    return;
}
```

#### 构造法雷序列

>打印n 阶法雷序列。对任意给定的自然数n ， 把所有不可约分数按递增顺序排列起来， 称该序列为n 阶法雷序列Fn 。

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20210103234309022.png" alt="image-20210103234309022" style="zoom:67%;" /><img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20210103234335876.png" alt="image-20210103234335876" style="zoom:67%;" />（例：F8）

<img src="C:\Users\Jiang Linyi\AppData\Roaming\Typora\typora-user-images\image-20210103234921630.png" alt="image-20210103234921630" style="zoom:67%;" />

```c
struct  farlei_item {
    int   numerator, denominator;   // 分子、分母
    struct  farlei_item* next;   // 连接部分
}node,*pnode;
pnode farlei(int n){
    int i,j;
    pnode r,r0,p,head,rear;
    head=rear=r0=r=p=NULL;
    if(n<1) return NULL; //如果n<=0,则没有法雷序列
/*****构造0/1*****/
    head=(pnode)malloc(sizeof(node));
    head->numerator=0;
    head->denominator=1;
/*****构造1/1*****/
    rear=(pnode)malloc(sizeof(node));
    rear->numerator=0;
    rear->denominator=1;
/*****联系0/1，1/1*****/
    head->next=rear;
    rear->next=p;
    for(i=2;i<n;i++) //i=denominaor
        for(j=1;j<i;j++){  //j=numerator
            if(gcd(i,j)==1）{  //j/i不可约分
/**********找位置**************/
                r=head->next;
                r0=head;
                while(j*(r->denominator)>i*(r->numerator)){
                    r0=r;
                    r=r->next;
                }
/************插入*************/
                p=(pnode)malloc(sizeof(node));
                p->numerator=j;
                p->denomonator=i;
                p->next=r;
                r0->next=p;
                r0->next=r;
            }
        }
     return head;
}
               
```

#### 删除所有的x

```c
cxxxxxxxxxx22 1pnode DelAll(pnode head,int x){2    pnode r,r0;3    r=r0=NULL;4    while(head&&head->data==x){ //单独处理头节点5        r=head;6        head=head->next;7        free(r);8    }9    r=head->next; //此时head肯定不等于x，故可以从下一个开始遍历10    r0=head;      //别忘将r0=head11    while(r!=NULL){12        if(r->data==x){13            r=r->next;14            free(r0->next);15            r0->next=r;16        }else{17            r0=r;18            r=r->next;19        }20    }21    return head;22}
```

